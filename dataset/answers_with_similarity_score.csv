,Unnamed: 0.1,Unnamed: 0,id,answer,score_me,score_other,score_avg,bert_distance,bert_similarity_score,normalized_bert_score,elmo_similarity_score,normalized_elmo_score,gpt_similarity_score,normalized_gpt_score,gpt2_similarity_score,normalized_gpt2_score,roberta_similarity_score,normalized_roberta_score,xlnet_similarity_score,normalized_xlnet_score,universal_similarity_score,normalized_universal_score
0,0,0,1.1,High risk problems are address in the prototype program to make sure that the program is feasible.  A prototype may also be used to show a company that the software can be possibly programmed.,4,3,3.5,0.027617693,0.972382307,0.964759214,0.296179891,0.382294898,0.994956427,0.942334127,0.999945775,0.936062385,0.946896871,0.858263531,0.976181685,0.940391951,0.797439158,0.747505018
1,1,1,1.1,To simulate portions of the desired final product with a quick and easy program that does a small specific job. It is a way to help see what the problem is and how you may solve it in the final project.,5,5,5,0.028398752,0.971601248,0.963762565,0.504172325,0.564838685,0.993547302,0.926222854,0.999949599,0.940572044,0.937217672,0.83242898,0.960641388,0.901500586,0.806125045,0.758332093
2,2,2,1.1,A prototype program simulates the behaviors of portions of the desired software product to allow for error checking.,5,3,4,0.013918638,0.986081362,0.98223951,0.786471367,0.812597389,0.999015482,0.988743473,0.999982503,0.979368663,0.976815201,0.93811793,0.981896304,0.954693437,0.912328899,0.890716636
3,3,3,1.1,"Defined in the Specification phase a prototype stimulates the behavior of portions of the desired software product.  Meaning, the role of a prototype is a temporary solution until the program itself is refined to be used extensively in problem solving.",5,5,5,0.016510129,0.983489871,0.978932711,0.617771268,0.664538374,0.992065537,0.909281038,0.999987911,0.985745126,0.951294193,0.870000332,0.968883813,0.922128194,0.863870442,0.830312513
4,4,4,1.1,It is used to let the users have a first idea of the completed program and allow the clients to evaluate the program. This can generate much feedback including software specifications and project estimations of the total project.,3,3,3,0.022429645,0.977570355,0.971379277,0.457669884,0.52402599,0.995158092,0.944639873,0.999979264,0.97554984,0.912757201,0.76714204,0.979667088,0.949114569,0.795169771,0.744676196
5,5,5,1.1,To find problem and errors in a program before it is finalized,2,2,2,0.052239478,0.947760522,0.933341272,0.096652053,0.207180033,0.994498782,0.937101635,0.999930053,0.917524652,0.980484184,0.947910737,0.980848327,0.952070755,0.687546194,0.610521949
6,6,6,1.1,"To address major issues in the creation of the program. There is no way to account for all possible bugs in the program, but it is possible to prove the program is tangible. ",3,2,2.5,0.027791083,0.972208917,0.964537964,0.279286951,0.367468872,0.9956336,0.950076614,0.999963253,0.956671111,0.968060446,0.914750793,0.979587957,0.948916535,0.746570349,0.684096358
7,7,7,1.1,you can break the whole program into prototype programs to simulate parts of the final program,5,5,5,0.037214339,0.962785661,0.952513682,0.350325704,0.429815769,0.990592191,0.892435484,0.999973837,0.969151352,0.984019239,0.95734608,0.977624856,0.944003651,0.776617467,0.721550498
8,8,8,1.1,#NAME?,5,2,3.5,0.036029518,0.963970482,0.954025539,0.339949876,0.420709463,0.996323246,0.957961709,0.999985167,0.982509979,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
9,9,9,1.1,Simulating the behavior of only a portion of the desired software product.,5,5,5,0.011372924,0.988627076,0.985487898,0.868911147,0.884950356,0.998604615,0.984045821,0.999951501,0.942814114,0.977591217,0.940189178,0.968046604,0.920032983,0.94770062,0.934807965
10,10,10,1.1,A program that stimulates the behavior of portions of the desired software product.,5,5,5,0.01170969,0.98829031,0.985058177,0.825634778,0.846969011,0.998502601,0.982879441,0.999985426,0.982815084,0.984878102,0.959638453,0.989707503,0.974241853,0.930559814,0.913441719
11,11,11,1.1,A program that simulates the behavior of portions of the desired software product.,5,5,5,0.011456907,0.988543093,0.985380734,0.911478996,0.92230987,0.998502601,0.982879441,0.999985426,0.982815084,0.984878102,0.959638453,0.989707503,0.974241853,0.944817185,0.931213725
12,12,12,1.1,To lay out the basics and give you a starting point in the actual problem solving.,2,2,2,0.035905242,0.964094758,0.954184118,0.138100311,0.243556943,0.993524055,0.925957055,0.999964561,0.958212999,0.961509136,0.897264827,0.984496044,0.961199582,0.74439007,0.681378611
13,13,13,1.1,To simulate problem solving for parts of the problem,4,5,4.5,0.034516156,0.965483844,0.955956623,0.419138521,0.490209083,0.995931868,0.953486868,0.999978315,0.974430389,0.975632572,0.934961399,0.971440329,0.928526167,0.821322203,0.777275556
14,14,14,1.1,A prototype program provides a basic groundwork from which to further enhance and improve a solution to a problem.,2,2,2,0.032634735,0.967365265,0.958357357,0.274500042,0.363267659,0.99519701,0.945084848,0.999977594,0.973580228,0.985423052,0.961092968,0.97875269,0.946826184,0.68330723,0.605238024
15,15,15,1.1,"A prototype program is a part of the Specification phase of Software Problem Solvin.  It's employed to illustrate how the key problem or problems will be solved in a program, and sometimes serves as a base program to expand upon.",4,5,4.5,0.024274349,0.975725651,0.969025394,0.354126483,0.433151509,0.994691202,0.939301671,0.999967329,0.961476802,0.925978812,0.80243157,0.974102098,0.935187547,0.812520802,0.766304491
16,16,16,1.1,Program that simulates the behavior of portions of the desired software product,5,5,5,0.021305799,0.978694201,0.972813329,0.869400203,0.885379574,0.997516662,0.971606667,0.999986169,0.983691599,0.985284917,0.960724275,0.98869429,0.971706172,0.936273098,0.920563405
17,17,17,1.1,it provides a limited proof of concept to verify with the client before actually programming the whole application.,2,2,2,0.020585239,0.979414761,0.97373278,0.338255763,0.419222631,0.993607669,0.926913062,0.99997616,0.971890482,0.96671733,0.91116591,0.969591597,0.923899504,0.762940943,0.704502526
18,18,18,1.1,It tests the main function of the program while leaving out the finer details.,2,2,2,0.025289357,0.974710643,0.967730222,0.294089407,0.380460192,0.998025717,0.977426968,0.999956381,0.948568029,0.975928509,0.935751279,0.978294405,0.945679274,0.745183349,0.682367443
19,19,19,1.1,To get early feedback from users in early stages of development.  To show users a first idea of what the program will do/look like.  To make sure the program will meet requirements before intense programming begins.,3,2,2.5,0.027671933,0.972328067,0.964690002,0.385987639,0.461114335,0.99242992,0.913447222,0.999981999,0.978775121,0.948415295,0.862316325,0.98284496,0.957067556,0.799007535,0.749460021
20,20,20,1.1,it simulates the behavior of portions of the desired software product,5,5,5,0.016664326,0.983335674,0.978735952,0.891450822,0.904732218,0.997823045,0.975109705,0.999986721,0.984342876,0.989407704,0.971728321,0.988642727,0.971577129,0.94791913,0.935080342
21,21,21,1.1,It simulates the behavior of portions of the desired software product.,5,5,5,0.008736014,0.991263986,0.988852653,0.944082141,0.950923899,1,1,0.999987873,0.985700319,0.98569302,0.961813534,0.989224159,0.973032229,0.944841087,0.931243519
22,22,22,1.1,A prototype program is used in problem solving to collect data for the problem.,1,2,1.5,0.040467381,0.959532619,0.948362727,0.272711277,0.361697756,0.994843417,0.941042029,0.99993945,0.92860468,0.974435982,0.931767605,0.839008921,0.597101469,0.702009082,0.628550135
23,23,23,1.1,To ease the understanding of problem under discussion and to ease the understanding of the program itself,2,3,2.5,0.024416924,0.975583077,0.968843466,0.126687288,0.233540346,0.998517575,0.983050644,0.999989215,0.987283025,0.950820081,0.86873489,0.969653784,0.924055134,0.686557889,0.609290014
24,24,24,1.1,it simulates the behavior of portions of the desired software product,5,5,5,0.016664326,0.983335674,0.978735952,0.891450822,0.904732218,0.997823045,0.975109705,0.999986721,0.984342876,0.989407704,0.971728321,0.988642727,0.971577129,0.94791913,0.935080342
25,25,25,1.1,The role of a prototype program is to help spot key problems that may arise during the actual programing.,2,2,2,0.031364143,0.968635857,0.959978661,0.323851407,0.406580701,0.995593438,0.949617416,0.999965402,0.959205508,0.963648702,0.902975498,0.975837676,0.939531029,0.741543591,0.677830436
26,26,26,1.1,"the prototype program gives a general idea of what the end product will do,   without the time and effort to write out the entire program.",4,2,3,0.029005647,0.970994353,0.962988154,0.325522006,0.408046896,0.99357862,0.926580926,0.999967668,0.961877043,0.969481986,0.918544997,0.983070689,0.957632469,0.73696059,0.672117663
27,27,27,1.1,to show that a certain part of the program works as it is supposed to,4,2,3,0.034177065,0.965822935,0.95638931,0.173815399,0.274902157,0.98695229,0.850818552,0.999919858,0.905503645,0.967344627,0.912840216,0.972538266,0.93127388,0.6899876,0.613565195
28,28,28,1.1,"Prototype programming is an approach to programming that enables one to take an organized approach to developing an effective program with minimal errors and a strategic pattern when solving a problem. i.e. book gave an example of a costumer withdrawing money from a bank, the approach that was taking on a pseudo code level during the OOA/Design lvl before proceeding into creating a solution. ",3,2,2.5,0.023513734,0.976486266,0.969995956,0.369107306,0.446299373,0.992495437,0.914196314,0.999983329,0.980342979,0.950811873,0.868712982,0.967348365,0.918285561,0.814595282,0.768890359
29,29,29,1.2,Refining and possibly the design if the testing phase reveals problems in the design. Production can be affected if the program is unworkable in its current form which will lead to a later production time than originally estimated. Also affects coding because after testing you may need to rewrite the code for the program to remove errors.,5,2,3.5,0.06367147,0.93632853,0.918753798,0.293439865,0.379890125,0.986294737,0.843300397,0.999933107,0.92112534,0.93714254,0.832228447,0.941341398,0.85320016,0.832716584,0.791478807
30,30,30,1.2,The implementation phase and the maintenance phase are effected,3,5,4,0.057609141,0.942390859,0.926489463,0.577789247,0.629448302,0.991254753,0.900010915,0.999943062,0.932863743,0.96484508,0.906168726,0.94900218,0.872372141,0.847555339,0.809975517
31,31,31,1.2,"Verification, coding, refining the solution and maintenance are all influenced by the testing stage.",4,5,4.5,0.053380549,0.946619451,0.93188524,0.467555612,0.532702163,0.98899593,0.874184579,0.999904851,0.887808855,0.906678091,0.750916412,0.936285668,0.84054762,0.71700567,0.647243585
32,32,32,1.2,"In RUP the stages in the software life cycle are influenced by the testing stage is:  Elaboration phase- refined progject vision, iterative devilopment of core system, development of system requirements, more accurate time and cost estimates.  Construction phase- iterative development of remaining system.  Transition phase-testing and deployment of the system.",2,4,3,0.043709874,0.956290126,0.944225235,0.502619624,0.563475962,0.986182072,0.84201224,0.999937678,0.92651522,0.920460747,0.787703416,0.95160903,0.87889608,0.864845574,0.831528028
33,33,33,1.2,"Refining the solution, Production and Maintenance are all influenced by the Testing stage. ",3,3,3,0.053514242,0.946485758,0.931714645,0.416627556,0.488005344,0.991275208,0.900244782,0.99988749,0.867338446,0.943882555,0.850218082,0.943528751,0.858674261,0.741493225,0.677767654
34,34,34,1.2,"Elaboration, Construction, and Transition are all affected by testing",2,2,2,0.071707428,0.928292573,0.908499738,0.13181667,0.238042129,0.986972114,0.851045207,0.99985934,0.834145474,0.936863234,0.831482957,0.942320192,0.855649704,0.75421989,0.693631614
35,35,35,1.2,"Refining, Production, Maintenance",3,4,3.5,0.127899945,0.872100055,0.836796845,0.111966021,0.22062028,0.990930421,0.896302647,0.999858475,0.833126363,0.926740716,0.804465152,0.941198235,0.852841879,0.61210078,0.516478218
36,36,36,1.2,Refining the solution,3,5,4,0.096245289,0.903754711,0.877188885,0.219870761,0.315322474,0.981429926,0.787678408,0.99989183,0.872455619,0.871310785,0.656518264,0.89504053,0.737326959,0.641978979,0.553721798
37,37,37,1.2,#NAME?,3,1,2,0.565203041,0.434796959,0.278788433,0.110221461,0.219089173,0.983686755,0.81348195,0.999662282,0.601792803,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
38,38,38,1.2,Refining and Coding,5,5,5,0.08910805,0.91089195,0.88629616,0.14968434,0.253723622,0.97847868,0.753935234,0.99990312,0.885768106,0.871310785,0.656518264,0.941198239,0.852841889,0.580309868,0.476850416
39,39,39,1.2,"The second half of the Elaboration phase, Construction phase, and the Transition phase. ",2,3,2.5,0.054634571,0.945365429,0.93028508,0.598138869,0.647308072,0.988564692,0.869254011,0.999923168,0.909406164,0.972721811,0.927192347,0.957141755,0.892742355,0.848600149,0.811277886
40,40,40,1.2,"The refining step, the production step, and the maintenance stage.  ",3,4,3.5,0.058953822,0.941046178,0.924773621,0.480811864,0.544336463,0.990065103,0.886409014,0.999934839,0.923167552,0.941460465,0.843753331,0.943144076,0.857711568,0.796304345,0.746090458
41,41,41,1.2,"Elaboration, Construction, Transition",2,2,2,0.103561819,0.896438181,0.867852832,0.076099396,0.18914207,0.990930421,0.896302647,0.999878709,0.856984282,0.92559634,0.801410722,0.941198235,0.852841879,0.699962318,0.625998816
42,42,42,1.2,Refining.,3,3,3,0.194137216,0.805862784,0.752276624,0.1389952,0.244342339,0.973607083,0.698235661,0.999849109,0.822082426,0.874491557,0.665007997,0.941198241,0.852841894,0.41651836,0.272682083
43,43,43,1.2,"The testing stage has a direct influence on the final version of a program, being as it is the debugging and finalization of a software revision.",2,1,1.5,0.05351752,0.94648248,0.931710462,0.410995305,0.483062219,0.994148529,0.933097002,0.999910147,0.894053656,0.964539017,0.90535182,0.953670703,0.884055652,0.78115648,0.727208439
44,44,44,1.2,"Directly: Refining, coding.  Because Refining is right before the Testing Phase and Coding is right after the Testing Phase.  Indirectly: Production, Maintenance.  Because Refining occurs before these last two stages in the Software Life Cycle.",5,5,5,0.054532111,0.945467889,0.930415822,0.359303325,0.437694946,0.988013615,0.862953251,0.999909603,0.893411544,0.933969108,0.823758304,0.944561551,0.86125896,0.864520371,0.831122658
45,45,45,1.2,"Testing, refining, production, and maintenance.",3,4,3.5,0.108796537,0.891203463,0.861173215,0.221128315,0.316426161,0.989661804,0.881797873,0.999845783,0.818161011,0.940296502,0.840646622,0.944522004,0.86115999,0.66613096,0.58382757
46,46,46,1.2,"Depending on how the work is done, Testing is spread throughout the  process as to prevent errors from showing up later on due to lack of foresight. ",2,1,1.5,0.071650922,0.928349078,0.90857184,0.052878115,0.168761999,0.982976638,0.805362804,0.999924946,0.911503051,0.963152782,0.901651848,0.937311507,0.843114899,0.771539807,0.715221126
47,47,47,1.2,"Elaboration, construction, and transition.",2,3,2.5,0.109662354,0.890337646,0.860068414,0.131165326,0.237470478,0.989272844,0.877350688,0.999871681,0.848697911,0.915527298,0.774535649,0.930726944,0.826636279,0.699962318,0.625998816
48,48,48,1.2,"All stages are influenced except setting the program requirements.  If a test fails, it can change the whole design, implementation, etc of a program as well as the final outcome.",2,1,1.5,0.059748232,0.940251768,0.923759935,0.352284581,0.43153497,0.992405601,0.913169171,0.99991775,0.903018452,0.944551278,0.852002957,0.931512399,0.82860197,0.788965166,0.736942071
49,49,49,1.2,"Refining, production, and maintenance",3,3,3,0.111213803,0.888786197,0.85808873,0.152301341,0.256020424,0.989690411,0.882124959,0.999908834,0.892504978,0.903666505,0.74287825,0.924193633,0.810285923,0.61210078,0.516478218
50,50,50,1.2,coding and refining,5,5,5,0.08910805,0.91089195,0.88629616,0.204779774,0.302077925,0.97847868,0.753935234,0.99990312,0.885768106,0.871310785,0.656518264,0.920740882,0.80164502,0.580309868,0.476850416
51,51,51,1.2,"refining, production, maintenance.",3,4,3.5,0.134016275,0.865983725,0.828992272,0.171022147,0.272450669,0.990760194,0.894356356,0.999909608,0.893417543,0.903666505,0.74287825,0.924193633,0.810285923,0.61210078,0.516478218
52,52,52,1.2,"Removing logical errors, testing for valid data, random data and actual data.",2,0,1,0.082456589,0.917543411,0.894783571,0.090115279,0.201443058,0.990398515,0.890221088,0.999901646,0.884029049,0.956747023,0.884554369,0.932097317,0.830065794,0.684588969,0.606835728
53,53,53,1.2,1- specification 2- design 3- risk analysis 4- verification 5- coding 6- testing 7- refining 8- production 9- maintenance,1,4,2.5,0.144389033,0.855610967,0.815756404,0.155426294,0.258763027,0.98774081,0.859834122,0.999845347,0.817646694,0.891715212,0.7109793,0.949842422,0.874474942,0.824729741,0.781523099
54,54,54,1.2,"Refining stage, Production stage, and Maintenance stage.  ",3,4,3.5,0.083961546,0.916038454,0.892863212,0.59597671,0.645410462,0.993416028,0.924721931,0.999923626,0.909946951,0.926740716,0.804465152,0.941198235,0.852841879,0.61210078,0.516478218
55,55,55,1.2,Testing could affect all parts of the life cycle; it could make you go back   to specification if it does not test well.,2,2,2,0.080972672,0.919027329,0.896677082,0.232819632,0.326687002,0.985460677,0.833764148,0.999900565,0.882754865,0.958305521,0.888714124,0.935093519,0.837564131,0.710197806,0.638757491
56,56,56,1.2,coding,3,3,3,0.132930934,0.867069066,0.830377191,0.209222376,0.305976959,0.957544689,0.514585721,0.999684292,0.62774481,0.874491557,0.665007997,0.876359821,0.690576355,0.518726945,0.400086468
57,57,57,1.2,"The Individual components and steps such as  analysis, design, and implementing code  as well as the entire system are tested for execution of the requirements identified during the analysis stage. i.e. Main output ",1,2,1.5,0.056088448,0.943911552,0.928429902,0.335814118,0.41707973,0.988918715,0.873301746,0.999924629,0.911128572,0.948114829,0.861514357,0.950552907,0.876253012,0.824515164,0.781255626
58,58,58,1.3,"Modularability, the ability to reuse parts of the program later in another program sometimes with completely different goals for the program. Also it makes it easier to debug code by dividing up the code into classes that each do a specific job and when the program fails at one job you only have one class to debug. Good for security purposes because it allows you to let someone use a program which sorts lists without having to give them access to the source code. ALso allows you to use inheritance and polymorphism.",4,5,4.5,0.117070556,0.882929444,0.850615385,0.229781941,0.324020984,0.974974803,0.713873544,0.999913164,0.897610404,0.748568986,0.328910653,0.975227021,0.938002795,0.536645114,0.422421709
59,59,59,1.3,"This type of programming is more flexible, making it easier to add and modify the program.  It is also a type of a fail safe program, you check each individual module.  This eliminates redundant code and makes the program easier to read for other programmers.  When debugging the program it is easier to track down the source of a problem within a module rather than a 2 million line program.",5,5,5,0.115385056,0.884614945,0.85276612,0.178167313,0.278721598,0.969233838,0.648234015,0.999923511,0.909810475,0.750212189,0.333296492,0.963113334,0.907686913,0.516811192,0.397698456
60,60,60,1.3,The main advantages to object-oriented programming are that existing classes can be reused and program maintenance and verification are easier.,3,4,3.5,0.100635052,0.899364948,0.871587451,0.316773772,0.400369041,0.989768763,0.883020799,0.999964562,0.958214606,0.900787369,0.735193607,0.980061865,0.950102544,0.511329472,0.390865418
61,61,61,1.3,The advantages is that OOP allows us to build classes of objects.  Three principles that make up OOP are:  Encapsulation- Objects combine data and operations.  Inheritance- Classes can inherit properties from other classes.  Polymorphism- Objects can determine appropriate operations at execution time.,2,3,2.5,0.110446513,0.889553487,0.85906781,0.387108326,0.462097901,0.98082336,0.780743218,0.999965901,0.959793001,0.717907128,0.247071718,0.984381279,0.96091237,0.638219237,0.549035229
62,62,62,1.3,Some advantages are existing classes can be reused and program maintenance and verification are easier to accomplish.,3,4,3.5,0.105224848,0.894775152,0.86573077,0.333148122,0.414739928,0.989621045,0.881331853,0.999961514,0.954620797,0.899311395,0.731254116,0.981472842,0.953633675,0.514976382,0.395411341
63,63,63,1.3,Object oriented programming allows programmers to use an object with classes that can be changed and manipulated while not affecting the entire object at once. The classes all hold attrubutes that affect the object.,1,1,1,0.119017243,0.880982757,0.848131368,0.238838151,0.331969133,0.985690014,0.836386281,0.999931146,0.918812901,0.790849934,0.441761861,0.980623862,0.951509005,0.54422462,0.431869665
64,64,64,1.3,"Reusable components, Extensibility, Maintainability, it reduces large problems into smaller more manageable problems.",4,4,4,0.089321196,0.910678804,0.88602418,0.362105638,0.440154385,0.971747816,0.676977673,0.999981365,0.978026999,0.913871139,0.770115229,0.990260643,0.975626149,0.572289109,0.466852431
65,65,65,1.3,Encapsulation-objects combine data and operations Inheritance- classes can inherit properties from other classes Polymorphism- Objects can determine appropriate operations at execution time,2,3,2.5,0.160642684,0.839357317,0.795016387,0.200599209,0.298408867,0.987916835,0.861846708,0.999953531,0.945207788,0.851285497,0.603069179,0.986172482,0.96539506,0.606546283,0.509554462
66,66,66,1.3,#NAME?,3,3,3,0.346277297,0.653722704,0.558142519,0.192947924,0.291693746,0.994110906,0.932666841,0.999936019,0.924559512,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
67,67,67,1.3,Re-usability  and ease of maintenance,3,5,4,0.134337962,0.865662038,0.828581793,0.334813386,0.416201442,0.998274334,0.980269532,0.999985843,0.983306783,0.978723044,0.943210114,0.960726526,0.901713653,0.66986686,0.58848442
68,68,68,1.3,"One of the main advantages is you can hide inner details a technique known by encapsulation. Objects combine the data and operations but you cannot see how it works.   Another advantage is you can reuse classes that have been defined earlier in the program, a method known as inheritance.   Finally another advantage is objects can determine appropriate operations at execution time a technique known as polymorphism. ",5,5,5,0.120796323,0.879203677,0.845861223,0.257909179,0.34870675,0.979006231,0.759967007,0.999953784,0.945506219,0.714564135,0.238149004,0.971930962,0.929754032,0.583454967,0.480770824
69,69,69,1.3,"Existing classes can be reused, and program maintenance and verification are easier.",3,4,3.5,0.094477534,0.905522466,0.879444579,0.418440223,0.489596224,0.981560143,0.789167258,0.999974792,0.970277221,0.964524911,0.90531417,0.988757606,0.971864627,0.511731803,0.391366929
70,70,70,1.3,Using different modules allows for easier debugging,2,2,2,0.148494005,0.851505995,0.810518369,0.118523404,0.226375343,0.990595116,0.892468928,0.999939474,0.928632442,0.932177264,0.818975731,0.983188509,0.957927327,0.433936357,0.294393852
71,71,71,1.3,"Data encapsulation concept,the use of functions or methods to manipulate data.",3,4,3.5,0.108998478,0.891001523,0.860915535,0.401530922,0.474755838,0.98508776,0.829500385,0.999953587,0.945273659,0.971312636,0.923431147,0.976915154,0.942227541,0.580301225,0.476839643
72,72,72,1.3,"Modular, reusable code, allowing faster deployment of solutions, and a more general view of a solution.",5,4,4.5,0.09687829,0.90312171,0.876381161,0.311963469,0.396147297,0.973176453,0.693312047,0.999982367,0.979208455,0.87241385,0.659462432,0.983472943,0.958639155,0.555974483,0.446516029
73,73,73,1.3,"Coding and Debugging programs are usually easier, as either the compiler will specify the object that is working incorrectly, or the function an object was assigned to will be easier to identify.  The code itself also looks more organized and is easier to read and will help to avoid redundant coding.  Post-programming maintenance is also easier.  Also, modules can be reused several times in other programs without too much hassle.   Abstraction is the art of breaking down one big problem into smaller, simpler problems and solving them.  Many of the smaller problems are shared between unique complex problems, and creating modules to these solve these smaller repeated problems can save time when you encounter them again.",5,5,5,0.108676374,0.891323626,0.861326546,0.307252049,0.392012337,0.963692749,0.584879788,0.99995646,0.94866124,0.625338988,0,0.979828186,0.949517736,0.565391123,0.458253999
74,74,74,1.3,"Variables can remain private. The code is easily modified and reusable, as well as easily implemented. Not to mention easier to read and follow along as an observer.",4,5,4.5,0.104338646,0.895661354,0.866861583,0.321000427,0.404078549,0.983601457,0.812506685,0.999975156,0.970706607,0.852755739,0.606993372,0.967034157,0.917499219,0.511685431,0.391309126
75,75,75,1.3,Data Abstraction and control... it is possible to isolate elements from other elements a lot easier and prevent tampering of data.,3,4,3.5,0.100212872,0.899787128,0.872126161,0.329621136,0.411644483,0.98652035,0.845879948,0.999973485,0.968736026,0.901726514,0.73770026,0.972900221,0.932179713,0.594330132,0.494326865
76,76,76,1.3,Encapsulation - Objects use operations without knowing how the operation works. Inheritance - cuts redundancy by reusing earlier classes. Polymorphism - objects select the correct operation to use in the situation.,5,3,4,0.104868352,0.895131648,0.866185666,0.421211988,0.492028853,0.972937441,0.690579294,0.999968429,0.962774203,0.831086548,0.54915658,0.982796579,0.956946477,0.621109068,0.527707172
77,77,77,1.3,"They make it easier to reuse and adapt previously written code and they separate complex programs into smaller, easier to understand classes.",5,4,4.5,0.115245819,0.884754181,0.852943789,0.209139943,0.305904612,0.98632174,0.843609133,0.999962473,0.955751577,0.876166625,0.669478886,0.97601621,0.939977831,0.553483009,0.443410373
78,78,78,1.3,"Existing classes can be reused, Program maintenance and verification are easier ",3,4,3.5,0.124755442,0.875244558,0.8408093,0.277752668,0.366122314,0.984394466,0.821573588,0.999975714,0.971363974,0.96495607,0.906464967,1,1,0.511731803,0.391366929
79,79,79,1.3,"Existing classes can be feused, Program maintenance and verification are easier",3,4,3.5,0.122013569,0.877986431,0.84430799,0.246919796,0.339061959,0.984394466,0.821573588,0.999975714,0.971363974,0.96495607,0.906464967,1,1,0.489562422,0.363732495
80,80,80,1.3,"the main advantages to object-oriented programming  is data abstraction, easier maintenance, and re-usability.",5,5,5,0.077510834,0.922489166,0.901094464,0.509514868,0.569527548,0.988539058,0.868960921,0.999983982,0.981112884,0.991276192,0.976715464,0.973965504,0.934845705,0.793577433,0.742691325
81,81,81,1.3,Existing classes can be reused Program maintenance and verifications are easy,3,5,4,0.139374316,0.860625684,0.822155294,0.243221238,0.335815933,0.992030309,0.908878261,0.999964196,0.957782527,0.936244931,0.829832657,0.986482269,0.966170337,0.52902472,0.412922784
82,82,82,1.3,1- Existing classes can be reused 2- Program maintenance and verification are easier,3,4,3.5,0.148076177,0.851923823,0.811051527,0.200486139,0.298309632,0.990211513,0.888082988,0.9999654,0.959202559,0.902282327,0.739183769,0.985924078,0.9647734,0.485262334,0.358372378
83,83,83,1.3,Information can be hidden. It is easier to debug. Programming is easier and more manageable.,3,4,3.5,0.09588027,0.90411973,0.877654657,0.374577552,0.451100314,0.990356511,0.889740833,0.999960537,0.953468111,0.930219265,0.813749676,0.989490094,0.973697762,0.432866603,0.293060389
84,84,84,1.3,"Existing classes can be reused, program maintenance and verification are   easier.",3,4,3.5,0.10087049,0.89912951,0.871287026,0.396600246,0.47042845,0.983213942,0.808076018,0.999977177,0.973089522,0.964524911,0.90531417,0.988757606,0.971864627,0.511731803,0.391366929
85,85,85,1.3,existing classes can be reused program maintenance and verification are easier,3,4,3.5,0.13597405,0.86402595,0.826494109,0.214885563,0.310947233,0.991908064,0.907480572,0.999955874,0.947970187,0.941106705,0.842809118,0.982302168,0.955709158,0.511731803,0.391366929
86,86,86,1.3,"Well for one encapsulation the values of the variables inside an object are private, unless methods are written to pass info outside of the object. As well as Inheritance where each subclass inherits all variables and methods of its super class.  Example in the book included obj clock and how obj alarm would still use clock from the first class. ",3,4,3.5,0.113355339,0.886644661,0.855356084,0.293572515,0.380006545,0.972227674,0.682464143,0.999942248,0.931904387,0.772863094,0.393753557,0.980163606,0.950357162,0.559953749,0.451476238
87,87,87,1.4,At function â€˜int main ()â€™,5,5,5,0.060131133,0.939868867,0.923271346,0.525377095,0.583448972,0.987880403,0.861430164,0.999850121,0.82327581,0.969044976,0.917378582,0.910464427,0.77592702,0.87754494,0.84735796
88,88,88,1.4,the Function main().,5,5,5,0.038246572,0.961753428,0.951196529,0.746781647,0.777763854,0.990770313,0.894472052,0.999905916,0.889064614,0.967868631,0.914238824,0.790787242,0.476421219,0.905438185,0.882127268
89,89,89,1.4,c++ programs begin to execute in the main method.,5,5,5,0.054554045,0.945445955,0.930387833,0.444032133,0.512056868,0.991155981,0.898881606,0.999877902,0.8560322,0.98978647,0.972739277,0.893469916,0.733396318,0.76114583,0.702264893
90,90,90,1.4,A C++ program will begin to execute at the main() function.,5,5,5,0.035574973,0.964425027,0.954605549,0.610269249,0.657954255,0.988429769,0.867711358,0.999890896,0.871353897,0.973459545,0.929161418,0.917020154,0.792333474,0.899647832,0.874909514
91,91,91,1.4,They begin in the main() function.,5,5,5,0.038173616,0.961826384,0.951289623,0.708941877,0.74455392,0.989254305,0.877138727,0.999912462,0.896782787,0.991696632,0.977837651,0.793493109,0.48319296,0.851059496,0.814343496
92,92,92,1.4,Int main(),5,5,5,0.116346717,0.883653283,0.851539019,0.354132265,0.433156584,0.985748467,0.837054596,0.999852542,0.826130475,0.95985144,0.892840304,0.790787242,0.476421219,0.739331186,0.675072643
93,93,93,1.4,main method,5,5,5,0.118505597,0.881494403,0.84878424,0.364448965,0.442210997,0.985027065,0.828806432,0.99991737,0.902569414,0.960484246,0.894529314,0.895963817,0.73963759,0.772749722,0.716729301
94,94,94,1.4,in the testing phase,0,0,0,0.099658906,0.900341094,0.872833034,0.01915854,0.13916814,0.990615035,0.892696672,0.999919427,0.904995249,0.978150148,0.941681009,0.846229604,0.615172051,0.449217975,0.313442595
95,95,95,1.4,#NAME?,5,5,5,0.060028672,0.939971328,0.923402088,0.481374949,0.544830652,0.994917659,0.941890874,0.999819074,0.786668321,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
96,96,96,1.4,main,5,5,5,0.161395669,0.838604331,0.794055561,0.494061768,0.555965192,0.969755032,0.65419311,0.999807842,0.773423574,0.93527733,0.827250053,0.755510484,0.38813711,0.745877683,0.683232941
97,97,97,1.4,They begin to execute at the funcion main().,5,5,5,0.041076303,0.958923698,0.947585731,0.574924111,0.626933727,0.990775911,0.894536059,0.99988426,0.863529688,0.982525666,0.953359615,0.895166563,0.737642371,0.712224364,0.641283623
98,98,98,1.4,The main method.,5,5,5,0.028926194,0.971073806,0.963089538,0.651628792,0.694253305,0.993988301,0.931265029,0.999957251,0.949594212,0.987959301,0.967862418,0.878053345,0.694814592,0.843294322,0.804664101
99,99,99,1.4,At the root,0,5,2.5,0.086470366,0.913529635,0.889661903,0.25665614,0.347607025,0.995182948,0.944924067,0.999954572,0.946434821,0.954462608,0.878457084,0.90067701,0.751432893,0.704970479,0.632241556
100,100,100,1.4,In the main() function.,5,5,5,0.040759027,0.959240973,0.947990581,0.79011488,0.815795104,0.994652649,0.938860871,0.999958127,0.950627302,0.995576115,0.9881923,0.905170392,0.762678094,0.981889367,0.977424702
101,101,101,1.4,C++ programs begin execution at main.,5,5,5,0.062269628,0.937730372,0.920542579,0.496552974,0.558151589,0.989346262,0.87819012,0.999764428,0.722233643,0.960543012,0.894686165,0.790787242,0.476421219,0.738535166,0.674080393
102,102,102,1.4,In the Main function..?,5,5,5,0.044065416,0.955934584,0.943771556,0.596611798,0.645967844,0.994008526,0.931496272,0.999886404,0.866057123,0.991213248,0.976547461,0.926507812,0.81607742,0.981889367,0.977424702
103,103,103,1.4,"At the ""main()"" function",5,5,5,0.078844428,0.921155572,0.899392768,0.523801744,0.582066371,0.99181077,0.906368155,0.999919758,0.905385537,1,1,1,1,1,0.999999851
104,104,104,1.4,The main function.,5,5,5,0.010952532,0.989047468,0.986024327,0.925686598,0.934779119,0.993988301,0.931265029,0.999959472,0.952213133,0.986860719,0.964930215,0.925271448,0.812983278,0.934347391,0.918162985
105,105,105,1.4,The function main,5,5,5,0.035595,0.964405,0.954579994,0.745000005,0.776200202,0.990707101,0.89374932,0.999902002,0.884448952,0.990611988,0.97494265,0.925799571,0.814304966,0.934347391,0.918162985
106,106,106,1.4,"After loading the required include statements and libraries, the main method begins the execution.",5,5,5,0.044585764,0.955414236,0.94310758,0.418837249,0.489944673,0.986214574,0.842383856,0.999899639,0.881662717,0.927733427,0.807114777,0.904553943,0.76113536,0.727499068,0.660323748
107,107,107,1.4,main function,5,5,5,0.088592708,0.911407292,0.886953747,0.693437874,0.73094689,0.985027065,0.828806432,0.999898087,0.879833428,0.976221107,0.936532246,0.897383297,0.743190001,0.905438185,0.882127268
108,108,108,1.4,main,5,5,5,0.161395669,0.838604331,0.794055561,0.494061768,0.555965192,0.969755032,0.65419311,0.999807842,0.773423574,0.93527733,0.827250053,0.755510484,0.38813711,0.745877683,0.683232941
109,109,109,1.4,C++ programs begin execution at the main function.,5,5,5,0.036995351,0.963004649,0.952793114,0.66868192,0.709219919,0.991698415,0.905083542,0.999793426,0.756425578,0.997872201,0.994320735,0.908472519,0.770942043,0.856787503,0.821483533
110,110,110,1.4,At main,5,5,5,0.07584548,0.92415452,0.903219492,0.64429909,0.687820419,0.983362975,0.809779997,0.999915146,0.899946968,0.957823436,0.887427401,0.903881017,0.759451286,0.909348905,0.887002033
111,111,111,1.4,they beging to excute at main,5,5,5,0.064349055,0.935650945,0.917889184,0.357176542,0.435828382,0.987882367,0.861452621,0.99986766,0.843956086,0.982095188,0.952210635,0.87432245,0.685477602,0.798577368,0.748923812
112,112,112,1.4,at the main function  int main() {},5,5,5,0.066480696,0.933519304,0.915169163,0.580518186,0.631843346,0.98971176,0.88236905,0.999940161,0.929442707,0.962800642,0.900711959,0.600417806,0,0.880931556,0.851579423
113,113,113,1.4,C++ programs begin execution at the main function.,5,5,5,0.036995351,0.963004649,0.952793114,0.66868192,0.709219919,0.991698415,0.905083542,0.999793426,0.756425578,0.997872201,0.994320735,0.908472519,0.770942043,0.856787503,0.821483533
114,114,114,1.4,"in the ""main"" function",5,5,5,0.080240607,0.919759393,0.897611212,0.455883324,0.522458022,0.994440421,0.936434364,0.999897208,0.878796118,0.976221107,0.936532246,0.897383297,0.743190001,0.905438185,0.882127268
115,115,115,1.4,Within the main function,5,5,5,0.033020914,0.966979086,0.957864585,0.653330386,0.695746702,0.999070622,0.989373923,0.999956331,0.948509605,0.993359867,0.982276958,0.908472519,0.770942043,0.947838187,0.934979445
116,116,116,1.5,Variable can be a integer or a string in a program.,1,3,2,0.025501072,0.974498928,0.967460068,0.229905665,0.32412957,0.993090098,0.920995394,0.999949918,0.940947605,0.962644522,0.900295262,0.911936316,0.77961059,0.619252086,0.525392418
117,117,117,1.5,"In programming, a structure that holds data and is uniquely named by the programmer. It holds the data assigned to it until a new value is assigned or the program is finished. ",4,5,4.5,0.020717323,0.979282677,0.973564238,0.247859776,0.339886929,0.991171494,0.899058971,0.999936994,0.925709294,0.898467841,0.729002603,0.928314209,0.820598135,0.743808985,0.68065428
118,118,118,1.5,A variable is a location in memory where a value can be stored.,5,5,5,0.012466192,0.987533808,0.984092863,0.783521175,0.810008164,0.997424999,0.970558641,0.999983066,0.980033373,0.987672172,0.967096048,0.95515788,0.887777482,0.965662718,0.957197964
119,119,119,1.5," Variable is a location in the computer's memory, in which a value can be stored and later can retrieve that value.",5,5,5,0.012162864,0.987837136,0.984479917,0.71622318,0.750944329,0.993803004,0.929146427,0.999980822,0.97738658,0.96442907,0.905058362,0.918799004,0.796785249,0.868427515,0.835992966
120,120,120,1.5,"A variable is a location in the computer's memory where a value can be stored for use by a program. Each variable has a name, a value, a type and a size.",5,5,5,0.014519691,0.985480309,0.981472553,0.671415389,0.711618938,0.995184353,0.944940127,0.99996903,0.963482799,0.936197987,0.82970736,0.941638988,0.853944913,0.903808713,0.880096109
121,121,121,1.5,A named object that can hold a numerical or letter value,2,5,3.5,0.025025845,0.974974155,0.968066469,0.402501166,0.47560737,0.998070386,0.977937689,0.999965873,0.959760743,0.974504599,0.93195075,0.939252952,0.847973586,0.782755494,0.729201632
122,122,122,1.5,"It's a sybol or name for a value/number. Example: 'a_used_number' can stand for any given number, and the programmer can refer to that number by using the variable name.",3,5,4,0.026005328,0.973994672,0.966816627,0.292293817,0.3788843,0.993319019,0.923612772,0.999941809,0.931385783,0.906793158,0.751223535,0.920362926,0.800699142,0.73383069,0.668216201
123,123,123,1.5,A variable is a location in the computers memory where a value can be stored for use by a program,5,5,5,0.016582668,0.983417332,0.97884015,0.626581967,0.672271052,0.997495772,0.971367817,0.999972249,0.967278392,0.974758589,0.932628669,0.946147807,0.865228747,0.905212641,0.881846124
124,124,124,1.5,#NAME?,3,5,4,0.036128402,0.963871598,0.953899361,0.612101793,0.659562581,0.998593111,0.983914291,0.999936102,0.924656517,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
125,125,125,1.5,a block of memory that holds a specific type of data,5,5,5,0.033363342,0.966636658,0.957427638,0.302713692,0.388029264,0.994991995,0.942740799,0.999972506,0.967581231,0.975510813,0.934636415,0.933159782,0.832724733,0.744220018,0.681166639
126,126,126,1.5,It is a location in the computer's memory where it can be stored for use by a program.,5,5,5,0.018115819,0.981884182,0.976883815,0.546101272,0.601637469,0.996344721,0.958207242,0.999965588,0.959424187,0.973259569,0.928627666,0.941817014,0.854390444,0.825327873,0.782268679
127,127,127,1.5,A location in memory where value can be stored.,5,5,5,0.014464498,0.985535502,0.981542982,0.846884608,0.865618846,0.998289971,0.980448327,0.99997949,0.975816837,0.987672172,0.967096048,0.95515788,0.887777482,0.965662718,0.957197964
128,128,128,1.5,a value/word that can assume any of a set of values,3,3,3,0.042954624,0.957045376,0.945188951,0.239197314,0.332284351,0.995295165,0.946207101,0.999933085,0.921100216,0.966468773,0.910502492,0.922536741,0.806139362,0.67949599,0.600487261
129,129,129,1.5,A pointer to a location in memory.,3,5,4,0.025174737,0.974825263,0.967876479,0.636582136,0.681047663,0.9957092,0.950940992,0.999950365,0.941475133,0.973836168,0.930166654,0.932829602,0.83189842,0.884693921,0.856269261
130,130,130,1.5,"A variable is the memory address for a specific type of stored data, or from a mathematical perspective, a symbol representing a fixed definition with changing values.",5,5,5,0.021272838,0.978727162,0.972855389,0.410932124,0.483006769,0.989080405,0.875150436,0.999965311,0.959098292,0.942285964,0.845956654,0.940436808,0.850936321,0.813151717,0.767090935
131,131,131,1.5,A variable is a value that is subject to change in a computer's memory that can be used by programs.  Programs can change the value of the variable and recall it later or act on it directly.,5,5,5,0.015440047,0.984559953,0.980298159,0.453596503,0.520451002,0.996050127,0.954838986,0.999946052,0.936389095,0.939073905,0.837383413,0.93009888,0.825064477,0.830806315,0.789097631
132,132,132,1.5,a symbol that stands in for a value that may or may not change depending on the program.,3,5,4,0.022131085,0.977868915,0.971760246,0.303268611,0.388516287,0.995937853,0.953555296,0.999943565,0.933456932,0.959723555,0.892498969,0.924322063,0.810607334,0.717259705,0.647560243
133,133,133,1.5,"a placeholder to hold information used in the program... for example: int can hold: 1, 2, 3, 4, 68, 72, 256, etc. float can hold: 1.54, 55.55, 1.24, 5.657, 8.8123, et. char can hold: A, B, C, D, E, F, !, 4, 5, 6, P, etc. ",4,5,4.5,0.055642486,0.944357514,0.928998959,0.230519936,0.324668682,0.980069422,0.772123037,0.999943053,0.932853464,0.892151968,0.712145036,0.922598287,0.806293388,0.685021162,0.607374463
134,134,134,1.5,a stored value used by the program,4,5,4.5,0.040673316,0.959326685,0.948099951,0.387372553,0.462329799,0.994311624,0.934961755,0.99994555,0.935797443,0.979230448,0.944564416,0.902636728,0.756337311,0.801609516,0.752703426
135,135,135,1.5,"A way to store different values into the program, such as numbers, words, letters, etc.",4,5,4.5,0.039754331,0.960245669,0.949272595,0.319238275,0.402532003,0.993074274,0.920814466,0.999952401,0.943875311,0.961743067,0.897889207,0.936066506,0.839999142,0.748982668,0.687103346
136,136,136,1.5,An object with a location in memory where value can be stored,2,5,3.5,0.022175312,0.977824688,0.971703812,0.707728267,0.7434888,0.996873232,0.964249993,0.999973445,0.968688781,0.97365442,0.929681554,0.941925139,0.854661039,0.93968904,0.924821423
137,137,137,1.5,location in memory where a value can be stored,5,5,5,0.023475528,0.976524472,0.970044708,0.739905715,0.771729218,0.996302868,0.957728716,0.999975607,0.971237543,0.970766364,0.921973104,0.922867561,0.806967277,0.91263479,0.891097933
138,138,138,1.5,a variable is an object where data is stored.,2,5,3.5,0.032606244,0.967393756,0.958393712,0.339746237,0.42053074,0.994708367,0.939497928,0.999970283,0.964960483,0.947247654,0.859199798,0.600431446,3.41E-05,0.717094123,0.647353843
139,139,139,1.5,Location in memory where a value can be stored.,5,5,5,0.014464498,0.985535502,0.981542982,0.791657627,0.817149091,0.996700567,0.962275817,0.999983587,0.980647256,0.976043349,0.936057796,0.906509917,0.766030408,0.91263479,0.891097933
140,140,140,1.5,it is a location in memory where value can be stored,5,5,5,0.021308124,0.978691876,0.972810363,0.695088685,0.732395718,0.996134099,0.955799089,0.999975223,0.970785548,0.970766364,0.921973104,0.922867561,0.806967277,0.91263479,0.891097933
141,141,141,1.5,A variable is the location in a computer's memory where a value can be stored for use by a program.,5,5,5,0.014182568,0.985817432,0.98190273,0.692892373,0.730468133,0.997489247,0.971293215,0.999980557,0.977074526,0.974758589,0.932628669,0.946147807,0.865228747,0.905212641,0.881846124
142,142,142,1.5,A variable is a location in a computers memory where a value can be stored   for use by a program.,5,5,5,0.013601482,0.986398518,0.982644209,0.698169649,0.735099714,0.997462836,0.970991241,0.999975633,0.971269092,0.974758589,0.932628669,0.946147807,0.865228747,0.905212641,0.881846124
143,143,143,1.5,a location in memory where data can be stored and retrieved,5,5,5,0.034369409,0.965630591,0.956143875,0.536661565,0.593352746,0.997029228,0.96603357,0.999963637,0.957123525,0.971115739,0.922905613,0.931637577,0.828915242,0.817136109,0.772057534
144,144,144,1.5,"Is a method or identifier I would say,  we use to bind a data object to memory location; which is then stored in a location that can be accessed when and manipulated later when the variable name is called. ",5,5,5,0.017260015,0.982739985,0.97797584,0.424265474,0.494708734,0.988983313,0.874040328,0.999967345,0.961495935,0.937338915,0.832752587,0.929912652,0.82459842,0.811243951,0.764712879
145,145,145,1.6,"They can be declared right before they are used, but it is a good practice to declare them at the beginning of the program and label what they are food.",1,3,2,0.033484161,0.966515839,0.957273471,0.334452599,0.415884798,0.992837069,0.918102373,0.999954115,0.945896226,0.961279096,0.896650832,0.980608395,0.951470297,0.715936422,0.645910753
146,146,146,1.6,In the Function main() before using the variable.,1,5,3,0.024815798,0.975184202,0.968334494,0.547637641,0.602985858,0.988512773,0.868660394,0.999843099,0.814995778,0.945398088,0.85426316,0.955314322,0.888168996,0.822494507,0.778736849
147,147,147,1.6,"Local variables are declared inside the method or function they will be used in at the beginning of the method. Global variables are declared outside of any function or method, generally before functions are defined.",5,5,5,0.012806594,0.987193406,0.983658503,0.701732636,0.738226757,0.992814578,0.917845231,0.999980078,0.976509583,0.937415907,0.832958085,0.988240898,0.970571506,0.851806283,0.815274375
148,148,148,1.6,Variables are declared where ever it is defined either inside a block locally or outside a block globally.,4,5,4.5,0.029239953,0.970760047,0.962689175,0.484219134,0.547326841,0.993324652,0.923677172,0.999976356,0.972121351,0.965314267,0.907421024,0.967802733,0.919422668,0.845699012,0.80766158
149,149,149,1.6,Variables are declared before they are actually used. They can be declared before main() to use globally,3,5,4,0.01926899,0.98073101,0.975412344,0.59270829,0.642541945,0.993631752,0.927188418,0.99997206,0.967055595,0.944228226,0.851140705,0.98434572,0.960823379,0.813486278,0.76750797
150,150,150,1.6,"For good programing practice they should be declared before main(), but should at least be declared before they are used.",2,3,2.5,0.034681976,0.965318024,0.955745033,0.43704769,0.505926998,0.991429882,0.902013255,0.999973261,0.968471668,0.945472064,0.854460608,0.976675242,0.941627134,0.679342747,0.600296241
151,151,151,1.6,"They can be declared globally just before the main method (but also outside of it)... or variables can be subject to only the method they're scoped within, but would still be declared at the beginning of that method (but inside of it).",5,5,5,0.025036395,0.974963605,0.968053007,0.552821219,0.607535205,0.987542575,0.857567593,0.999972066,0.967062088,0.954260084,0.877916531,0.982698525,0.956701086,0.818947315,0.774315227
152,152,152,1.6,local variables are declared inside the method while global variables are declared in the body.,5,5,5,0.016488791,0.98351121,0.978959939,0.689204037,0.727231079,0.994299787,0.934826412,0.999978041,0.97410769,0.955221767,0.880483339,0.95587034,0.889560494,0.855772078,0.820217793
153,153,153,1.6,#NAME?,1,3,2,0.051195264,0.948804736,0.934673712,0.334915668,0.416291209,0.982315102,0.797799104,0.999903046,0.885679741,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
154,154,154,1.6,"Globally for an entire program, and locally for individual functions (including FOR statements)",4,5,4.5,0.04129976,0.95870024,0.947300593,0.462639272,0.528387355,0.988311996,0.8663648,0.999979525,0.975857603,0.946011385,0.855900098,0.986418343,0.966010355,0.845549941,0.80747576
155,155,155,1.6,They are usually declared at the beginning before they can be used in the program. They always contain a name and a data type.,2,4,3,0.028248787,0.971751213,0.963953924,0.390297234,0.464896634,0.993111604,0.92124128,0.999961413,0.954501982,0.957765733,0.887273387,0.97738684,0.943407989,0.748608887,0.686637423
156,156,156,1.6,Inside the method.,2,3,2.5,0.069838583,0.930161417,0.910884425,0.271491408,0.360627143,0.985912022,0.838924615,0.999848652,0.821543936,0.871197447,0.656215755,0.981873036,0.954635206,0.663572967,0.580638997
157,157,157,1.6,at the top,1,2,1.5,0.135728002,0.864271998,0.826808071,-0.094885677,0.039077656,0.966293027,0.614610153,0.999811793,0.778082473,0.843915573,0.583398267,0.936549178,0.841207083,0.43595323,0.296907911
158,158,158,1.6,Global variables are declared in the body of the code. Local variables are declared in the function they are to be used (unless the function is being passed a variable). Variables should always be declared before use.,5,5,5,0.013945401,0.986054599,0.982205361,0.740474403,0.772228325,0.993087619,0.920967048,0.999984508,0.981732577,0.940199772,0.840388442,0.974215853,0.935472232,0.868914008,0.836599387
159,159,159,1.6,Variables are usually declared at the beginning of a module of C++ code.,2,3,2.5,0.033891618,0.966108382,0.956753546,0.46888414,0.53386814,0.993235881,0.922662211,0.999987042,0.984721286,0.941992891,0.845174419,0.964754958,0.911795264,0.708556354,0.636711398
160,160,160,1.6,"In the main function, usually at the top of code.  They can be declared almost anywhere, but must be declared before the code can use or act upon them.",3,4,3.5,0.02408582,0.97591418,0.969265962,0.476302803,0.540379102,0.988729708,0.871140721,0.99996018,0.953047446,0.952222496,0.872478047,0.975394727,0.938422499,0.777273476,0.722368222
161,161,161,1.6,in the very beginning of the program. Before the main() starts.,1,3,2,0.045496702,0.954503298,0.941945203,0.336553216,0.417728397,0.991917937,0.907593449,0.999977452,0.973413519,0.918230489,0.78175068,0.962350917,0.905778877,0.532968998,0.41783938
162,162,162,1.6,"In the declaration of Functions, for statements, and while statements. in the body of If, For, while, do while, statements, in namespaces, headers, etc  ( almost anywhere. ) anywhere in the program, as long as it is on it's own line.",2,3,2.5,0.032342315,0.967657685,0.958730492,0.383878321,0.459263099,0.981405596,0.787400236,0.999968365,0.962698309,0.959549705,0.89203495,0.976140445,0.940288743,0.810170472,0.763374773
163,163,163,1.6,After declaration of the variable's data type.,1,1,1,0.041224241,0.958775759,0.947396957,0.388840497,0.463618134,0.990771078,0.894480801,0.999927418,0.91441715,0.935397396,0.827570519,0.951781152,0.879326835,0.624997258,0.532553853
164,164,164,1.6,"anywhere in the code, can be at the top, or in the middle of the code, or anywhere.",3,3,3,0.038291991,0.961708009,0.951138574,0.25870043,0.349401189,0.988255285,0.865716396,0.999936259,0.924842697,0.942793452,0.84731118,0.978877936,0.947139627,0.670029521,0.588687179
165,165,165,1.6,Before they are used.,2,2,2,0.059867203,0.940132797,0.923608126,0.254357874,0.345589961,0.986524687,0.845929545,0.999909575,0.893378831,0.868903484,0.650092986,0.92892557,0.822128135,0.574559689,0.469682739
166,166,166,1.6,Anywhere in the same scope before they are used,3,4,3.5,0.042717755,0.957282245,0.945491201,0.183078691,0.283032051,0.991449289,0.902235145,0.99992334,0.909609445,0.91518862,0.77363169,0.938195041,0.845326043,0.746506333,0.684016562
167,167,167,1.6,variables can be declared in classes and methods.,1,4,2.5,0.026842415,0.973157585,0.965748485,0.61995101,0.666451417,0.993095729,0.921059774,0.999988041,0.985898804,0.838670923,0.569399879,0.981873036,0.954635206,0.512068272,0.391786342
168,168,168,1.6,inside the function scope and outside of the function scope in case of global variables,5,5,5,0.026432812,0.973567188,0.966271148,0.433307678,0.50264459,0.992228035,0.911138962,0.999809596,0.775491756,0.953691425,0.876398735,0.926112409,0.815087879,0.855572045,0.819968449
169,169,169,1.6,global variables are declared in the main function local variables are declared in any other function,3,5,4,0.025537789,0.974462211,0.967413217,0.678343833,0.717699661,0.994440743,0.936438039,0.999982352,0.979190797,0.948332716,0.862095915,0.880443854,0.700797113,0.835568428,0.795033669
170,170,170,1.6,"Variables are usually declared at the very beginning of a C++ program, but can be declared any in the program as long as they appear before they are called upon.",4,4,4,0.026005745,0.973994255,0.966816095,0.462378085,0.528158125,0.994041059,0.931868238,0.999964948,0.958670174,0.941002153,0.84253006,0.963250675,0.908030624,0.693800271,0.61831774
171,171,171,1.6,"Variables are declared in the main function, before any operation is   attempted with the variables.",1,3,2,0.021537602,0.978462398,0.972517544,0.66215694,0.703493294,0.992920708,0.919058668,0.999984227,0.98140173,0.932209601,0.819062041,0.967549747,0.918789542,0.751499236,0.690240282
172,172,172,1.6,"anywhere, but where you declare them depends on where you want them to be accessible (their scope)",4,5,4.5,0.043722391,0.956277609,0.944209263,0.349289298,0.428906172,0.991719248,0.905321734,0.99995743,0.949805545,0.943767128,0.849909998,0.978402243,0.945949151,0.689904571,0.613461697
173,173,173,1.6,It depends if itâ€™s a global then they have to be declared out side the source code to be used in every scope however a local variable is one declared in a local function etc. which obviously doesnâ€™t need to be declared outside the variable seeing how it is used for the function or block its being called for.,4,5,4.5,0.023006976,0.976993024,0.970642591,0.553313971,0.607967667,0.990958992,0.896629321,0.999967205,0.961331276,0.948074071,0.861405571,0.965489804,0.9136343,0.866230607,0.833254491
174,174,174,1.7,"""The â€œdoâ€ statement first evaluates the condition and then executes the lines of code in the statement 0 or more times. 	The â€œdo whileâ€ statement executes the lines of code and then it evaluates the condition. """,4,5,4.5,0.03729707,0.96270293,0.952408115,0.333824962,0.415333955,0.98980708,0.883458896,0.999879465,0.857875695,0.898512755,0.729122482,0.964401949,0.910911819,0.792124748,0.740880534
175,175,175,1.7,do...while statements evaluate whether or not to loop after running the block contained within it at least once. So the main differance is that while statements have a possibility of never being used. Do ... while statements on the other hand are always run at least once before evaluating whether to run again.,5,5,5,0.010663509,0.989336491,0.986393126,0.726702511,0.760141475,0.992542875,0.914738706,0.999966939,0.96101709,0.929322545,0.811356259,0.966952151,0.91729399,0.849525511,0.812431363
176,176,176,1.7,"The main difference between a while and a do...while loop is that the do...while loop always cycles through the loop at least once, but the while loop does not always do so.",5,5,5,0.013773382,0.986226618,0.982424861,0.530881524,0.588279914,0.994558041,0.937779175,0.999938867,0.927917091,0.891126149,0.709407044,0.933271518,0.833004366,0.706748307,0.634457643
177,177,177,1.7,While loop used to execute a block of code as long as some condition is true.  A do...while loop used to execute a block of code as long as some condition is satisfied.  The difference between while and do...while is while loop tests its condition before the execution of its contents and the do...while loop tests its condition after the execution of its contents at least once.,5,5,5,0.015294254,0.984705746,0.980484194,0.59742105,0.646678081,0.991985804,0.908369414,0.999945956,0.93627613,0.891860533,0.711367173,0.96692218,0.917218984,0.813252568,0.767216648
178,178,178,1.7,"The termination condition of a do...while statement is usually at the end of the loop so it will run at least once. As for the while statement, if the condition is false to begin with, then the loop will never run.",5,5,5,0.012851179,0.987148821,0.983601612,0.633853018,0.678652463,0.990211908,0.888087514,0.999928485,0.915676236,0.893253296,0.715084568,0.960223579,0.900454971,0.838436842,0.798609186
179,179,179,1.7,A while loop will check the statement to make sure it is true before executing. A do while loop will execute before checking the statement to see if it should run again.,5,5,5,0.015442908,0.984557092,0.980294509,0.625244677,0.671097384,0.989257072,0.877170356,0.999919423,0.904990766,0.924051697,0.797287947,0.972477037,0.931120647,0.775131464,0.719698175
180,180,180,1.7,"A while statement will test the condition of the while loop FIRST - there is a chance the loop will never run. A do...while loop will ALWAYS run once, and then the while test will determine if it will run again.",5,5,5,0.013372898,0.986627102,0.982935887,0.579083324,0.630584044,0.981305034,0.786250461,0.999958237,0.95075635,0.895746748,0.72173979,0.951130779,0.877699202,0.780397594,0.726262477
181,181,181,1.7,a do while loop always executes once. A while loop's conditional statement has to be true for it to run.,5,5,5,0.020878673,0.979121327,0.973358353,0.592331827,0.642211543,0.994858597,0.941215585,0.999979461,0.975781662,0.959761563,0.892600416,0.974874362,0.937120226,0.744217873,0.681163964
182,182,182,1.7,#NAME?,5,5,5,0.02326858,0.97673142,0.970308777,0.502039313,0.562966655,0.980026363,0.771630731,0.99995152,0.942836202,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
183,183,183,1.7,"while statements will evaluate the statement BEFORE executing a cycle of the loop, including the first cycle, meaning that a while loop will not always execute. A do...while will run evaluate the statement AFTER running through a cycle of the loop, ensuring that the loop always executes at least one time.",5,5,5,0.014653921,0.985346079,0.981301273,0.600611627,0.649478279,0.976236342,0.728297385,0.999916899,0.902014902,0.86263238,0.633354911,0.970359302,0.925820774,0.824278712,0.780960886
184,184,184,1.7,The main difference between a do and a do...while statement is in a do...while statement is the statements in a do block are always executed atleast once.   The while statement will only execute if its condition is true.,5,5,5,0.012811661,0.987188339,0.983652038,0.779288888,0.806293713,0.994929394,0.942025051,0.999972138,0.967147552,0.97538263,0.934294284,0.980174828,0.950385247,0.863681793,0.83007736
185,185,185,1.7,The loop of a do...while statement always executes once.,4,5,4.5,0.013900936,0.986099064,0.982262099,0.7561993,0.786029222,0.995504786,0.948603814,0.999982797,0.979715487,0.981569357,0.95080715,0.979595905,0.948936426,0.78495276,0.731940553
186,186,186,1.7,"a while statement will only process if the statement is met, while a do...while will always process once, then only continue if the statement is met.",5,5,5,0.017400742,0.982599258,0.977796269,0.63930881,0.683440718,0.987679837,0.859136987,0.999828938,0.798298688,0.93567488,0.828311145,0.968463278,0.921075757,0.659078181,0.575036185
187,187,187,1.7,"Do ...while runs the embedded code at least once, the do command does not necessarily",4,4,4,0.017292619,0.982707381,0.977934236,0.521242023,0.579819841,0.993410092,0.924654062,0.999969515,0.964054594,0.972552434,0.926740266,0.96688657,0.917129866,0.829115033,0.786989425
188,188,188,1.7,"While tests for true first before running, do...while runs once first before checking.",5,5,5,0.031348467,0.968651533,0.959998664,0.546021044,0.601567057,0.990141004,0.887276821,0.999928149,0.91527923,0.930509427,0.814524141,0.951091459,0.8776008,0.730085731,0.663548058
189,189,189,1.7,A do...while statement's body always executes at least once.  Where as a while statement will not execute at all unless the condition for the while is true.,5,5,5,0.009015143,0.990984857,0.988496479,0.775421441,0.802899462,0.995663377,0.950417073,0.999970647,0.965389342,0.965583937,0.908140794,0.977703854,0.944201352,0.840342224,0.80098427
190,190,190,1.7,The statements within the block of the do while loop will always be executed at least once regardless of the conditions. Whereas the while loops may never be executed if the conditions are not met.,5,5,5,0.017414927,0.982585073,0.977778168,0.660582244,0.702111269,0.992865406,0.918426371,0.999936938,0.925642944,0.916651169,0.77753535,0.9845885,0.961430964,0.839244425,0.79961585
191,191,191,1.7,"a do... while loop will always run through once, while an while loop performs a test before running through the loop.",5,5,5,0.017465174,0.982534826,0.977714052,0.507479668,0.567741362,0.992161134,0.910374055,0.999968805,0.96321796,0.937751019,0.833852525,0.926426506,0.815873943,0.669646442,0.588209666
192,192,192,1.7,A while statement tests the condition before it can start. A do...while statement loops through once before the condition is tested.,5,5,5,0.015421867,0.984578133,0.980321357,0.608004391,0.655966511,0.993802444,0.929140024,0.999953044,0.944633435,0.898469211,0.72900626,0.954601299,0.886384574,0.693450689,0.617881983
193,193,193,1.7,"A while loop terminates at the beginning of the loop, a do/while terminates at the end of the loop.",3,4,3.5,0.031306982,0.968693018,0.960051599,0.235658795,0.329178783,0.990688135,0.893532462,0.999917448,0.902662003,0.9298266,0.812701622,0.938198457,0.845334592,0.628900826,0.537419703
194,194,194,1.7,the loop body always executes at least once,3,4,3.5,0.04162699,0.95837301,0.946883041,0.411650896,0.483637596,0.99360598,0.926893747,0.999955274,0.947262597,0.982287389,0.952723634,0.969130589,0.922745779,0.804799199,0.756679409
195,195,195,1.7,"While loop evaluates its expression at the top of its loop and decides if it needs to execute, and the do-while always executes at least once and then evaluates its expression at the bottom of its loop.",5,5,5,0.023611248,0.976388753,0.969871527,0.460294783,0.526329723,0.987355304,0.855426432,0.999847999,0.82077335,0.939761236,0.839217954,0.974882061,0.937139494,0.78739351,0.734982982
196,196,196,1.7,"A do...while statement will always execute the ""do"" piece of code at least once before checking the condition. A while statement will always check the condition first.",5,5,5,0.010432243,0.989567757,0.986688227,0.671042085,0.711291309,0.99359309,0.926746366,0.999950134,0.941202044,0.914333511,0.771349336,0.958219957,0.895440679,0.80415684,0.755878699
197,197,197,1.7,"A do-while passes atleast 1 time before checking the condition, however, a while would fail to enter the loop if the condition fails in its first place.",5,5,5,0.023673117,0.976326883,0.969792579,0.385803431,0.460952665,0.984617433,0.824122886,0.999962277,0.955520645,0.940155365,0.840269916,0.966078613,0.915107861,0.791606188,0.740234141
198,198,198,1.7,"a while loop checks if the condition is true or not first, if it was true, it excutes the statement. a do.. while loop executes the statement before it checks the condition. if the condition was true it would excute the statement again. so a do...while loop would excute the statement atleast once.",5,5,5,0.014442682,0.985557318,0.981570818,0.612899482,0.66026267,0.984508685,0.822879508,0.999915237,0.900055351,0.883156599,0.688135682,0.971776771,0.929368151,0.711456954,0.640327036
199,199,199,1.7,NO ANSWER,0,0,0,0.177761674,0.822238326,0.773172177,0.011174782,0.132161224,0.991110749,0.898364441,0.999722446,0.672732682,0.918513187,0.782505224,0.962795041,0.906890348,0.577489793,0.473335155
200,200,200,1.7,"A do...while loop will always execute atleast once, a while loop may never   execute depending on teh conditions.",5,5,5,0.015417695,0.984582305,0.980326681,0.635831118,0.680388534,0.992876183,0.918549593,0.99997636,0.972125266,0.942076885,0.845398605,0.978138532,0.945289184,0.815448463,0.76995386
201,201,201,1.7,"a while loop is pre-check (it checks the condition statement before it executes the code within the while block)  a do while loop is post-check (it checks the condition AFTER the block executes, it runs at least once no matter what the condition statement is)",5,5,5,0.023235977,0.976764023,0.97035038,0.528060675,0.585804206,0.982921303,0.804730122,0.999949836,0.940850619,0.881232689,0.683000613,0.973965129,0.934844767,0.806135952,0.75834569
202,202,202,1.7,"))     What is the main difference between a while and a do...while statement? The do while construct consists of a block of code and a condition. First, the code within the block is executed, and then the condition is evaluated, this is done until it is proven false. The difference between the While loop is it tests the condition before the code within the block is executed. ",5,5,5,0.016620815,0.983379185,0.978791473,0.580818236,0.632106683,0.977347749,0.741004703,0.999966902,0.960973442,0.902645587,0.740153339,0.968747034,0.921785889,0.842397928,0.803546734
203,203,203,2.1,"For us it is usually a set, get, and displayMessge or other messages that tell you what properties a class has but does not reveal its implementations. You could have anything you want in your own class definition.",1,3,2,0.100014687,0.899985313,0.87237905,0.243759006,0.336287904,0.978288592,0.751761866,0.999936471,0.925092625,0.937269969,0.832568565,0.959514636,0.898680761,0.644686997,0.557097379
204,204,204,2.1,The attributes of said class. Also whether or not it is a subclass. Also whether it is public private or protected.,4,4,4,0.091338515,0.908661485,0.883450037,0.37144798,0.448353657,0.983887954,0.815782362,0.999927961,0.915057293,0.907736744,0.753742041,0.966221585,0.915465665,0.643706262,0.55587488
205,205,205,2.1,Information telling the compiler what data members and member functions belong to the class.,5,5,5,0.052280188,0.947719812,0.933289326,0.658615112,0.700384823,0.987318212,0.855002338,0.999960632,0.953580319,0.981346168,0.950211441,0.973896985,0.934674229,0.897796392,0.87260167
206,206,206,2.1,"Since class is user defined, the body of the declaration can contain members, that can be either data or function declarations, and optionally access specifiers.  Example for specifiers would be public, private, and protected.  There is the keyword Class and the Class body is enclosed with brackets ({}). ",5,5,5,0.062294126,0.937705874,0.92051132,0.559311807,0.613231646,0.980386262,0.775745642,0.999968015,0.962286034,0.924811919,0.79931704,0.96680431,0.916924001,0.789367616,0.737443731
207,207,207,2.1,An object and data.,1,3,2,0.070094943,0.929905057,0.910557304,0.473627746,0.538031348,0.989698941,0.882222486,0.999889738,0.869988507,0.954665565,0.878998792,0.839777906,0.599025942,0.702348411,0.628973113
208,208,208,2.1,"It's specific class name, includes only information defined by that class... implementation details... etc.",2,4,3,0.075169742,0.924830258,0.904081748,0.304216206,0.38934794,0.981614023,0.789783297,0.999887783,0.867683118,0.91702939,0.778544852,0.968221372,0.92047036,0.723766267,0.655670761
209,209,209,2.1,data members and member functions.,5,5,5,0.024205565,0.975794435,0.969113164,0.864236236,0.880847437,0.990203243,0.887988435,0.999963142,0.956540256,0.989792616,0.972755681,0.966563219,0.916320643,0.971831262,0.964887138
210,210,210,2.1,A class definition usually contains the function and its data members,5,5,5,0.06362325,0.936376751,0.918815328,0.470067054,0.53490632,0.98760116,0.858237436,0.999929776,0.91719752,0.962201003,0.899111475,0.958658429,0.896538005,0.815468967,0.769979419
211,211,211,2.1,Data members and member functions,5,5,5,0.045626342,0.954373658,0.941779779,0.778328002,0.805450395,0.99025767,0.888610727,0.999960629,0.953576564,0.99088555,0.975672809,0.991401486,0.978481238,0.971831262,0.964887138
212,212,212,2.1,member functions,3,4,3.5,0.132347286,0.867652714,0.83112194,0.659164548,0.700867033,0.987240999,0.854119513,0.999868651,0.845124211,0.915817649,0.775310619,0.958144096,0.895250828,0.886003196,0.857901291
213,213,213,2.1,Member functions and data members belonging to the class.,5,5,5,0.043546438,0.956453562,0.944433783,0.739597857,0.771459027,0.989905765,0.884587217,0.999970594,0.96532691,0.964118576,0.904229629,0.960849709,0.902021933,0.942434669,0.928243886
214,214,214,2.1,a public and private area that includes the functions and variables that are used in the class,5,4,4.5,0.070497453,0.929502547,0.910043692,0.282841563,0.370588564,0.983285936,0.808899172,0.999926278,0.913073966,0.958159569,0.888324566,0.960165423,0.900309429,0.729119241,0.662343316
215,215,215,2.1,"the keyword class followed by they class name, on the inside you declare public and private declarations of your class",3,4,3.5,0.088456154,0.911543846,0.887127993,0.091756925,0.202883842,0.973381172,0.695652706,0.999968263,0.962579016,0.968035578,0.914684419,0.966427541,0.915981093,0.629265606,0.537874407
216,216,216,2.1,A class definition typically includes function definitions.,3,3,3,0.075643241,0.924356759,0.903477553,0.336271465,0.417481119,0.986793605,0.849004219,0.999959991,0.95282457,0.969363507,0.918228767,0.959365405,0.898307293,0.621325731,0.527977245
217,217,217,2.1,"It begins with Class, followed by the class name, then usually a constructor, data members and member functions that delineates the class is included in any class's definition.",5,5,5,0.065686643,0.934313357,0.916182392,0.482338905,0.545676665,0.984058077,0.817727465,0.999970382,0.965076628,0.963202246,0.901783872,0.969555431,0.923808995,0.814217687,0.768419681
218,218,218,2.1,the data and methods,5,4,4.5,0.076870382,0.923129618,0.901911695,0.348201186,0.427951194,0.983117683,0.806975438,0.999924924,0.911477496,0.915795128,0.775250508,0.923069377,0.807472344,0.657042265,0.572498388
219,219,219,2.1,"A constructor, functions, and variables that are accessible to by that class, and possibly other classes depending on how they are done.",5,4,4.5,0.082098484,0.917901516,0.895240521,0.33862102,0.419543198,0.995514758,0.948717827,0.999935592,0.924055189,0.952184268,0.872376013,0.962441824,0.906006382,0.68703109,0.609879865
220,220,220,2.1,Member functions and data members.,5,5,5,0.009306312,0.990693688,0.988124941,0.947265506,0.953717767,1,1,0.999912934,0.897338979,0.960986605,0.89587015,0.952731333,0.881704771,0.971831381,0.964887287
221,221,221,2.1,"public section and private section, and there must be a semicolon to set the end",1,4,2.5,0.09752363,0.90247637,0.875557694,0.12837863,0.235024745,0.990765476,0.894416752,0.999876413,0.854277332,0.938525074,0.83591854,0.959055276,0.89753116,0.616123497,0.52149259
222,222,222,2.1,member funtions and data members,5,5,5,0.069948554,0.930051446,0.9107441,0.684294939,0.722922627,0.99025767,0.888610727,0.999960691,0.95365,0.960988487,0.895875173,0.961258441,0.903044831,0.934082508,0.917832805
223,223,223,2.1,Data members and Member functions,5,5,5,0.045626342,0.954373658,0.941779779,0.751540959,0.781940846,0.99025767,0.888610727,0.99995452,0.946373973,0.987632807,0.96699098,0.967163148,0.917822034,0.971831262,0.964887138
224,224,224,2.1,data members and member functions,5,5,5,0.045626342,0.954373658,0.941779779,0.777678669,0.80488051,0.99025767,0.888610727,0.999937455,0.92625224,0.989792616,0.972755681,0.966563219,0.916320643,0.971831262,0.964887138
225,225,225,2.1,"the class name and its public data types such as constructors, methods, functions.",2,5,3.5,0.063760996,0.936239004,0.918639561,0.483137667,0.546377695,0.980479733,0.776814347,0.999950762,0.941943139,0.970006658,0.919945388,0.959667783,0.899064028,0.76101476,0.702101511
226,226,226,2.1,"a constructor and several data members, and at least one public data member or method",4,5,4.5,0.05931133,0.94068867,0.924317432,0.511290312,0.571085759,0.994679242,0.939164925,0.999953604,0.945293654,0.950443091,0.867728674,0.96141327,0.903432309,0.811937213,0.765577039
227,227,227,2.1,"class name, two curly prenthesis, public and private",1,3,2,0.095293105,0.904706895,0.878403893,0.067000717,0.181156648,0.983725652,0.813926676,0.999968139,0.962432081,0.9666117,0.910883975,0.955993067,0.889867633,0.533150077,0.418065097
228,228,228,2.1,data members and member functions,5,5,5,0.045626342,0.954373658,0.941779779,0.777678669,0.80488051,0.99025767,0.888610727,0.999937455,0.92625224,0.989792616,0.972755681,0.966563219,0.916320643,0.971831262,0.964887138
229,229,229,2.1,Data and functions,5,4,4.5,0.088785529,0.911214471,0.886707703,0.55070442,0.605677404,0.980744577,0.779842446,0.999888613,0.868662401,0.915766658,0.77517452,0.970909393,0.927197439,0.816548526,0.771325104
230,230,230,2.1,functions and data members that belong to the class,5,5,5,0.05829674,0.94170326,0.925612072,0.563371301,0.616794445,0.987425903,0.856233625,0.999946975,0.93747758,0.964321123,0.904770243,0.960321751,0.900700658,0.908607364,0.886077692
231,231,231,2.1,"class variables, function definitions for the class",5,5,5,0.083563983,0.916436017,0.893370511,0.265422553,0.355300835,0.990464131,0.89097131,0.999967801,0.962033164,0.958484538,0.889191934,0.95890753,0.897161409,0.634327054,0.54418357
232,232,232,2.1,"A class is an expanded concept of a data structure, it holds both the data and the functions being executed ",5,4,4.5,0.072170377,0.927829623,0.907909005,0.362689227,0.440666569,0.988891096,0.872985958,0.999955242,0.947225009,0.95655566,0.884043606,0.960252527,0.900527417,0.790460765,0.738806357
233,233,233,2.2,Data members are the data components of a particular class.  A member function are the functioning components of the class.,1,5,3,0.029294729,0.970705271,0.962619278,0.623681426,0.669725403,0.99605124,0.95485171,0.999969019,0.963470366,0.979283232,0.944705301,0.987683768,0.969177225,0.828905523,0.786728268
234,234,234,2.2,A field variable is a variable that is declared as a member of a class. A local variable is avariable that isdeclared local to a method.,1,4,2.5,0.039726079,0.960273922,0.949308646,0.397849083,0.471524486,0.991702732,0.905132897,0.999965822,0.959699867,0.966974921,0.911853441,0.97930931,0.948219189,0.71432215,0.643898541
235,235,235,2.2,"Data members are declared inside the class, but outside of any member functions. Unlike with local variables, each object of the class keeps its own copy of the data members stored in memory.",4,5,4.5,0.016627073,0.983372927,0.978783487,0.711735606,0.747005827,0.989280885,0.877442629,0.999972813,0.967943767,0.972831315,0.927484622,0.986645488,0.966578811,0.876961231,0.846630359
236,236,236,2.2,Data member are variables that represent an attribute in a class definition.  Local variables declared in a function body cannot be used outside of that function body.  When a function terminates the values of its local variables are lost.,4,5,4.5,0.018011272,0.981988728,0.977017219,0.712884724,0.748014346,0.99556943,0.949342928,0.99996707,0.961171438,0.958907812,0.890321686,0.990316639,0.975766285,0.882279217,0.853259301
237,237,237,2.2,A local variable cannot be accessed outside the function in which it is declared. Data members normally are private. Variables of functions declared private are accessible only to member functions of the class in which they are declared.,5,5,5,0.013175011,0.986824989,0.983188395,0.711608589,0.74689435,0.996182466,0.956352097,0.999989161,0.987220051,0.967412712,0.91302194,0.973870046,0.934606811,0.893812418,0.867635592
238,238,238,2.2,"A data member is part of a C++ class or structure that stores data of a certain type... A local variable inside a member function is only available inside that function, and can be used to derive a desired outcome.",4,5,4.5,0.018060446,0.981939554,0.976954472,0.684016585,0.722678331,0.992208625,0.910917043,0.999954188,0.945982203,0.974489467,0.931910361,0.983928928,0.95978031,0.756887317,0.696956598
239,239,239,2.2,A local variable can only be accessed within the scope of its declaration.,3,4,3.5,0.028434217,0.971565783,0.963717311,0.501183212,0.5622153,0.995476065,0.948275436,0.999979625,0.975975759,0.936880381,0.831528723,0.980705517,0.951713356,0.783570409,0.730217434
240,240,240,2.2,Data members are the atributes of the function and can be used outside the function. Local variable can not be used outside the function and the value is lost after the function terminates.,4,5,4.5,0.017988443,0.982011557,0.977046349,0.671315134,0.711530949,0.995839713,0.952433211,0.999923964,0.910345029,0.954725587,0.879158996,0.986952103,0.96734615,0.767460763,0.710136543
241,241,241,2.2,"data members are permanent attributes of the class, local variables inside a member function are lost when the scope of the member function ends.",3,5,4,0.016465902,0.983534098,0.978989145,0.736417115,0.768667461,0.99262314,0.915656415,0.999972026,0.967015417,0.975940685,0.935783777,0.978430463,0.946019774,0.831304669,0.789718836
242,242,242,2.2,data members are declared in a class definition but outside the bodies of a class's member-function definitions. Local variables are declared in a function definition's body,3,5,4,0.023514211,0.976485789,0.969995347,0.59662205,0.645976842,0.995634134,0.950082715,0.999972272,0.967305189,0.988744829,0.969959055,0.985876788,0.964655052,0.85526979,0.819591683
243,243,243,2.2,"A data member is globally accessible, while a local variable is only accessible inside the member function.",4,5,4.5,0.017914593,0.982085407,0.977140583,0.67715925,0.716660016,0.988618109,0.869864748,0.999895578,0.876875078,0.934648279,0.825571066,0.971744284,0.929286849,0.658887804,0.574798877
244,244,244,2.2,A variable inside a member function can only be accessed inside that member and a data member can be accessed throughought the program.,5,5,5,0.009285033,0.990714967,0.988152093,0.803036392,0.827135622,0.996341621,0.958171793,0.99996823,0.962539115,0.944314221,0.851370233,0.978612634,0.946475678,0.798596025,0.748947067
245,245,245,2.2,Local variables are used only within the scope of its declaration,5,4,4.5,0.033689141,0.966310859,0.957011911,0.400985658,0.47427729,0.995436514,0.947823221,0.999960626,0.95357348,0.946985524,0.858500153,0.977592589,0.943922899,0.821656108,0.777691774
246,246,246,2.2,"A data member is a more general term describing all objects instantiated within a member function.  ""Local"" in local variables refers more to the scope of a variable, which may be located in anything from a control structure to a class.  Local variables whose scope are in a member function are the same as data members of member functions.",0,4,2,0.019751251,0.980248749,0.974796968,0.700050712,0.736750622,0.991341372,0.901001276,0.999969889,0.964495701,0.939875621,0.839523257,0.975749999,0.939311608,0.89636457,0.870816883
247,247,247,2.2,A data member exists permanently in that program's memory as long as it's run.  A local variable inside a member function is temporal and only used to operate in the function and exists as long as the function is run.,2,5,3.5,0.022144079,0.977855921,0.971743666,0.55937767,0.613289451,0.994108254,0.932636511,0.999967598,0.961794899,0.963887374,0.903612533,0.981252058,0.953081138,0.748484075,0.686481843
248,248,248,2.2,"local variables can only be used within the function, where as data members can be set to public access and can be used throughout",5,5,5,0.022420466,0.977579534,0.97139099,0.5896824,0.639886284,0.992510555,0.914369173,0.999937662,0.926496114,0.951920802,0.871672802,0.956765959,0.891801883,0.813338399,0.767323637
249,249,249,2.2,"The local variable is lost once it exits the block of code, while the data member is not.",4,5,4.5,0.02640307,0.973596931,0.9663091,0.424690932,0.495082136,0.993407029,0.924619035,0.999928318,0.915478395,0.935288506,0.827279883,0.968519609,0.921216732,0.663140416,0.580099816
250,250,250,2.2,Every member function can access and modify a data member. A local variable can only be used from the line of declaration to the next closing } before it is lost from memory.,4,5,4.5,0.018764973,0.981235027,0.97605548,0.63203907,0.677060458,0.996942763,0.965044972,0.999963204,0.956613055,0.965623137,0.908245422,0.98529839,0.963207545,0.76764673,0.710368352
251,251,251,2.2,"data member is accessible to all functions in the class, where local variable is only available to the member function and value is lost when function closes",5,5,5,0.0172351,0.9827649,0.978007631,0.649338782,0.692243486,0.992366025,0.912716676,0.999914552,0.89924747,0.968450685,0.915792372,0.990991148,0.977454321,0.767109156,0.709698259
252,252,252,2.2,Data members are variables that are declared inside the class definition but outside of the bodies of the class member functions. Local variables can only be used within the function declaration.,4,5,4.5,0.011616886,0.988383114,0.985176597,0.79997164,0.824445854,0.995695383,0.950783009,0.999989845,0.988026045,0.968284023,0.915347538,0.982820331,0.95700592,0.911879003,0.890155835
253,253,253,2.2,"The data member can be accessed outside of the class, whereas the local variable cannot.",3,5,4,0.01756537,0.98243463,0.9775862,0.638429344,0.682668858,0.997035318,0.966103204,0.999976663,0.972483279,0.963763396,0.903281626,0.982641107,0.956557391,0.770219028,0.713574757
254,254,254,2.2,"Local variables cannot be used outside of that function body. When a function terminates the values of its local variables are lost. Where as data members are variables in a class definition, and they exist throughout the life of the object. ",5,5,5,0.01722002,0.98277998,0.978026874,0.687579274,0.725805112,0.996136996,0.955832205,0.999970594,0.965327325,0.956788704,0.884665619,0.987138589,0.967812853,0.852593064,0.816255109
255,255,255,2.2,a local variable in a member function has to be static. a data member can change its value freely.,0,4,2,0.022194684,0.977805316,0.971679093,0.611869574,0.659358774,0.993872494,0.929940952,0.999881039,0.85973209,0.942298218,0.845989361,0.977469626,0.94361517,0.642309904,0.554134301
256,256,256,2.2,"a local variable is only useable within the function it is defined, whereas a data member is available to any method within its class",5,5,5,0.022456348,0.977543652,0.971345204,0.568160415,0.620997594,0.99137811,0.901421322,0.999933785,0.921925105,0.920423129,0.787603011,0.985504433,0.963723191,0.751663506,0.690445047
257,257,257,2.2,Variable declared in a function defination's body cannot be used outside of that function.  Data members accessible only to member function of that class.,5,5,5,0.013689816,0.986310184,0.982531492,0.750858843,0.78134219,0.996594254,0.961060283,0.999945328,0.93553599,0.975253525,0.933949693,0.981106807,0.95271763,0.874869466,0.844022945
258,258,258,2.2,"data members   local variables are declared in a function definitionâ€™s body. they Cannot be used outside of that function body. When a function terminates, the values of its local variables are lost.   ",5,4,4.5,0.017824471,0.982175529,0.977255581,0.664438903,0.705496051,0.994732773,0.939776977,0.999971804,0.966753704,0.965695458,0.908438453,0.983176917,0.957898317,0.835806251,0.795330118
259,259,259,2.2,local variable is only available in the function.,4,5,4.5,0.030151069,0.969848931,0.96152657,0.512174845,0.571862066,0.990567313,0.892151042,0.999852007,0.825499317,0.876227388,0.669641067,0.88466419,0.711358985,0.412677348,0.267894208
260,260,260,2.2,local variables are accessed inside member functions only while data members   can be accessed throughout the class,4,5,4.5,0.01390928,0.98609072,0.982251451,0.829386592,0.850261777,0.995633233,0.950072413,0.9999819,0.978658144,0.972108168,0.925554485,0.991146122,0.977842161,0.921457171,0.902095152
261,261,261,2.2,"A data member is accessible anywhere in the class, while i local variable in a member function is only accessible in that particular function, and is freed after the function exits.",5,5,5,0.019265294,0.980734706,0.975417059,0.662404478,0.703710545,0.988531767,0.868877562,0.999948012,0.938700618,0.951241234,0.869858981,0.993730746,0.984310477,0.703260601,0.63011017
262,262,262,2.2,"a Data member is encapsulated within a class or object,  it is static and can be shared by all instances of that class.  however local variable's are only used from the function or block in which it is declared and not the whole class. other wise they would be called global variables. ",3,5,4,0.021972775,0.978027225,0.971962253,0.572677791,0.624962252,0.989702776,0.882266329,0.99995515,0.947116481,0.954618678,0.878873647,0.976803356,0.941947754,0.858889341,0.824103504
263,263,263,2.3,A constructor initializes an object or objects of a class.  A function of a class performs a task such as display a line of text or do some kind of mathematical operations.,2,3,2.5,0.025745571,0.974254429,0.967148083,0.415721804,0.487210414,0.992044522,0.909040763,0.999976494,0.972283431,0.929104294,0.81077373,0.973564681,0.9338426,0.79362607,0.742751952
264,264,264,2.3,"all constructors are functions but not all functions are constructors. Also functions can have nearly infinite purposes, while constructors always create an instance of whichever class you are using. You can change how a constructor does something but not what it does. With functions you can change not only the how but also the what.",2,4,3,0.017699122,0.982300878,0.977415529,0.614055693,0.661277414,0.985646686,0.835890888,0.999982378,0.979221389,0.945340382,0.854109138,0.96486985,0.912082794,0.841680229,0.802652112
265,265,265,2.3,"Unlike regular functions, constructors are only used to initialize an objectâ€™s data when it is created. Constructors must also be given the same name as the class and cannot return any values. ",5,5,5,0.013465762,0.986534238,0.98281739,0.64461416,0.688096939,0.994526148,0.937414526,0.999983028,0.979987792,0.952357723,0.872838979,0.974154103,0.935317696,0.897024214,0.871639139
266,266,266,2.3,"A constructor typically used to intialize data members and allocate resources, for instance memory, files, etc.  Also a constructor cannot return values.  Functions are operations that maybe globally defined.",4,5,4.5,0.01702404,0.98297596,0.978276949,0.561592877,0.615233618,0.992532385,0.91461876,0.999982477,0.979338712,0.94283884,0.847432324,0.970546972,0.926290439,0.834372044,0.79354236
267,267,267,2.3,"Constructors cannot return values, so they cannot specify a return type. Normally, constructors are declared public.",3,5,4,0.011685133,0.988314867,0.985089512,0.625009835,0.670891276,0.99070846,0.893764852,0.99998442,0.98162943,0.916600632,0.777400462,0.968891339,0.922147029,0.872834623,0.841486486
268,268,268,2.3,A constructor is a method that starts new instances of a class. (Example: Employee employee1(parameters) starts a new instance of object of type Employee). A function is simply a module w/in a program that completes its single desired task.,2,4,3,0.023547769,0.976452231,0.969952527,0.438185155,0.50692529,0.990185448,0.887784983,0.999988015,0.985868754,0.961818469,0.898090461,0.978164018,0.945352965,0.849710822,0.812662355
269,269,269,2.3,A constructor is called whenever a new object of that class is made.,4,3,3.5,0.018564165,0.981435835,0.976311716,0.583469749,0.634433773,0.993542181,0.926164296,0.999984978,0.982287849,0.907537259,0.7532096,0.965837822,0.914505254,0.857686818,0.822604542
270,270,270,2.3,A constructor does not return any date and has no return type.  Functions can return date or not return data can have a return type.,3,5,4,0.017807126,0.982192874,0.977277714,0.565094352,0.618306675,0.989281462,0.877449222,0.999960855,0.953843857,0.935313648,0.827346989,0.972522618,0.931234719,0.858708441,0.823878009
271,271,271,2.3,"A constructor is automatically called whenever an instance of a class is created, a function must be explicitly called by the user. ",4,4,4,0.011878431,0.988121569,0.98484286,0.669374824,0.709828043,0.997806132,0.97491633,0.999989679,0.987830141,0.956779917,0.884642166,0.981797463,0.954446076,0.883825421,0.855186665
272,272,272,2.3,"constructors cannot return values, so they cannot specify a return type like functions can.",3,5,4,0.01696676,0.98303324,0.978350039,0.612329662,0.659762569,0.990718183,0.893876021,0.999975126,0.970671233,0.904801838,0.745908544,0.975260682,0.938087036,0.904239297,0.880632838
273,273,273,2.3,A constructor is a function used to initialize an object's data when it is created.,4,3,3.5,0.01480931,0.98519069,0.981102993,0.604676962,0.653046205,0.993941209,0.930726604,0.999978673,0.974852897,0.88214625,0.68543898,0.960049666,0.900019734,0.827250481,0.784665235
274,274,274,2.3,a constructor initialises everything so that nothing is left empty or with random varioubles and a function modifies those variables with data.,2,3,2.5,0.028581798,0.971418202,0.963528994,0.351552278,0.430892268,0.991365275,0.901274575,0.999970329,0.965014989,0.910953135,0.762326844,0.959532766,0.898726133,0.704354048,0.631473167
275,275,275,2.3,A constructor initialized values at the execution of its instantiation. It provides default values.,4,3,3.5,0.028358519,0.971641481,0.963813903,0.270225465,0.359516093,0.989809985,0.883492107,0.999974178,0.969552415,0.919379916,0.784818592,0.965076507,0.912599977,0.790065229,0.738313315
276,276,276,2.3,"A constructor sets up the default values of variables when an object is instantiated, whereas a function allows interaction with that object.",4,4,4,0.020355582,0.979644418,0.974025827,0.531986475,0.58924967,0.993132926,0.921485066,0.999990744,0.989085915,0.940255853,0.840538126,0.972351228,0.930805796,0.818730652,0.774045154
277,277,277,2.3,"A constructor is used to create an object that can be employed in the main function of a program.  This may or may not execute code along with it.  A function is a set of code that executes when called, but does not create a new object.",3,3,3,0.011876881,0.988123119,0.984844837,0.667319,0.708023757,0.993085263,0.92094011,0.999969821,0.964415193,0.930005571,0.813179309,0.95678856,0.891858445,0.880856812,0.851486253
278,278,278,2.3,a constructor initializes data members but the functions actually perform tasks. Constructors cant return values either.,3,5,4,0.04607749,0.95392251,0.941204105,0.552986205,0.607680005,0.990551745,0.891973049,0.99995532,0.94731667,0.909244881,0.757767379,0.96659288,0.916394873,0.843281627,0.804648276
279,279,279,2.3,"a constructor does not need a type, and it is used to initialize the variables.",3,4,3.5,0.0113855,0.9886145,0.98547185,0.555282056,0.60969495,0.98537779,0.832816457,0.999984146,0.981306884,0.845631987,0.587979512,0.976153984,0.940322626,0.790039778,0.73828159
280,280,280,2.3,Constructors don't have a return type.,3,5,4,0.023372769,0.976627231,0.97017583,0.601152182,0.649952695,0.989310613,0.87778252,0.999969478,0.964010547,0.840928166,0.57542464,0.967172968,0.91784661,0.87385875,0.842763074
281,281,281,2.3,constructor creates the class object into memory where functions perform actions against that object,2,4,3,0.046366572,0.953633428,0.940835229,0.371410042,0.448320361,0.989540875,0.880415225,0.999976694,0.972519518,0.914085386,0.770687071,0.96238745,0.905870305,0.774381459,0.718763283
282,282,282,2.3,constructors cannot return values,3,5,4,0.060514987,0.939485014,0.92278154,0.33991158,0.420675852,0.981541218,0.788950878,0.999940572,0.929928213,0.830810644,0.54842017,0.961990853,0.904877776,0.747246504,0.684939194
283,283,283,2.3,A constructor initializes values and a function usual performs some sort of operation.,2,3,2.5,0.025364399,0.974635601,0.967634467,0.44363749,0.511710512,0.991809856,0.906357708,0.999979791,0.976171353,0.893871488,0.716734572,0.97320069,0.932931671,0.778043211,0.723327706
284,284,284,2.3,A constructor is a function used to initialize an object's data when it is created. It's call is made implicitly when the object is created and must be defined with the same name as the class. Constructor also cannot return a value like a function can.,5,5,5,0.01062113,0.98937887,0.986447203,0.720133126,0.754375878,0.992874251,0.918527497,0.999981336,0.977993017,0.939562722,0.838688105,0.958479269,0.896089637,0.907168806,0.88428451
285,285,285,2.3,A constructor is used to create an instance of a class and has the same name as that class. A function cannot have the same name as a class and computes data.,4,4,4,0.018170238,0.981829763,0.976814376,0.444821596,0.512749738,0.992465574,0.913854875,0.999951315,0.942595361,0.928026337,0.807896577,0.932435324,0.830911695,0.835129321,0.794486316
286,286,286,2.3,"a constructor is a function that initializes a class instance, a function performs whatever task it is written for",2,4,3,0.019948006,0.980051994,0.974545904,0.458169133,0.524464154,0.994202779,0.933717269,0.999985482,0.982881476,0.909667153,0.758894456,0.969809763,0.92444549,0.751342595,0.690045027
287,287,287,2.3,"A constructor cannot return values, not even void, but function get a return value.",3,5,4,0.015381634,0.984618366,0.980372695,0.521423817,0.579979392,0.991673908,0.904803336,0.999958169,0.950676808,0.929148606,0.810892002,0.967799571,0.919414755,0.832825422,0.791614475
288,288,288,2.3,"a constructor cannot return values, its not even void. it is used to initialize an object's data when it is created. whereas, a function is created to do a specific task, and it can return values.",5,5,5,0.008107483,0.991892517,0.989654672,0.683625937,0.722335479,0.991475071,0.902529925,0.999966324,0.960292445,0.934196965,0.824366473,0.97009789,0.92516656,0.867497325,0.834833472
289,289,289,2.3,A constructor initializes an object. A function is part of an object.,1,4,2.5,0.025251806,0.974748194,0.967778138,0.523665547,0.581946839,0.993253881,0.922868012,0.999964486,0.958125307,0.901187437,0.736261421,0.948249949,0.870489597,0.767081738,0.709664082
290,290,290,2.3,constructors initialize the data that is then used in the calculations of a   function,2,3,2.5,0.040229917,0.959770083,0.948665738,0.339985728,0.420740928,0.99117092,0.899052412,0.999976886,0.97274618,0.84755901,0.593122889,0.95851686,0.896183712,0.701567829,0.628000107
291,291,291,2.3,"a constructor is called when the class is created, a function can be called any time.",4,3,3.5,0.012099445,0.987900555,0.984560841,0.670686603,0.710979321,0.993232461,0.922623103,0.999958033,0.950516277,0.897848939,0.727350704,0.936564686,0.841245894,0.813749909,0.76783659
292,292,292,2.3,"constructor is a special block of statements called when an object is created, either when it is declared statically or constructed on the stack. However a function is a portion of code within a larger program, which performs a specific task and independent to the rest of the code. ",4,4,4,0.019539058,0.980460942,0.97506773,0.551845431,0.606678809,0.993989108,0.931274254,0.999987116,0.98480858,0.94364438,0.849582374,0.966073301,0.915094568,0.8479563,0.810475319
293,293,293,2.4,The compiler creates a default constructor when we do not define one in our class file,5,5,5,0.022903919,0.977096081,0.970774093,0.693130255,0.730676909,0.989855547,0.884013048,0.99997995,0.976358292,0.98004103,0.946727924,0.971862696,0.929583189,0.860750079,0.826422939
294,294,294,2.4,during compilation,2,5,3.5,0.225274086,0.774725914,0.712545289,0.206362009,0.303466568,0.976925049,0.736171746,0.999862833,0.8382645,0.88372601,0.689655485,0.976777199,0.941882293,0.515164614,0.395645974
295,295,295,2.4,When the class does not explicitly include a constructor.,5,5,5,0.019539833,0.980460167,0.975066741,0.558415711,0.612445191,0.98263914,0.801504003,0.999963478,0.956935826,0.937701598,0.833720617,0.9429384,0.85719684,0.759500623,0.700214119
296,296,296,2.4,When no parameters are set is when a default constructor is used.,3,3,3,0.020198226,0.979801774,0.974226617,0.627421498,0.673007863,0.987785352,0.860343399,0.999970849,0.965627509,0.939537911,0.838621882,0.952272102,0.880555493,0.628308654,0.536681553
297,297,297,2.4,When a class does not explicitly include a constructor.,5,5,5,0.019377232,0.980622768,0.975274224,0.561836302,0.61544726,0.98397673,0.816797381,0.999968073,0.962353855,0.937701598,0.833720617,0.9429384,0.85719684,0.759500623,0.700214119
298,298,298,2.4,When there are no arguments passed.,1,2,1.5,0.051370561,0.948629439,0.934450029,0.247074038,0.339197329,0.982278381,0.797379248,0.999937738,0.92658619,0.881534121,0.683805159,0.976777199,0.941882293,0.520177245,0.401894287
299,299,299,2.4,when there is not one already for a specific class,5,5,5,0.047268808,0.952731192,0.939683957,0.179068938,0.279512906,0.977214822,0.739484875,0.999954207,0.946005387,0.941702088,0.844398242,0.939000853,0.84734268,0.738471091,0.674000523
300,300,300,2.4,When it the programs compiles,2,5,3.5,0.068769574,0.931230426,0.912248504,0.223319262,0.318349038,0.980313771,0.774916817,0.999880152,0.858685496,0.881534121,0.683805159,0.976777199,0.941882293,0.652983963,0.567439661
301,301,301,2.4,when a constructor is not provided by the programmer of the class,5,5,5,0.019272268,0.980727732,0.975408161,0.539220214,0.595598334,0.985774296,0.837349917,0.999980858,0.977429462,0.928641677,0.809538968,0.976069018,0.940109989,0.818561316,0.773834073
302,302,302,2.4,In any class that does not explicitly include a constructor.,5,5,5,0.02386111,0.97613889,0.969552696,0.529748797,0.58728578,0.97984929,0.769606161,0.999974945,0.970457536,0.958004444,0.887910525,0.966636742,0.916504643,0.814023077,0.768177098
303,303,303,2.4,Before the main function of the code.,0,2,1,0.048769772,0.951230228,0.937768693,0.269591481,0.358959679,0.978570982,0.754990573,0.999918368,0.903747046,0.957480596,0.886512333,0.958896269,0.897133227,0.6616292,0.578216065
304,304,304,2.4,whenevery you dont specifiy your own,5,5,5,0.1394099,0.8605901,0.822109888,0.09653464,0.207076986,0.984229279,0.81968491,0.999932673,0.920614393,0.918974122,0.783735496,0.976777207,0.941882313,0.560320616,0.451933542
305,305,305,2.4,When non are provided,5,5,5,0.070804894,0.929195106,0.909651391,0.295572192,0.381761553,0.974553891,0.709061028,0.99978145,0.74230549,0.909572543,0.758641935,0.957409483,0.893412375,0.691302061,0.615203688
306,306,306,2.4,C++ will create a default constructor when no other constructor is present.,5,5,5,0.028276384,0.971723616,0.963918709,0.707918465,0.743655727,0.98805388,0.86341362,0.999983625,0.980691843,0.88578265,0.695144821,0.905536255,0.763593708,0.438419074,0.299981619
307,307,307,2.4,"When no constructor was specified in the constructor's class, but the class is instantiated in a program.",5,5,5,0.027338862,0.972661138,0.965115008,0.57573694,0.627647103,0.992306731,0.912038741,0.999973596,0.968866268,0.965942849,0.909098759,0.975945827,0.939801689,0.737467766,0.672749865
308,308,308,2.4,"When no constructor exists when one is needed, a parameterless default constructor is declared.",5,5,5,0.012084544,0.987915456,0.984579855,0.698397279,0.735299493,0.99586702,0.952745433,0.999978406,0.974537821,0.947950198,0.861074944,0.96195441,0.904786573,0.80324167,0.754737928
309,309,309,2.4,"The Compiler creates this automatically for you, unless you specifically create one.",5,5,5,0.029001653,0.970998347,0.96299325,0.453068525,0.519987624,0.992406172,0.913175703,0.999979529,0.975862693,0.961826244,0.898111213,0.975292737,0.938167257,0.823476195,0.779960537
310,310,310,2.4,In any class that doesn't explicitly include a constructor.,5,5,5,0.031251311,0.968748689,0.960122636,0.527013958,0.584885558,0.981877238,0.792792767,0.999965669,0.959519855,0.960280449,0.893985363,0.976053164,0.940070313,0.828388333,0.786083584
311,311,311,2.4,when no user-defined constructor exists,5,5,5,0.101483226,0.898516774,0.870505162,0.491117179,0.553380885,0.97930901,0.76342885,0.999824748,0.79335849,0.881534121,0.683805159,0.976777199,0.941882293,0.655341208,0.570377998
312,312,312,2.4,"If a class does not explicitly include a constructor, the compiler creates one.",5,5,5,0.010335386,0.989664614,0.986811819,0.766738474,0.795278889,0.990587396,0.892380669,0.99997945,0.975768926,0.962941255,0.901087266,0.977513851,0.943725848,0.931565464,0.914695275
313,313,313,2.4,When you do not provide your own constructor.,5,5,5,0.045756042,0.954243958,0.94161428,0.533705056,0.590757976,0.981204126,0.785096721,0.999970303,0.964983526,0.88372601,0.689655485,0.897797773,0.744227274,0.578614354,0.474736935
314,314,314,2.4,When a class does not explicitly include a constructor.,5,5,5,0.019377232,0.980622768,0.975274224,0.561836302,0.61544726,0.98397673,0.816797381,0.999968073,0.962353855,0.937701598,0.833720617,0.9429384,0.85719684,0.759500623,0.700214119
315,315,315,2.4,C++ creates a default constructor during compilation if one is not provided.,5,5,5,0.015936494,0.984063506,0.979664682,0.781404138,0.808150154,0.988814632,0.872111701,0.999980264,0.976729404,0.952057531,0.872037742,0.975295424,0.938173982,0.850993931,0.814261768
316,316,316,2.4,when a class does not explicitly include a constructor,5,5,5,0.025583446,0.974416554,0.967354958,0.473848313,0.538224928,0.979687479,0.767756088,0.999962482,0.955762127,0.937701598,0.833720617,0.9429384,0.85719684,0.759500623,0.700214119
317,317,317,2.4,The compiler will provide one when class does not explictly include a consructor.,5,5,5,0.021637321,0.97836268,0.972390301,0.620926201,0.66730729,0.989124097,0.875649984,0.99996732,0.961466354,0.984839408,0.959535176,0.960021502,0.89994925,0.857897639,0.822867334
318,318,318,2.4,when the programmer does not explicitly include a constructor,5,5,5,0.021197557,0.978802443,0.972951448,0.488243312,0.550858645,0.9809686,0.782403821,0.999971449,0.966334627,0.926325466,0.803356817,0.971982361,0.929882664,0.698879719,0.624649341
319,319,319,2.4,When one is not explicitly stated.,5,5,5,0.037382841,0.962617159,0.952298669,0.314057738,0.397985324,0.981708935,0.790868474,0.999942273,0.931932852,0.944341214,0.851442279,0.967633796,0.918999884,0.733937442,0.668349269
320,320,320,2.4,when one is not explicitly included by a class,5,5,5,0.03837502,0.96162498,0.951032627,0.273638308,0.362511362,0.980137966,0.772906743,0.999951684,0.943030166,0.93689032,0.831555251,0.963995577,0.909894826,0.80110997,0.752080734
321,321,321,2.4,When you dont specify any constructors.,5,5,5,0.047362328,0.952637672,0.939564624,0.475624025,0.539783375,0.984402897,0.821669986,0.999946819,0.937293899,0.918974122,0.783735496,0.976777207,0.941882313,0.71485275,0.644559942
322,322,322,2.4,"at the very beginning when you run a complier, matter a fact in C++ it generates its own default constructor for the class provided if no other constructors have been provided by user",5,5,5,0.015715182,0.984284818,0.979947081,0.581828117,0.632993002,0.992284982,0.911790072,0.999976961,0.972834757,0.973258178,0.928623953,0.963887551,0.909624479,0.870696127,0.838820822
323,323,323,2.5,Just one per class.,0,0,0,0.07369262,0.92630738,0.905966589,0.381242245,0.456949557,0.988280895,0.866009204,0.999873051,0.850312517,0.920075759,0.786675852,0.902108877,0.755016303,0.415489286,0.271399328
324,324,324,2.5,As many as you want so long as they have different parameters.,5,5,5,0.088773608,0.911226392,0.886722915,0.170116603,0.271655922,0.993379306,0.924302065,0.999845655,0.818009768,0.941900518,0.844927868,0.936999255,0.842333452,0.463743955,0.331549426
325,325,325,2.5,"There is no limit to the number of constructors in a class because like functions, constructors can be overloaded.",5,5,5,0.076626301,0.923373699,0.902223147,0.31364277,0.397621129,0.987371582,0.855612542,0.999908586,0.892212218,0.949672959,0.86567313,0.939593051,0.848824723,0.68447715,0.606696345
326,326,326,2.5,It depends what type of class is being defined.  Typically you would have a constructor call for each object.,1,2,1.5,0.076570749,0.923429251,0.902294032,0.195063725,0.293550671,0.987016179,0.851549032,0.999901272,0.883588465,0.888468933,0.702314723,0.922447754,0.805916662,0.505762875,0.383926579
327,327,327,2.5,"In C++, the constructor can be overloaded in that there can be more than one constructor for a class, each having different parameters.",5,5,5,0.090441525,0.909558475,0.884594616,0.200009346,0.297891177,0.986294619,0.843299054,0.999891223,0.871739778,0.932766318,0.820547962,0.945985309,0.864822077,0.452290863,0.317272992
328,328,328,2.5,1,0,0,0,0.245399892,0.754600108,0.686864316,0.061966006,0.176737953,0.974913629,0.713174109,0.999807912,0.773507118,0.981994652,0.951942296,0.876784029,0.691637984,0.272196949,0.092783488
329,329,329,2.5,any number you want,5,5,5,0.127340257,0.872659743,0.837511019,0.257908702,0.348706331,0.992441847,0.9135836,0.999884762,0.864121263,0.997065259,0.992166943,0.941767604,0.854266789,0.694990754,0.619801694
330,330,330,2.5,One,0,0,0,0.250252783,0.749747217,0.68067192,0.084790774,0.196770025,0.980687516,0.779190042,0.999396654,0.288586706,0.981820016,0.951476179,0.89404694,0.734840387,0.402240932,0.254885075
331,331,331,2.5,"by default just one, but they may be overloaded to create as many constructors as necessary",5,5,5,0.093358159,0.906641841,0.880872926,0.006032733,0.127648323,0.984581643,0.823713684,0.999889866,0.870139684,0.920239365,0.78711253,0.934766805,0.836746492,0.556337118,0.446968058
332,332,332,2.5,as many as you want,5,5,5,0.14085114,0.85914886,0.820270834,-0.035546917,0.091156098,0.99134998,0.901099691,0.999785245,0.746780139,0.982002555,0.95196339,0.955472359,0.888564501,0.273953021,0.094972455
333,333,333,2.5,"As many as you want, with different parameters.",5,5,5,0.083780348,0.916219652,0.893094425,0.276220858,0.364777927,0.992866424,0.918438005,0.999897166,0.878747584,0.956319402,0.883413014,0.934121305,0.835131054,0.394054025,0.244679985
334,334,334,2.5,infinite,5,5,5,0.146169484,0.853830516,0.813484509,0.143929541,0.248672945,0.912537984,0,0.999538282,0.455582439,0.982186909,0.952455445,0.955472359,0.888564501,0.622027695,0.528852253
335,335,335,2.5,as many as you need,5,5,5,0.141086102,0.858913899,0.819971017,-0.013324797,0.110659259,0.988961569,0.873791717,0.999786012,0.74768354,0.981931032,0.951772489,0.955472359,0.888564501,0.284365118,0.107951275
336,336,336,2.5,"As many as are needed, depending on how many variables one wishes to directly modify or leave as default when instantiating an object.",5,5,5,0.085764945,0.914235055,0.890562036,0.10669332,0.215992714,0.983772505,0.81446237,0.999905356,0.888404523,0.893184139,0.714899983,0.948248132,0.87048505,0.527618289,0.411169649
337,337,337,2.5,"A very large amount of constructors can be created for any given class through overloading.  When two constructors with a different type or number of parameters are created, they are said to be overloaded, and C++ can recognize which constructor to use based on the type of the variables that are passed/returned.",5,5,5,0.073874414,0.926125586,0.905734616,0.306493908,0.391346957,0.981886252,0.792895834,0.999906944,0.890276876,0.878325162,0.675240193,0.953597777,0.883873146,0.569523573,0.463405153
338,338,338,2.5,It depends on the number of objects. Each object should have a constructor.,1,4,2.5,0.064056635,0.935943365,0.918262319,0.332608879,0.414266664,0.992640413,0.915853903,0.999947426,0.938009047,0.918161636,0.781566906,0.945145375,0.862720047,0.569990337,0.463986981
339,339,339,2.5,"Theoretically unlimited, as long as they are defined by the programmer.",5,5,5,0.068295896,0.931704104,0.912852928,0.326352447,0.40877573,0.987743428,0.859864061,0.999911596,0.89576207,0.939178927,0.837663725,0.94306496,0.857513571,0.711465001,0.640337066
340,340,340,2.5,As many as needed.,5,5,5,0.089787245,0.910212755,0.885429492,0.334955305,0.416325996,0.997512052,0.971553957,0.999876175,0.853996232,0.996933143,0.991814315,0.915362567,0.788185174,0.262461632,0.080648284
341,341,341,2.5,as many as wanted/needed,5,5,5,0.189521492,0.810478509,0.75816639,-0.021715378,0.103295297,0.990758743,0.894339762,0.999883104,0.862166789,0.982186909,0.952455445,0.955472359,0.888564501,0.382623672,0.230431895
342,342,342,2.5,several,4,5,4.5,0.300282598,0.699717403,0.616832771,0.011169421,0.132156518,0.980687516,0.779190042,0.999538282,0.455582439,0.982186909,0.952455445,0.861016481,0.652177897,0.382155716,0.229848581
343,343,343,2.5,One,0,0,0,0.250252783,0.749747217,0.68067192,0.084790774,0.196770025,0.980687516,0.779190042,0.999396654,0.288586706,0.981820016,0.951476179,0.89404694,0.734840387,0.402240932,0.254885075
344,344,344,2.5,one,0,0,0,0.160912514,0.839087486,0.794672077,0.313976198,0.397913761,0.962290641,0.568848738,0.999689145,0.633466664,0.982113953,0.95226072,0.919953975,0.799675696,0.402240932,0.254885075
345,345,345,2.5,There can be infinite constructors as long as the signature is different.,5,5,5,0.08054471,0.91945529,0.89722317,0.226350993,0.321009825,0.990676393,0.893398209,0.999889191,0.869343634,0.963497709,0.902572486,0.930602672,0.826325274,0.607539654,0.510792713
346,346,346,2.5,that depends on the number of data members in the class,0,3,1.5,0.109897018,0.890102983,0.859768978,0.224327788,0.319234167,0.989316254,0.87784702,0.999915992,0.900945106,0.95773175,0.887182683,0.953459569,0.883527265,0.666026115,0.58369688
347,347,347,2.5,one,0,0,0,0.160912514,0.839087486,0.794672077,0.313976198,0.397913761,0.962290641,0.568848738,0.999689145,0.633466664,0.982113953,0.95226072,0.919953975,0.799675696,0.402240932,0.254885075
348,348,348,2.5,you can overload constructors as you need,5,5,5,0.159198225,0.840801776,0.796859548,-0.039486442,0.087698589,0.989066607,0.874992674,0.999884855,0.864231612,0.993023806,0.981379984,0.955472373,0.888564536,0.405583858,0.259052078
349,349,349,2.5,As many as the programmer wants to create.,5,5,5,0.081389487,0.918610513,0.896145217,0.249689609,0.341492875,0.99535106,0.946846184,0.999909017,0.892720191,0.965561873,0.908081904,0.925290472,0.813030888,0.377490282,0.224033054
350,350,350,2.5,one,0,0,0,0.160912514,0.839087486,0.794672077,0.313976198,0.397913761,0.962290641,0.568848738,0.999689145,0.633466664,0.982113953,0.95226072,0.919953975,0.799675696,0.402240932,0.254885075
351,351,351,2.5,"as many as you want, as long as they each have a unique argument list",5,5,5,0.097762465,0.902237535,0.875252934,0.001706589,0.123851499,0.986853204,0.849685648,0.99979891,0.762892568,0.91458051,0.772008596,0.931026685,0.827386415,0.5582335,0.449331924
352,352,352,2.5,as many as the user decides to use.,5,5,5,0.078413427,0.921586573,0.899942735,0.235553503,0.329086374,0.992522787,0.914509025,0.999886013,0.865596233,0.965286141,0.907345953,0.941274022,0.853031544,0.33456862,0.170530621
353,353,353,2.6,A function definition does not require any additional information that needs to be passed inside its parenthesis  to execute. While a definition prototype requires more than one parameters to be passed in order to complete its  task.,5,3,4,0.029484749,0.970515251,0.962376809,0.465890974,0.531241199,0.985214423,0.830948594,0.999947535,0.938137302,0.967276204,0.912657589,0.982514731,0.956241121,0.798006773,0.748212557
354,354,354,2.6,"The FUNCTION PROTOTYPE is where the programmer declares that he/she is using a function other than main( ). This is like declaring a variable, the programmer knows that he/she will be using in the future, but has yet to say where they are going to use it, or how. This is answers the question who, it gives the function a name and character. The function prototype, by common practice is placed at the beginning of the program after the #includes and before main( ). The FUNCTION DEFINITION is the guts of the function. This is where the programmer decides what the function is going to do and tells it how to do it. It takes whatever information it is given and performs the operations. It works sort of like the brain, the brain takes in input and based upon that input performs in some way producing an output. The function defintion is placed outside of main( ) and any other functions. A function is its own entity and should be thought of as such.",1,4,2.5,0.013811111,0.986188889,0.982376717,0.591976523,0.641899713,0.984158739,0.818878391,0.999944279,0.934298923,0.91410561,0.770741051,0.971744955,0.929288528,0.877591729,0.847416283
355,355,355,2.6,"A function prototype tells the compiler the function name, return type and the number and type of parameters without revealing the implementations contained in the function definition.",5,5,5,0.006861389,0.993138611,0.991244716,0.823242128,0.844869111,0.993982036,0.931193395,0.999977244,0.973168282,0.975076465,0.933477105,0.986760039,0.966865488,0.903502464,0.879714366
356,356,356,2.6,Function prototype is a declaration.  Function definitions (w/multiple parameters) often require more than one piece of information. to perform their tasks.,3,3,3,0.020582318,0.979417682,0.973736507,0.636506677,0.680981436,0.990934844,0.896353224,0.999938885,0.927938255,0.95296015,0.874446904,0.979638315,0.949042562,0.824633718,0.781403404
357,357,357,2.6,"A function prototype is a declaration of a function that tells the compiler the function's name, its return type and the types of its parameters.",5,5,5,0.0078125,0.9921875,0.990031077,0.801448166,0.825741721,0.990140839,0.887274941,0.999976042,0.971751287,0.971643209,0.924313472,0.987598785,0.968964546,0.892864585,0.866454105
358,358,358,2.6,A prototype shows only return types and necessary parameters. The definition includes names for those parameters and defines what the object is actually capable of doing.,5,4,4.5,0.02443099,0.97556901,0.968825517,0.576794505,0.628575271,0.985551893,0.834807066,0.999947084,0.937606111,0.97388036,0.930284606,0.981240377,0.953051905,0.925836384,0.9075539
359,359,359,2.6,prototype only tells the user what data types go into a function and what type is returned.,5,4,4.5,0.025069177,0.974930823,0.968011176,0.523831606,0.582092579,0.986231199,0.842573937,0.999934675,0.922974666,0.957092331,0.885476023,0.980494689,0.951185735,0.833968997,0.793039957
360,360,360,2.6,Function prototype is located in the .h file and only contains the access function name and paramater type.  Function definition contains the code for the function to perform its activity.,4,5,4.5,0.011760056,0.988239944,0.984993909,0.786422014,0.812554075,0.985787564,0.837501624,0.999962088,0.955297896,0.964862188,0.906214389,0.947945699,0.869728177,0.867962778,0.835413665
361,361,361,2.6,"a function prototype is used to reference the compiler to a function that will be defined later on, a function definition is the actual function itself, complete with return type, parameters, etc...",4,4,4,0.010300636,0.989699364,0.986856161,0.709868789,0.745367421,0.989343895,0.878163047,0.999959814,0.952615584,0.968648872,0.916321349,0.970600362,0.926424054,0.877676666,0.847522158
362,362,362,2.6,A function prototype describes a class's public interface without revealing the class's member function implementations,5,4,4.5,0.02694577,0.97305423,0.965616602,0.509836614,0.569809927,0.984207702,0.819438212,0.999945208,0.935393633,0.944910675,0.852962216,0.979250669,0.948072433,0.775738478,0.720454826
363,363,363,2.6,"Function definitions are just that, the definition. The prototype is what the compiler uses to check that calls to function are correct.",1,3,2,0.022535741,0.977464259,0.971243896,0.61950326,0.666058451,0.986831735,0.849440179,0.999942792,0.93254516,0.931491592,0.817145617,0.974922881,0.93724165,0.806454718,0.758743035
364,364,364,2.6,a prototype does not include any actual code where the function has all the code that is executed in the program.,3,3,3,0.026004553,0.973995447,0.966817616,0.527533054,0.585341142,0.980388254,0.775768422,0.999945149,0.935324231,0.942553778,0.846671471,0.967612515,0.918946626,0.751856983,0.690686219
365,365,365,2.6,a prototype declares what will be used in the program and the definition,3,3,3,0.03254652,0.96745348,0.958469921,0.350554794,0.43001683,0.981917795,0.79325648,0.999900048,0.882144991,0.895658231,0.721503531,0.936956758,0.842227099,0.723571181,0.655427584
366,366,366,2.6,"A function prototype lays out the name, return type, and the number and types of parameters the function expects to receive in a certain order.  The details for function prototypes are in the function definition.",5,5,5,0.006419599,0.993580401,0.99180845,0.821689308,0.843506284,0.993121478,0.921354177,0.999962674,0.955988713,0.977154648,0.939023941,0.982174122,0.955388708,0.896468222,0.870946088
367,367,367,2.6,"A function definition is the code that defines the function placed in the {} brackets that determines that function's operation.  A function prototype shows the function's public interface without exposing implementation.  It shows name, return type and type of paramaters.",5,5,5,0.012998879,0.987001121,0.983413143,0.78739351,0.813406705,0.993526614,0.925986311,0.999977888,0.973927831,0.971780797,0.924680706,0.981908489,0.954723931,0.902683616,0.87869366
368,368,368,2.6,"A function prototype is just a declaration of the function existing, and cant be used as an actual function. A function has to be created with a definition within to tell the compiler what the function does.",3,4,3.5,0.013038099,0.986961901,0.983363098,0.706894636,0.742757167,0.992547608,0.914792819,0.999966623,0.960644181,0.950301105,0.867349702,0.976621773,0.941493321,0.850854754,0.814088282
369,369,369,2.6,the Prototype creates a framework to call the function definition. While a function definition is where the function is actually programmed out and created into a final product.,5,4,4.5,0.014851749,0.985148251,0.98104884,0.692086816,0.729761139,0.983063923,0.806360769,0.99996053,0.953460584,0.959910281,0.892997356,0.975044199,0.937545263,0.775334001,0.719950639
370,370,370,2.6,A function prototype describes the class's public interface without providing how the function works. A function definition contains the inner workings of the function.,5,4,4.5,0.008425295,0.991574705,0.989249137,0.74641794,0.777444648,0.986533498,0.84603028,0.999967114,0.961223352,0.949578305,0.865420491,0.985549905,0.96383699,0.83112061,0.789489404
371,371,371,2.6,"prototype states all functions in that class before compilation, where the definition actually holds the source for the functions",3,4,3.5,0.034649372,0.965350628,0.955786636,0.510337114,0.570249189,0.986905818,0.850287219,0.999939705,0.928905746,0.951504467,0.87056157,0.96500858,0.912429982,0.783161044,0.729707155
372,372,372,2.6,"Function prototypes tell the compiler the function names, its return type, and the types of its parameters where as, function definitions actually implement the member functions.",5,5,5,0.009308994,0.990691006,0.988121518,0.808318198,0.831771179,0.994205259,0.933745632,0.999958057,0.9505449,0.971818538,0.924781439,0.978294346,0.945679126,0.886704147,0.858775036
373,373,373,2.6,A function prototype just specifies parameters.  A function definition includes parameters and a code body.,4,4,4,0.023290873,0.976709127,0.970280332,0.74327451,0.774685828,0.983320055,0.809289263,0.99994939,0.940325307,0.945910601,0.855631098,0.979171227,0.947873621,0.888115287,0.860534041
374,374,374,2.6,Function prototypes describe the class's public interface,5,4,4.5,0.038992822,0.961007178,0.950244297,0.403732956,0.476688445,0.981955953,0.793692762,0.999934781,0.923098971,0.936316225,0.830022946,0.973308559,0.933201626,0.751322806,0.69002036
375,375,375,2.6,"A prototype only declares name, return type, and input type. A definition also defines the scope, variables, process, and return function ",4,5,4.5,0.013801217,0.986198783,0.982389342,0.659713149,0.70134851,0.992643622,0.915890601,0.999949158,0.940051437,0.965415637,0.907691588,0.986346923,0.965831618,0.910188258,0.888048298
376,376,376,2.6,"a function prototype simply declares the functions parameters, the function definition includes any necessary variables and the function's actual code",4,4,4,0.02283597,0.97716403,0.970860798,0.750900567,0.781378808,0.994291029,0.934726285,0.999964407,0.958031688,0.956451993,0.88376691,0.970253188,0.925555211,0.809191227,0.762154131
377,377,377,2.6,"A functgion prototype is a declaration of a function , while function definition specifies what a function does",3,4,3.5,0.026173532,0.973826468,0.966601995,0.65251869,0.69503432,0.988905901,0.873155236,0.999944461,0.93451286,0.853142857,0.608026621,0.966654322,0.916548639,0.735889912,0.670783048
378,378,378,2.6,"in a function prototype you include the return type, the name of the function, and its parameters if any are needed.  in a function definition you write the code of what the function will do. ",5,5,5,0.009563565,0.990436435,0.987796679,0.829985917,0.850787772,0.987039657,0.851817462,0.999952775,0.944316277,0.962848935,0.900840857,0.957506662,0.893655577,0.87295568,0.841637385
379,379,379,2.6,"A function definition contains all the code for a function to work. A function prototype just shows the output, input and function name.",5,4,4.5,0.015179694,0.984820306,0.980630376,0.768739224,0.797034839,0.987599955,0.858223656,0.999957254,0.949598074,0.94731316,0.859374639,0.986447457,0.966083216,0.870717406,0.838847347
380,380,380,2.6,"function prototype describe the class's public interface without revealing   the class's member function implementations,  function definitions show what   implementations are being done",5,4,4.5,0.0219239,0.9780761,0.97202462,0.574835479,0.626855939,0.990021123,0.885906168,0.999957608,0.950014804,0.958728087,0.889841986,0.974556744,0.936325351,0.771686733,0.715404271
381,381,381,2.6,"A function prototype only names the function, its return type, and it's argument list, while a definition defines the above as well as what the function actually does.",5,5,5,0.009856939,0.990143061,0.987422328,0.734493554,0.766979255,0.996358126,0.958360505,0.9999427,0.932436513,0.962608389,0.90019882,0.978783548,0.94690341,0.891695321,0.864996601
382,382,382,2.6,function prototype describes a classes interface without reviling whatever is inside as for the function definition can't do that.,5,4,4.5,0.022345245,0.977654755,0.971486974,0.584859312,0.635653318,0.982928651,0.804814138,0.999927538,0.914559184,0.950829073,0.86875889,0.973138832,0.932776864,0.744747698,0.681824399
383,383,383,2.7,the role of a header file list all the functions a class can do while hiding the inner workings of its functions,5,4,4.5,0.031030357,0.968969643,0.960404579,0.262692094,0.352904457,0.989576978,0.880828018,0.999889168,0.869317008,0.958609939,0.88952664,0.984525143,0.961272406,0.826182902,0.783334484
384,384,384,2.7,The main role of header file is it is used to share information among various files.,3,3,3,0.029328644,0.970671356,0.962576002,0.218579948,0.314189597,0.990792115,0.894721324,0.999923489,0.909785379,0.968719237,0.916509159,0.978998235,0.947440689,0.813278854,0.767249413
385,385,385,2.7,Header files separate files in which classes are defined and allow the compiler to recognize classes when used elsewhere.,4,3,3.5,0.026265621,0.973734379,0.966484487,0.368396163,0.445675241,0.98901977,0.874457158,0.999909881,0.893739003,0.948956563,0.863761012,0.952603699,0.881385353,0.809991896,0.763152176
386,386,386,2.7,No,0,0,0,0.333196342,0.666803658,0.574834106,-0.139411196,0,0.967485186,0.628240742,0.99961857,0.550251548,0.840583513,0.574504734,0.951370286,0.878298596,0.378861189,0.225741908
387,387,387,2.7,"A header file consists of ""reusable"" source code such as a class in a file that by convention has a .h filename extension. This differs from .cpp files that contain ""source-code.""",4,3,3.5,0.037103832,0.962896168,0.952654691,0.330561847,0.412470094,0.98607892,0.840832848,0.999894996,0.876189002,0.95677895,0.884639585,0.979832005,0.949527293,0.83046174,0.788668114
388,388,388,2.7,"To provide information about the contents of a library. It includes the definition of classes, declarations of functions, data types, and constants.",5,4,4.5,0.020987093,0.979012907,0.973220005,0.560619533,0.614379367,0.990118817,0.887023148,0.999905931,0.889082607,0.965727486,0.908523938,0.979643761,0.949056191,0.836227298,0.795854959
389,389,389,2.7,the header file shows the user what types go into and come out of a function but does not allow a user to manipulate the actual code for the function.,5,4,4.5,0.02914834,0.97085166,0.962806074,0.397609502,0.471314219,0.986601267,0.84680512,0.999863302,0.838817672,0.976991369,0.938588136,0.953558424,0.883774661,0.833171725,0.792046147
390,390,390,2.7,Header files declares the class member functions.,3,4,3.5,0.04773432,0.95226568,0.939089953,0.622358084,0.668563976,0.990640242,0.892984877,0.999917934,0.903235233,0.957307014,0.886049029,0.981188205,0.952921338,0.858932376,0.824157147
391,391,391,2.7,A header file allows for the separation of declaration and implementation into separate files.,5,3,4,0.028372765,0.971627235,0.963795726,0.292188734,0.378792074,0.988729156,0.87113441,0.999909936,0.893804844,0.951391075,0.870258918,0.985022949,0.962518222,0.768033981,0.710851066
392,392,392,2.7,the header file has access to the C++ Standard Library and makes certain classes like class string work.,0,3,1.5,0.024555027,0.975444973,0.968667242,0.355090737,0.433997783,0.988979647,0.873998414,0.99995256,0.944063331,0.974082725,0.930824734,0.983560685,0.95885874,0.835308254,0.794709358
393,393,393,2.7,â€œInstructâ€ the compiler on how to interface with library and user-written components.,2,3,2.5,0.035345972,0.964654028,0.954897759,0.394275785,0.468388394,0.988152493,0.864541122,0.999876257,0.854093582,0.930890159,0.815540345,0.980502323,0.95120484,0.790572345,0.738945442
394,394,394,2.7,create a comon area to contain reusable functions.,3,3,3,0.045133352,0.954866648,0.942408845,0.363975346,0.441795327,0.990668365,0.893306429,0.999760675,0.717808357,0.894380131,0.71809218,0.979603818,0.948956229,0.787251651,0.734806152
395,395,395,2.7,to declare the functions being used in the classes,3,3,3,0.039268911,0.960731089,0.949892002,0.263061822,0.353228948,0.991145845,0.898765711,0.999870366,0.847147447,0.917989844,0.78110838,0.9128761,0.781962507,0.77423501,0.718580733
396,396,396,2.7,"#include ""hat.h""  allows the use of the hat container, so called from the act of pulling names from a hat.  The header file for hat includes functions for storage and retrieval of it's contents, mainly put(), peek(), and pull().",0,3,1.5,0.033910036,0.966089964,0.956730045,0.313263029,0.397287851,0.983982243,0.816860413,0.999916504,0.901548643,0.950645478,0.868268861,0.974065079,0.935094903,0.801559448,0.752641015
397,397,397,2.7,To hold reusable content or modules separate from the actual  source-code file that can be easily referenced and employed for different programs.,5,3,4,0.028698325,0.971301675,0.963380303,0.285129279,0.37259637,0.988951986,0.873682149,0.999889431,0.869626826,0.942568828,0.84671164,0.975333696,0.938269762,0.820678651,0.776473361
398,398,398,2.7,a header file is a file used to store a list of prototye functions and data members.,5,5,5,0.024157584,0.975842416,0.96917439,0.607978284,0.655943599,0.991561898,0.90352267,0.999926779,0.913664259,0.973445951,0.929125134,0.961403925,0.903408922,0.87685734,0.846500858
399,399,399,2.7,"A header file is a cross communication method between source files, to help limit the size of each individual program. Without header files a program will be 1 large lump of code and thus fairly hard to debug and traverse.",3,4,3.5,0.021011174,0.978988826,0.973189278,0.368378818,0.445660018,0.986944999,0.85073519,0.999888202,0.86817757,0.9559774,0.882500184,0.979394045,0.948431248,0.816691279,0.771503048
400,400,400,2.7,It contains reusable source code for use by other classes.,3,3,3,0.046581864,0.953418136,0.940560512,0.36937201,0.446531689,0.986849974,0.849648722,0.999841476,0.813082583,0.940108337,0.840144394,0.954766786,0.886798725,0.783722878,0.730407488
401,401,401,2.7,"to separate the source code from the main function, allows the methods/classes to be included in the program without direct coding. allows re usability.",4,3,3.5,0.024969399,0.975030601,0.968138495,0.379819155,0.455700587,0.985501511,0.834231016,0.999896641,0.878128607,0.958178603,0.88837537,0.974482217,0.936138839,0.807561219,0.760122303
402,402,402,2.7,Header files have reusable source code in a file that a programer can use.,3,2,2.5,0.046396196,0.953603804,0.940797429,0.323960334,0.406676301,0.987580311,0.857999056,0.999921763,0.907749411,0.956793568,0.884678601,0.983363376,0.958364952,0.789195538,0.737229233
403,403,403,2.7,To hide the definition and details of a class.  Also to help readability of the main C++ file.,4,3,3.5,0.030532122,0.969467878,0.961040338,0.337548167,0.418601611,0.987937222,0.862079807,0.999919551,0.905141362,0.972670095,0.927054313,0.983600861,0.958959285,0.817466736,0.772469665
404,404,404,2.7,To allow the compiler to recognize the classes when used elsewhere.,3,4,3.5,0.034357727,0.965642273,0.956158782,0.243048519,0.335664347,0.988158833,0.8646136,0.999895732,0.877056733,0.927085194,0.805384591,0.982950225,0.957330994,0.799295187,0.749818583
405,405,405,2.7,"A header file declares a class, its data, and functions available through that class.",5,3,4,0.024864674,0.975135326,0.968272127,0.536098182,0.592858294,0.994222917,0.933947515,0.99995724,0.949581251,0.970378944,0.920939049,0.971427728,0.928494632,0.863244474,0.829532235
406,406,406,2.7,header files contain code which can be used in multiple files,3,3,3,0.054706097,0.945293903,0.930193812,0.242060781,0.334797462,0.987744883,0.859880688,0.99993177,0.919549285,0.955713563,0.881795982,0.977270556,0.943116975,0.752424181,0.691393238
407,407,407,2.7,Allow compiler to recognize the classes when used elsewhere,3,3,3,0.037541866,0.962458134,0.952095749,0.164161846,0.266429752,0.989198131,0.876496457,0.999882457,0.861403248,0.922394486,0.792864719,0.972106027,0.930192152,0.765453875,0.707634929
408,408,408,2.7,Allow compiler to recognize the classes when used elsewhere,3,4,3.5,0.037541866,0.962458134,0.952095749,0.164161846,0.266429752,0.989198131,0.876496457,0.999882457,0.861403248,0.922394486,0.792864719,0.972106027,0.930192152,0.765453875,0.707634929
409,409,409,2.7,To promote function reusuablitly,3,3,3,0.086152315,0.913847685,0.890067743,0.26314953,0.353305924,0.987546957,0.857617694,0.999786644,0.748429825,0.912044042,0.765238562,0.976788516,0.941910615,0.752665401,0.691693922
410,410,410,2.7,class definitions are placed here,3,3,3,0.074312747,0.925687254,0.905175294,0.238916501,0.332037897,0.988148857,0.864499544,0.999898531,0.880356987,0.903853983,0.743378644,0.938990463,0.847316677,0.709693134,0.63812841
411,411,411,2.7,A header file usually contains class and/or function prototypes.,4,5,4.5,0.03586477,0.96413523,0.954235761,0.586998701,0.637530946,0.988230053,0.865427896,0.999914663,0.899378416,0.964432363,0.905067152,0.988143231,0.970327084,0.838125348,0.798220905
412,412,412,2.7,contains all the standard C++ library's i.e. string,0,2,1,0.069138944,0.930861056,0.91177718,0.194901422,0.293408226,0.987429761,0.856277738,0.999878409,0.856630331,0.932293411,0.819285736,0.962233545,0.90548514,0.715926468,0.645898346
413,413,413,3.1,"It includes the name of the program, the type of parameters it can take. It should also include a brief description of what the function does.",4,5,4.5,0.01899761,0.98100239,0.97575863,0.643401921,0.687033022,0.992674335,0.916241752,0.999960757,0.953728123,0.944282604,0.851285844,0.977603272,0.943949635,0.806300819,0.758551198
414,414,414,3.1,it includes the specific information about the function such as input and output variable types and how many of each.,1,5,3,0.021496058,0.978503943,0.972570556,0.486246079,0.549105782,0.992696067,0.91649023,0.999870218,0.846971964,0.913618852,0.769441855,0.972445404,0.931041482,0.771226645,0.714830764
415,415,415,3.1,The function signature includes the name of the function and the types of its arguments.,5,5,5,0.006905079,0.993094921,0.991188967,0.789335191,0.815110814,0.995031795,0.94319585,0.999977962,0.974015198,0.987854538,0.967582797,0.989719794,0.974272612,0.913329363,0.891963728
416,416,416,3.1,"A function signature consists of the function prototype.  This tells you the general information about a function, its name, parameters, what scope it is in, and other miscellaneous information.",4,5,4.5,0.020933628,0.979066372,0.973288228,0.588463068,0.638816142,0.984996908,0.828461628,0.999946434,0.936839921,0.935518953,0.827894964,0.961874043,0.904585446,0.818026781,0.773167769
417,417,417,3.1,It includes the name of the function and the types of its arguments.,5,5,5,0.008537948,0.991462052,0.98910539,0.80158335,0.825860365,0.997424485,0.970552761,0.999973237,0.968443179,0.986642756,0.964348455,0.976918353,0.942235547,0.865373611,0.832186234
418,418,418,3.1,"Name, paramaters, scope, and other general function information",4,5,4.5,0.047376275,0.952623725,0.939546826,0.378903121,0.454896633,0.974340754,0.706624113,0.999872493,0.849654855,0.956575797,0.884097353,0.958607447,0.896410417,0.753423929,0.692639439
419,419,419,3.1,It includes a function name and parameter list. Does not include return type. Function signatures must be different.,5,5,5,0.038420379,0.961579621,0.950974747,0.545918703,0.601477238,0.9904017,0.890257499,0.999933613,0.92172205,0.923216439,0.795058577,0.978900387,0.947195813,0.856039107,0.820550648
420,420,420,3.1,input parameters and return type,1,5,3,0.0739066,0.9260934,0.905693545,0.366447926,0.443965377,0.98862562,0.869950632,0.999868032,0.84439467,0.978386303,0.942311326,0.960617086,0.901439767,0.763552248,0.705264526
421,421,421,3.1,The portion of the function prototyp tha has the function name and the arguments but NOT the return type.,5,5,5,0.014030397,0.985969603,0.982096904,0.701285482,0.737834313,0.993522126,0.925935003,0.999945374,0.935589997,0.96535116,0.907519494,0.982734899,0.956792116,0.795875072,0.745555364
422,422,422,3.1,Name of the function and the types of it's arguments,5,5,5,0.011446238,0.988553762,0.985394348,0.712529004,0.747702149,0.996885433,0.964389489,0.999980176,0.976625221,0.964688176,0.905749937,0.978149853,0.945317516,0.875992954,0.845423388
423,423,423,3.1,The name of the function and the types of its arguments.,5,5,5,0.004659057,0.995340943,0.994054941,0.869052053,0.885074021,0.999816296,0.99789961,0.999999208,0.999066054,1,1,1,1,0.936553776,0.920913274
424,424,424,3.1,Includes the name of the function and the types of its arguments.,5,5,5,0.006848454,0.993151546,0.991261221,0.804916918,0.828786059,0.997829994,0.975189165,0.99998637,0.983928978,0.994510073,0.985346949,0.978983779,0.947404511,0.864486754,0.831080754
425,425,425,3.1,"identification of a function and the data types of its parameters, it has the name, and the data type variables ",5,5,5,0.014718235,0.985281766,0.981219208,0.675348103,0.71507047,0.990600349,0.892528763,0.999962638,0.955945986,0.95255378,0.87336227,0.941827797,0.854417429,0.871882081,0.84029913
426,426,426,3.1,"a return type, and input parameters",1,5,3,0.040521264,0.959478736,0.948293972,0.379706502,0.455601718,0.985628516,0.835683136,0.999863108,0.83858909,0.985554697,0.961444339,0.975993809,0.93992177,0.763552308,0.7052646
427,427,427,3.1,The function signature includes the method name and the input types.,5,5,5,0.017068625,0.982931376,0.978220058,0.677948237,0.717352467,0.992593224,0.915314363,0.999898754,0.880619487,0.930325993,0.814034541,0.98023716,0.95054124,0.889232337,0.861926459
428,428,428,3.1,"A function signature includes the name of the function and types of arguments, but not the return type.  ",5,5,5,0.010849059,0.989150941,0.986156362,0.722115874,0.75611603,0.993546342,0.926211881,0.999948715,0.939529099,0.954459123,0.878447782,0.977570666,0.943868034,0.879413784,0.849687499
429,429,429,3.1,The signature can include a result type and thrown errors.,1,3,2,0.035810769,0.964189231,0.954304668,0.335174859,0.416518686,0.988677956,0.87054902,0.99991777,0.903041472,0.978904309,0.943693925,0.980521441,0.951252685,0.748028874,0.68591443
430,430,430,3.1,"function name, and input paramaters",5,5,5,0.061546981,0.938453019,0.921464692,0.411881506,0.483839991,0.98807906,0.863701512,0.9998885,0.868528393,0.964180115,0.904393882,0.96813126,0.920244845,0.742281675,0.678750468
431,431,431,3.1,"The name of the function and the types of its arguments. This includes the number, type, and order the parameters appear in.",5,5,5,0.008371234,0.991628766,0.989318121,0.835476935,0.855606944,0.995850953,0.952561724,0.999981854,0.978603893,0.948203446,0.861750883,0.98004087,0.950050001,0.912048757,0.890367436
432,432,432,3.1,the name of the function and the types of its arguments,5,5,5,0.007137418,0.992862582,0.990892497,0.77821517,0.805351369,0.995876702,0.952856133,0.999965644,0.959490102,0.969332832,0.918146893,0.96813126,0.920244845,0.875992954,0.845423388
433,433,433,3.1,A function signature includes the name of the function and the types of its arguments,5,5,5,0.01095742,0.98904258,0.98601809,0.699041843,0.735865193,0.99499417,0.942765669,0.999975365,0.970952481,0.986701103,0.964504188,0.97962265,0.949003358,0.88028121,0.850768758
434,434,434,3.1,"A function signature includes a function's return type, parameters and semi-colon.",1,5,3,0.039509118,0.960490882,0.949585493,0.553337157,0.607988016,0.986941071,0.850690284,0.999890269,0.870615222,0.976655965,0.937692916,0.976853908,0.942074266,0.805281162,0.757280182
435,435,435,3.1,the name of the function and the types of its arguments,5,5,5,0.007137418,0.992862582,0.990892497,0.77821517,0.805351369,0.995876702,0.952856133,0.999965644,0.959490102,0.969332832,0.918146893,0.96813126,0.920244845,0.875992954,0.845423388
436,436,436,3.1,the function's name and parameters,5,5,5,0.040439963,0.959560037,0.948397713,0.708061814,0.743781537,0.992319965,0.912190048,0.999927348,0.914334632,0.963748732,0.903242486,0.968629014,0.921490531,0.855582833,0.819981897
437,437,437,3.1,The name of the function and the types of its arguments.,5,5,5,0.004659057,0.995340943,0.994054941,0.869052053,0.885074021,0.999816296,0.99789961,0.999999208,0.999066054,1,1,1,1,0.936553776,0.920913274
438,438,438,3.1,The portion of a function prototype that includes the name of the function and the types of its arguments,5,5,5,0.012877941,0.987122059,0.983567463,0.734061241,0.766599837,0.994004004,0.93144457,0.999918199,0.903546941,0.966402903,0.91032668,0.981761107,0.954355091,0.874678731,0.843785192
439,439,439,3.1,the name of the function and its parameters,5,5,5,0.011551976,0.988448024,0.985259423,0.788803339,0.814644036,0.994758367,0.940069612,0.999970115,0.964762477,0.914538045,0.771895254,0.967262321,0.918070226,0.872647643,0.841253413
440,440,440,3.1,The function name and parameters,5,5,5,0.035282254,0.964717746,0.954979064,0.731443286,0.764302198,0.991533474,0.903197682,0.999930458,0.918001694,0.971768971,0.924649141,0.988819091,0.9720185,0.939433217,0.924502536
441,441,441,3.1,name of function and types of arguments,5,5,5,0.023866653,0.976133347,0.969545623,0.638701201,0.682907452,0.994158543,0.933211497,0.999936018,0.924557631,0.969332832,0.918146893,0.96813126,0.920244845,0.875992954,0.845423388
442,442,442,3.1,a function's return type and parameter list,1,5,3,0.050414979,0.949585021,0.935669372,0.44227007,0.510510401,0.990880387,0.89573059,0.999847119,0.819736264,0.977743676,0.940596103,0.961632491,0.903980934,0.818610609,0.773895518
443,443,443,3.1,"it includes the name of the function, and the types of its arguments. it does not specify the function return type. Function in the same scope must have unqiue signatures. ",5,5,5,0.016627193,0.983372808,0.978783335,0.709471524,0.745018763,0.994683026,0.939208196,0.99996614,0.960074689,0.940318753,0.840706011,0.977437401,0.943534523,0.879525304,0.84982651
444,444,444,3.2,Any functions that follows their deceleration that  are in the source code file are allowed to have access the variables.  Also global scope variables retrain their value throughout the execution of the program.,5,5,5,0.081524193,0.918475807,0.895973328,0.458820283,0.525035634,0.985560936,0.834910459,0.999809045,0.774842846,0.829510995,0.544951304,0.845746215,0.613962315,0.67428267,0.593988787
445,445,445,3.2,they can be accessed by any C++ file anywhere.,0,5,2.5,0.079806566,0.920193434,0.898165058,0.382321835,0.457897055,0.987214904,0.853821159,0.999788767,0.750932973,0.955356952,0.880844159,0.875959451,0.689574383,0.740487993,0.676514619
446,446,446,3.2,Global variables have file scope.,5,5,5,0.038891792,0.961108208,0.950373214,0.698891282,0.735733053,0.99641221,0.958978873,0.999902578,0.885128231,0.980179568,0.947097693,0.846601411,0.616102541,0.804483354,0.756285703
447,447,447,3.2,The scope of global variables are created by placing variable declarations outside any class or function definition.  Global variables retain their values throughout the execution of the program and they can be referenced by any function that follows their declarations or definitions in the source file.,0,5,2.5,0.087686062,0.912313938,0.888110648,0.355263472,0.434149383,0.985925092,0.839074052,0.999819076,0.786669855,0.679385129,0.144253443,0.873274899,0.682855986,0.673891127,0.593500723
448,448,448,3.2,A global variable is an identifier that retains it's value throughout the execution of the program. It has file scope.,5,5,5,0.071632564,0.928367436,0.908595266,0.552965045,0.607661434,0.990445652,0.890760025,0.999858464,0.83311262,0.873109008,0.661317864,0.876328635,0.690498308,0.72717762,0.659923058
449,449,449,3.2,Global Variables can be used in any function as long as the appropriate .h file that holds the variable is included,3,5,4,0.100310683,0.899689317,0.872001352,0.202395886,0.299985715,0.992106622,0.909750788,0.999775988,0.735864369,0.894714864,0.718985609,0.880430976,0.700764884,0.632871628,0.542369362
450,450,450,3.2,They can be accessed by any part of the program. It can be referenced by any function that follows the declarations or definitions in the source file.,5,5,5,0.084822297,0.915177703,0.891764875,0.365065157,0.442751796,0.986549783,0.846216476,0.999814935,0.781787286,0.865833958,0.641900177,0.879720972,0.698988018,0.695770144,0.620773215
451,451,451,3.2,can be accesed by any classes that have and object of that variables class in it,1,5,3,0.126021862,0.873978138,0.83919332,0.011383295,0.132344225,0.989280494,0.87743816,0.999811137,0.777309019,0.910027816,0.759857094,0.858824584,0.646692425,0.491874546,0.366614589
452,452,452,3.2,Global variables have file-scope.  The variable is know to all functions throught the file,5,5,5,0.070718825,0.929281175,0.909761217,0.431208491,0.500802247,0.994638717,0.938701585,0.999835174,0.805652145,0.907532972,0.753198158,0.881181713,0.702643689,0.684551001,0.6067884
453,453,453,3.2,The entire program,4,5,4.5,0.200951219,0.799048781,0.743581805,0.029133383,0.147922523,0.98962137,0.881335577,0.999849068,0.822033976,0.943760943,0.84989349,0.78777098,0.46887268,0.59453696,0.494584679
454,454,454,3.2,They have file scope when placed outside a function.,5,5,5,0.058551192,0.941448808,0.925287385,0.621511221,0.66782073,0.994290884,0.934724626,0.999864844,0.840635821,0.913477536,0.769064671,0.873304946,0.682931182,0.69148922,0.615436984
455,455,455,3.2,File scope.,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
456,456,456,3.2,They can be used throughout the program,4,5,4.5,0.139913082,0.860086918,0.821467816,0.027359378,0.146365574,0.992728886,0.916865466,0.999841869,0.813545194,0.909587393,0.758681571,0.854309804,0.635393673,0.539520204,0.426005547
457,457,457,3.2,Global variable can b accessed by any class wit an object in the variables class,1,5,3,0.120407701,0.8795923,0.846357114,0.061449446,0.176284596,0.991488622,0.902684865,0.999837569,0.808475742,0.836182094,0.562756997,0.869754548,0.674045906,0.5748142,0.469999992
458,458,458,3.2,The scope of global variables is at the file level.,5,5,5,0.067862272,0.932137728,0.913406241,0.626681924,0.672358779,0.994497637,0.937088542,0.999886846,0.866578822,0.932212303,0.819069252,0.860929155,0.651959354,0.782126129,0.728417119
459,459,459,3.2,Global variables all have file scope.,5,5,5,0.04763478,0.95236522,0.939216968,0.673982978,0.713872373,0.995677092,0.950573876,0.999887374,0.867201662,0.980179568,0.947097693,0.846601411,0.616102541,0.804483354,0.756285703
460,460,460,3.2,it is accessible by all functions within a program,4,5,4.5,0.129132986,0.870867014,0.835223457,0.025152721,0.14442891,0.991183802,0.899199695,0.99984604,0.81846403,0.919209534,0.784363829,0.858894348,0.646867017,0.56808871,0.461616577
461,461,461,3.2,"variables accessible anywhere in the program, as long as they are public.",4,5,4.5,0.1009565,0.8990435,0.871177276,0.208115757,0.305005738,0.990504545,0.891433384,0.999818495,0.785985742,0.906033834,0.749196839,0.868998259,0.672153207,0.543712139,0.431230851
462,462,462,3.2,They can be referenced by any function following their declaration or definition inside the source file.,5,5,5,0.08427465,0.91572535,0.892463685,0.380069286,0.455920113,0.993307134,0.923476878,0.999843467,0.815429381,0.886847121,0.697985978,0.876009747,0.689700255,0.690946579,0.614760575
463,463,463,3.2,"globally, anywhere in the program.",4,5,4.5,0.094288766,0.905711234,0.879685451,0.203641489,0.301078914,0.988788551,0.871813512,0.999865351,0.841234075,0.947295077,0.859326374,0.853346707,0.632983413,0.465965956,0.334319181
464,464,464,3.2,Global variables have a file scope,5,5,5,0.078471363,0.921528637,0.899868808,0.512834191,0.572440739,0.996881339,0.964342677,0.999866405,0.842476044,0.980179568,0.947097693,0.846601411,0.616102541,0.804483354,0.756285703
465,465,465,3.2,The entire program.,4,5,4.5,0.102432013,0.897567987,0.869294489,0.282318056,0.37012911,0.990039165,0.886112441,0.999876172,0.853993021,0.943760943,0.84989349,0.78777098,0.46887268,0.59453696,0.494584679
466,466,466,3.2,throughout the execution of the program,4,5,4.5,0.140018821,0.859981179,0.821332891,0.066064745,0.180335196,0.982888582,0.804356003,0.999817449,0.784751591,0.947295077,0.859326374,0.853346707,0.632983413,0.559961975,0.451486491
467,467,467,3.2,"If a variable is declared global, any function or class can use that variable.",4,5,4.5,0.093988657,0.906011343,0.880068397,0.178546369,0.279054275,0.990592069,0.892434096,0.999875366,0.853042297,0.832417925,0.552710131,0.86997908,0.674607823,0.553465188,0.443388158
468,468,468,3.2,The entire program or file.,5,5,5,0.06195426,0.93804574,0.920944996,0.468988478,0.533959712,0.991393873,0.901601542,0.999904876,0.887838642,0.923164289,0.794919384,0.859512859,0.648414912,0.790652096,0.739044853
469,469,469,3.2,throught the programm,4,5,4.5,0.178258836,0.821741164,0.772537787,0.04491974,0.161777361,0.992278135,0.91171179,0.999648607,0.585667921,0.99900796,0.997352166,0.866512852,0.665933192,0.599785566,0.501127138
470,470,470,3.2,the whole code,4,5,4.5,0.164410412,0.835589588,0.790208682,0.084451057,0.196471874,0.978511382,0.754309141,0.999801924,0.766445858,0.978932197,0.94376836,0.856256649,0.640265875,0.49168399,0.366377058
471,471,471,3.2,File scope,5,5,5,0.057141781,0.942858219,0.927085825,0.834967732,0.855160044,0.997979979,0.976904023,0.999946512,0.93693135,1,1,1,1,1,0.999999851
472,472,472,3.2,can be referenced by any function that follows their declarations or definitions in the source file,5,5,5,0.109715164,0.890284836,0.860001027,0.235076517,0.328667749,0.990961385,0.896656677,0.999829656,0.799145559,0.921126855,0.789481311,0.875283736,0.687883329,0.670919299,0.589796299
473,473,473,3.2,global variables have program scope (accessible anywhere in program),4,5,4.5,0.132981598,0.867018402,0.830312543,0.232276902,0.326210677,0.991944424,0.907896286,0.999890452,0.87083068,0.917817049,0.780647176,0.836268539,0.590243351,0.577623665,0.473502028
474,474,474,3.2,variables that exist throught the entire script. their values can be changed anytime in the code and fucntions.,4,5,4.5,0.091394782,0.908605218,0.883378239,0.297587723,0.383530476,0.986386776,0.844352732,0.99982029,0.788102112,0.903770607,0.743156107,0.869971095,0.67458784,0.550199449,0.439317371
475,475,475,3.3,It expands the function's definition in that place.  Once the functions is called you can use it as many times as you need.  The compiler just expands on the function.,4,5,4.5,0.014797688,0.985202313,0.981117824,0.552332461,0.607106249,0.994903062,0.94172398,0.999966494,0.960493115,0.947474618,0.859805583,0.967385154,0.918377629,0.878345609,0.848356005
476,476,476,3.3,"When the compiler inline-expands a function call, the function's code gets inserted into the caller's code stream (conceptually similar to what happens with a #define macro). This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code â€” optimize the called code into the caller.   ",4,5,4.5,0.015824616,0.984175384,0.97980744,0.505520463,0.566021873,0.980612346,0.778330583,0.999946524,0.936946116,0.957026981,0.885301599,0.960338325,0.900742136,0.875074565,0.844278605
477,477,477,3.3,The inline keyword advises the compiler to copy the function's code in place to avoid function calls; however the compiler can and typically does ignore the inline qualifier for all but the smallest functions.,5,5,5,0.018454075,0.981545925,0.976452193,0.559001386,0.612959206,0.992854939,0.918306696,0.999948864,0.939705329,0.964902172,0.906321109,0.969360771,0.923321836,0.850696206,0.81389065
478,478,478,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2,4,3,0.030153871,0.969846129,0.961522995,0.28576076,0.373150587,0.993039418,0.920415937,0.999943161,0.932979965,0.909050265,0.757247933,0.949779032,0.874316301,0.64074707,0.552186207
479,479,479,3.3,"Placing the qualifier inline before a function's return type in the function definition ""advises"" the compiler to generate a copy of the function's code in place to avoid a function call.",5,5,5,0.01437664,0.98562336,0.981655089,0.63756609,0.681911226,0.995381393,0.947192996,0.999957926,0.950389593,0.977967548,0.941193636,0.960848466,0.902018822,0.880339444,0.850841347
480,480,480,3.3,You declare your inline function in the header or before your int main(). You then can call that function at anytime in your main program quickly and easily.,0,4,2,0.022342324,0.977657676,0.971490701,0.348192394,0.427943478,0.990367176,0.889862772,0.999963654,0.957144499,0.960724764,0.895171276,0.952263997,0.88053521,0.876869678,0.846516237
481,481,481,3.3,"It expands a small function out... making your code longer, but also makes it run faster.",4,4,4,0.022797167,0.977202833,0.970910311,0.492820472,0.554875773,0.991940167,0.907847622,0.999951006,0.942230655,0.976345705,0.936864808,0.971775173,0.929364152,0.839157879,0.799507969
482,482,482,3.3,the function is not treated as a separate unit like other functions,4,3,3.5,0.027112126,0.972887874,0.965404328,0.389756918,0.464422428,0.991395953,0.901625332,0.99996113,0.954168071,0.908139883,0.754818051,0.949805027,0.874381357,0.782934964,0.729425343
483,483,483,3.3,"When the program compiles,it will copy the function inplace, avoiding a function call.",5,5,5,0.014291167,0.985708833,0.981764155,0.64461726,0.688099659,0.988582748,0.869460453,0.99996367,0.957162878,0.964428349,0.905056438,0.956968441,0.892308617,0.886044145,0.857952334
484,484,484,3.3,"It replaces all instances of that function call with the inline code itself, resulting in longer but faster programs.",5,5,5,0.023101151,0.976898849,0.970522421,0.447093427,0.514743602,0.993061405,0.920667327,0.999936237,0.924816316,0.954455909,0.878439204,0.972359888,0.930827468,0.864175856,0.830693216
485,485,485,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2,4,3,0.030153871,0.969846129,0.961522995,0.28576076,0.373150587,0.993039418,0.920415937,0.999943161,0.932979965,0.909050265,0.757247933,0.949779032,0.874316301,0.64074707,0.552186207
486,486,486,3.3,Ignores the inline qualifier and typically does so for all but the smallest functions.,2,4,3,0.037263513,0.962736487,0.952450935,0.239709944,0.332734259,0.994764591,0.940140769,0.999939917,0.929155599,0.888573016,0.702592529,0.957582398,0.893845115,0.416125625,0.272192533
487,487,487,3.3,If the function is small enough it will expand it but it will run faster as it will avoid making so many calls to the function.,5,4,4.5,0.026883066,0.973116934,0.965696614,0.465298712,0.530721403,0.991789053,0.906119851,0.999965117,0.958868396,0.965897175,0.908976851,0.967942615,0.919772739,0.828295708,0.785968125
488,488,488,3.3,it treats them as the same function,2,2,2,0.044492066,0.955507934,0.943227141,0.406395495,0.479025213,0.98963945,0.881542286,0.999949074,0.939952026,0.818547195,0.515688051,0.963175068,0.907841409,0.69270581,0.61695348
489,489,489,3.3,"Inline functions are copied in place, instead of being referenced.",5,5,5,0.027439177,0.972560823,0.964987004,0.420891762,0.491747808,0.988402753,0.867402478,0.999921601,0.907558269,0.899174904,0.73088981,0.964490353,0.91113306,0.727612138,0.660464691
490,490,490,3.3,"For inline functions, the compiler creates a copy of the function's code in place so it doesn't have to make a function call and add to the function call stack.",5,5,5,0.00985837,0.99014163,0.987420502,0.760858774,0.790118592,0.990187453,0.887807901,0.999970838,0.965614721,0.981072076,0.949479867,0.968374868,0.920854501,0.931582928,0.914717044
491,491,491,3.3,it generates a copy of the function's coding which eliminates calling the function,5,5,5,0.020261347,0.979738653,0.974146073,0.652332902,0.694871264,0.996336505,0.958113303,0.999951135,0.942382379,0.910317183,0.760629438,0.960722581,0.901703781,0.780635238,0.726558703
492,492,492,3.3,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
493,493,493,3.3,It generates a copy of the function's code by by inserting it in the program.,4,5,4.5,0.019503832,0.980496168,0.97511268,0.606202006,0.654384655,0.998124641,0.978558022,0.999966745,0.960788605,0.932726529,0.820441762,0.969042323,0.922524884,0.860763431,0.826439581
494,494,494,3.3,"tells the compiler to make a copy of function's code in place to avoid a function call.  it typically ignores it, except for the smallest functions.",5,5,5,0.008906424,0.991093576,0.988635206,0.731961608,0.764757102,0.996592056,0.961035159,0.99997235,0.967397328,0.972462039,0.926498995,0.973549583,0.933804816,0.860408604,0.825997285
495,495,495,3.3,The compiler can ignore the inline qualifier and typically does so for all but the smallest functions.,2,2,2,0.030153871,0.969846129,0.961522995,0.28576076,0.373150587,0.993039418,0.920415937,0.999943161,0.932979965,0.909050265,0.757247933,0.949779032,0.874316301,0.64074707,0.552186207
496,496,496,3.3,"Multiple copies of the function code are inserted into the program, making it bigger.",4,5,4.5,0.017227829,0.982772172,0.97801691,0.591700375,0.641657352,0.992887534,0.918679368,0.999954439,0.946278963,0.965655646,0.908332191,0.967800963,0.919418239,0.873761594,0.842641968
497,497,497,3.3,compiler ignores inline qualifier,2,3,2.5,0.151166439,0.848833561,0.807108284,0.05365755,0.169446068,0.986641082,0.847260351,0.999704627,0.651721968,0.793067614,0.447681025,0.957582388,0.89384509,0.265484542,0.084416381
498,498,498,3.3,"It generates a copy of the function, if it is needed again.",2,5,3.5,0.016902089,0.983097911,0.978432561,0.539953172,0.596241612,0.995121998,0.944227195,0.999973096,0.968276758,0.931796343,0.817959022,0.973265566,0.933094031,0.885427356,0.857183498
499,499,499,3.3,"The complier includes copies of inline functions instead of making function calls, but usually only with very small functions.",5,5,5,0.035654724,0.964345276,0.954503785,0.554109514,0.608665873,0.986997044,0.851330254,0.999942219,0.931870068,0.962430036,0.899722782,0.966913455,0.917197149,0.886352241,0.85833638
500,500,500,3.3,Compiler generate a copy of the function's code in place (when appropriate) to avoid a function call,5,5,5,0.01580143,0.98419857,0.979837027,0.688706994,0.726794851,0.996030194,0.954611087,0.999960795,0.953773227,0.96978844,0.919362947,0.976141333,0.940290966,0.88134402,0.852093565
501,501,501,3.3,"instead of calling the function every time it is invoked, the compiler will replace the function call with a copy of the function body",5,5,5,0.012714803,0.987285197,0.98377563,0.635743022,0.680311218,0.992408677,0.913204349,0.999978586,0.974750809,0.977220024,0.939198435,0.971696914,0.9291683,0.920066476,0.900361631
502,502,502,3.3,Expands the function into the program,4,4,4,0.037917018,0.962082982,0.951617048,0.287935346,0.375059104,0.993024992,0.920250998,0.999947666,0.93829255,0.900547957,0.734554598,0.954550898,0.88625844,0.745937228,0.683307164
503,503,503,3.3,it generates a copy of the functions code in place to avoid a function call,5,5,5,0.010987878,0.989012122,0.985979225,0.758969307,0.788460308,0.997012415,0.965841343,0.999964376,0.95799573,0.968873151,0.916919968,0.966903957,0.917173379,0.892662227,0.866201863
504,504,504,3.3,the function call will be replaced by the code that was defined in the inline function,5,5,5,0.022184014,0.977815986,0.971692708,0.575510085,0.627448004,0.99166751,0.904730188,0.999969441,0.963967407,0.959911134,0.892999632,0.946849603,0.866985071,0.857139051,0.821921743
505,505,505,3.3,"When the compiler inline-expands a function call, the function's code gets inserted into the caller's code stream (conceptually similar to what happens with a #define macro). This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code â€” optimize the called code into the caller. ",4,5,4.5,0.015824616,0.984175384,0.97980744,0.505520463,0.566021873,0.980612346,0.778330583,0.999946524,0.936946116,0.957026981,0.885301599,0.960338325,0.900742136,0.875074565,0.844278605
506,506,506,3.4,Overall the program has better performance (means it is faster) because it does not have to copy large amounts of data.,5,5,5,0.034116983,0.965883017,0.956465975,0.409939796,0.482135856,0.981182845,0.784853405,0.999965913,0.959807482,0.979891035,0.946327575,0.982039808,0.955052572,0.842460394,0.803624598
507,507,507,3.4,because you can't change the original and passing by reference limits memory needed for the program.,5,4,4.5,0.038698375,0.961301625,0.950620018,0.267508268,0.357131355,0.989932701,0.88489519,0.999948638,0.939438374,0.971653582,0.924341159,0.939512692,0.848623615,0.804827929,0.75671522
508,508,508,3.4,Passing by reference can eliminate the pass-by-value overhead of copying large amounts of data.,5,5,5,0.029963493,0.970036507,0.961765921,0.416990131,0.488323556,0.992724088,0.916810605,0.999984158,0.981320289,0.981628541,0.950965117,0.983612709,0.958988936,0.833246648,0.792139539
509,509,509,3.4,"It is often more efficient to pass references, rather than large objects, to functions. This allows the compiler to pass the address of the object while maintaining the syntax that would have been used to access the object.",5,5,5,0.028101444,0.971898556,0.964141936,0.421205103,0.492022811,0.986302493,0.843389079,0.999957859,0.950311014,0.9160142,0.775835229,0.978734232,0.946779991,0.88176626,0.852619892
510,510,510,3.4,"Pass by reference is good for performance reasons, because it can eliminate the pass by value overhead of copying large amounts of data.",5,5,5,0.033962011,0.966037989,0.956663723,0.414191842,0.485867648,0.9858224,0.837899916,0.99998277,0.979683277,0.97299415,0.927919241,0.98111741,0.952744166,0.853963494,0.817963369
511,511,511,3.4,You do not alter the original value of the variable that was passed.,3,3,3,0.042257607,0.957742393,0.94607836,0.115251549,0.223503811,0.98954741,0.880489951,0.99994748,0.938073349,0.956235977,0.883190346,0.974021259,0.934985239,0.729691327,0.663056428
512,512,512,3.4,Don't have to make copies of stuff.,4,5,4.5,0.051456749,0.948543251,0.934340051,0.464346767,0.529885931,0.996606279,0.961197769,0.999978064,0.974134356,0.954724501,0.879156097,0.969599993,0.923920516,0.808534503,0.761335515
513,513,513,3.4,you do not use unessesary memory space to copy variables between functions,5,5,5,0.043608665,0.956391335,0.944354379,0.305007726,0.390042615,0.987553923,0.85769735,0.999980097,0.976531814,0.974300334,0.93140555,0.979186537,0.947911936,0.817838013,0.772932467
514,514,514,3.4,It elimitates the need to copy large amonts of data,5,5,5,0.040432811,0.959567189,0.94840684,0.492820293,0.554875616,0.988769256,0.871592893,0.999980769,0.977324606,0.985718911,0.961882639,0.98531242,0.963242656,0.834559202,0.793775656
515,515,515,3.4,The function can change the data stored in a variable passed by reference directly.,3,4,3.5,0.037085652,0.962914348,0.952677888,0.342627555,0.423059518,0.995027503,0.943146783,0.999973817,0.96912728,0.979506265,0.945300593,0.979310001,0.948220918,0.791080952,0.739579427
516,516,516,3.4,Gives called function the ability to access and modify the callerâ€™s argument data.,3,4,3.5,0.031040013,0.968959987,0.960392258,0.514252842,0.573685812,0.995016556,0.943021616,0.999967573,0.961764528,0.966805837,0.911402142,0.979895736,0.949686787,0.839128435,0.799471266
517,517,517,3.4,Gives called function the ability to access and modify the callerâ€™s argument data directly.,3,4,3.5,0.029060721,0.970939279,0.962917877,0.494198531,0.556085221,0.994872241,0.941371591,0.999978432,0.974568988,0.967625607,0.913590174,0.978686733,0.946661119,0.833916903,0.79297502
518,518,518,3.4,It is more efficient and it changes the variable not online inside the function but outside so that the new value can be used elsewhere.,3,3,3,0.0325073,0.9674927,0.958519967,0.203985527,0.301380857,0.990797237,0.894779885,0.999906703,0.889992072,0.959941298,0.893080143,0.97688061,0.942141091,0.778289855,0.723635151
519,519,519,3.4,you don't make another copy and waste memory,5,5,5,0.064346075,0.935653925,0.917892987,0.205139384,0.302393535,0.987612318,0.858365005,0.999967421,0.961585298,0.971540795,0.924040121,0.979763736,0.949356442,0.794773936,0.744182783
520,520,520,3.4,"Passing by reference eliminates the copying of large amounts of data, typical with pass by value.",5,5,5,0.032442212,0.967557788,0.958603021,0.450163186,0.517437764,0.993478036,0.925430893,0.999978955,0.975185387,0.984625946,0.958965429,0.976875473,0.942128235,0.851156294,0.814464156
521,521,521,3.4,"If a function's arguments are large in size, computing time and memory space is not wasted copying down the argument and passing it to the function.  Also pass by reference gives the function called the permission to read edit the argument directly.",5,5,5,0.025836766,0.974163234,0.967031716,0.482983857,0.546242705,0.989386782,0.878653402,0.999979603,0.975950106,0.952791765,0.873997471,0.980134489,0.950284294,0.868529022,0.836119496
522,522,522,3.4,"Gives access to the caller data directly, also it allows for modifying the data.",3,4,3.5,0.028258383,0.971741617,0.963941679,0.425645381,0.495919804,0.989271171,0.877331564,0.999977995,0.974053053,0.973389839,0.928975367,0.953421147,0.88343111,0.81738627,0.772369362
523,523,523,3.4,"less overhead overall, and you modify the variable directly.",4,3,3.5,0.038565457,0.961434543,0.950789625,0.103882693,0.213525977,0.991232778,0.89975966,0.999992222,0.990829205,0.953047333,0.874679602,0.971355728,0.928314443,0.643065572,0.555076251
524,524,524,3.4,The original variable being referenced can be modified directly by the called function.,3,3,3,0.039190292,0.960809708,0.949992321,0.311798424,0.396002445,0.99735562,0.969765387,0.999974676,0.970140287,0.97011574,0.920236536,0.980593978,0.951434217,0.716910422,0.647124857
525,525,525,3.4,gives function ability to access and modify the caller's argument data directly,3,4,3.5,0.037176847,0.962823153,0.952561521,0.369205624,0.446385661,0.996253504,0.957164306,0.999976853,0.972706503,0.973974313,0.930535374,0.952286444,0.880591386,0.80963093,0.762702227
526,526,526,3.4,Gives the called function the ability to access and modify the caller's argument data directly.,3,3,3,0.029477477,0.970522523,0.962386088,0.452417702,0.519416432,0.992989589,0.919846225,0.999957584,0.949987175,0.97215325,0.925674812,0.973966729,0.934848771,0.824983358,0.781839237
527,527,527,3.4,"Less overhead than passed by value, especially when using large numbers.",4,3,3.5,0.033846378,0.966153622,0.956811274,0.314480394,0.398356267,0.990917005,0.896149264,0.999983385,0.980409516,0.974269586,0.931323481,0.979858873,0.949594533,0.78419745,0.730999049
528,528,528,3.4,"large data items can be passed without copying the entire data point, reducing execution time and the amout of memory space needed ",5,5,5,0.030746281,0.969253719,0.960767066,0.389613122,0.464296226,0.994087341,0.932397405,0.99998354,0.980591963,0.962075541,0.898776607,0.977968278,0.944863104,0.873756409,0.842635505
529,529,529,3.4,The data can be modified directly instead of making a copy of the data. Improves execution time with large amounts of data.,4,4,4,0.02283293,0.97716707,0.970864677,0.536688209,0.593376129,0.995779126,0.951740491,0.999976964,0.972838039,0.954436928,0.878388542,0.987759357,0.969366395,0.874592841,0.843678128
530,530,530,3.4,Functions can directly modify arguments that are passed by reference.,3,4,3.5,0.047380328,0.952619672,0.939541654,0.404003173,0.476925601,0.99395126,0.93084152,0.99997796,0.974011776,0.921337529,0.790043617,0.974454598,0.936069719,0.652706623,0.567093952
531,531,531,3.4,It gives access and modify the caller's argument data directly. It eliminate the pass by value overhead of copying large amounts ofdata,5,5,5,0.028859377,0.971140623,0.963174798,0.489198566,0.55169702,0.994484828,0.936942087,0.999988947,0.986966791,0.968901729,0.916996245,0.987637159,0.969060581,0.886343777,0.85832583
532,532,532,3.4,"it takes less memory, thus it would make the program faster",4,4,4,0.043886304,0.956113696,0.944000107,0.13898322,0.244331824,0.989310737,0.877783937,0.999955889,0.947988476,0.957541521,0.886674947,0.971133277,0.927757734,0.789341688,0.737411412
533,533,533,3.4,You are able to modify the variable that is referenced directly.,3,4,3.5,0.054973841,0.945026159,0.929852165,0.204556838,0.301882266,0.992070952,0.909342951,0.999987632,0.985417258,0.957697112,0.887090232,0.983503869,0.958716551,0.721682847,0.653073749
534,534,534,3.4,"if you pass by reference, you can modify the value as opposed to passing by value where you cannot change the value",3,4,3.5,0.044950902,0.955049098,0.942641655,0.119415343,0.22715815,0.985885188,0.838617801,0.999947714,0.938348761,0.934848478,0.826105413,0.96224239,0.905507276,0.715510964,0.645380414
535,535,535,3.4,"only the memory address is sent to the function, so no copy of the object sent needs to be made. It makes the function run faster, and saves memory.",5,5,5,0.035032272,0.964967728,0.955298047,0.446305424,0.514052014,0.986813636,0.849233246,0.999875862,0.853626862,0.954112766,0.877523328,0.983715931,0.959247261,0.812907934,0.766787057
536,536,536,3.4,"Actual arguments are associated with dummy arguments when a function or subroutine is referenced. In a procedure reference, the actual argument list identifies the correspondence between the actual arguments provided in the list and the dummy arguments of the subprogram",3,3,3,0.034348965,0.965651035,0.956169962,0.32874018,0.410871314,0.991175021,0.899099297,0.9999869,0.984553108,0.956761935,0.88459417,0.979889987,0.9496724,0.799259186,0.749773707
537,537,537,3.5,"The compiler selects the proper functions to execute based on number, types and order of arguments in the function call.",5,5,5,0.015522659,0.984477341,0.980192744,0.5817011,0.632881526,0.996773682,0.963111776,0.999983318,0.980329767,0.950667462,0.868327538,0.946390978,0.86583731,0.882191181,0.853149563
538,538,538,3.5,They differentiated by the compiler by the conditions/inputs used for one of the overloaded functions.,4,2,3,0.02521354,0.97478646,0.967826966,0.499612838,0.560837068,0.989857152,0.884031392,0.99993309,0.921105148,0.864969874,0.639593868,0.913478624,0.783470392,0.679217339,0.600139918
539,539,539,3.5,"The compiler distinguishes overloaded functions by their signatures. It encodes each function identifier with the number and types of its parameters to generate type-safe linkage, which ensures the proper overloaded function is called.",5,5,5,0.015700758,0.984299243,0.979965487,0.654932797,0.697153052,0.993907871,0.930345428,0.999960048,0.952891484,0.945285396,0.853962376,0.941578086,0.853792499,0.874586701,0.843670476
540,540,540,3.5,"Overloaded functions are distinguished by their signatures, Name mangling or name decoration, and type-safe linkage ensures that proper overloaded functions is called and types of the arguments conform to tpes to the parameters.",5,5,5,0.021475255,0.978524745,0.9725971,0.549878299,0.604952363,0.993747564,0.928512552,0.999941215,0.930686157,0.917418224,0.77958268,0.943230688,0.857928324,0.800000489,0.750697751
541,541,541,3.5,"The compiler selects proper function to execute based on number, types and order of arguments in the function call.",5,5,5,0.014237881,0.985762119,0.98183215,0.597228468,0.646509062,0.995081368,0.943762653,0.999956806,0.949069106,0.968995861,0.91724749,0.947795804,0.869353047,0.903489292,0.879697946
542,542,542,3.5,"By the type they are initilized with (int, char, etc.)",2,4,3,0.031038046,0.968961954,0.960394768,0.25675863,0.347696975,0.985432045,0.833436783,0.999957447,0.949825362,0.9263183,0.80333769,0.940714195,0.851630513,0.697936714,0.623473873
543,543,543,3.5,"It selects the proper function to execute based on number, types and order of arguments in the function call.",5,5,5,0.012495279,0.987504721,0.984055748,0.565008998,0.618231764,0.996108176,0.955502692,0.999969668,0.964235491,0.968649176,0.916322161,0.949934418,0.874705173,0.90441376,0.880850308
544,544,544,3.5,overloaded functions must have the same return type but different input parameters,1,5,3,0.042146385,0.957853615,0.946220282,0.360324383,0.438591073,0.990604535,0.892576622,0.999963068,0.956452442,0.923037285,0.794580401,0.940770136,0.851770512,0.772352457,0.716234105
545,545,545,3.5,"It examines the names, types, and order of arguments on each function.",5,5,5,0.023526192,0.976473808,0.96998006,0.376390189,0.452691168,0.994290162,0.934716365,0.999968441,0.962788789,0.918778847,0.783214291,0.942386179,0.855814844,0.8366189,0.796343097
546,546,546,3.5,unique function signatures,5,5,5,0.073833227,0.926166773,0.905787171,0.538312554,0.59480173,0.986481768,0.845438825,0.999941507,0.931030322,0.842785372,0.58038167,0.933363052,0.83323344,0.771184802,0.714778607
547,547,547,3.5,"Is based on number, types, and order of arguments in the function call.",5,5,5,0.016025603,0.983974397,0.979550977,0.467555106,0.532701718,0.993240992,0.922720646,0.99995875,0.951361779,0.943563955,0.849367713,0.94543577,0.863446793,0.887091517,0.859257898
548,548,548,3.5,"Compiler selects proper function to execute based on number, types and order of arguments in the function call.",5,5,5,0.015821099,0.984178901,0.979811928,0.575424612,0.627372989,0.994689135,0.93927804,0.999947932,0.938605997,0.964259012,0.904604464,0.937967158,0.84475574,0.886616468,0.858665743
549,549,549,3.5,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
550,550,550,3.5,"they have to have same return type, but different input parameters",1,5,3,0.031605124,0.968394876,0.959671163,0.148935258,0.253066194,0.989949829,0.885091021,0.999954066,0.945838521,0.903535506,0.742528603,0.938758497,0.846736156,0.730337679,0.663862115
551,551,551,3.5,Overloaded functions are differentiated by their parameters.,4,5,4.5,0.043171823,0.956828177,0.9449118,0.496676385,0.558259901,0.991292478,0.900442241,0.9999214,0.907322064,0.782977935,0.420750871,0.928492914,0.821045364,0.518520057,0.39982858
552,552,552,3.5,"The compiler selects the right function to execute from the number, types and order of arguments in the function call.",5,5,5,0.01305753,0.98694247,0.983338303,0.575206041,0.627181162,0.996909613,0.964665949,0.999977238,0.973160694,0.963469829,0.902498072,0.945283964,0.863066881,0.897776604,0.872577003
553,553,553,3.5,it creates a set of candidate functions then a set of viable functions,3,3,3,0.033805907,0.966194093,0.956862916,0.344819635,0.424983389,0.989671085,0.881903987,0.999908823,0.892491859,0.881513322,0.683749645,0.935150632,0.837707063,0.650495052,0.564337199
554,554,554,3.5,their function signature.,5,5,5,0.046253622,0.953746378,0.940979357,0.754237771,0.784307694,0.988545508,0.869034661,0.999966178,0.960120408,0.783088905,0.421047058,0.929538317,0.823661604,0.838746071,0.798994644
555,555,555,3.5,The number and type of its parameters.,5,5,5,0.036409616,0.963590384,0.953540525,0.212304339,0.308681832,0.988087854,0.863802059,0.999960952,0.953957486,0.86998921,0.652990875,0.942767223,0.85676845,0.778299868,0.723647633
556,556,556,3.5,by their function signature,5,5,5,0.051978409,0.948021591,0.933674401,0.65424341,0.696548014,0.985142494,0.830126193,0.999975044,0.970574538,0.783088905,0.421047058,0.929538317,0.823661604,0.838746071,0.798994644
557,557,557,3.5,"They have the same name, just different parameters.",3,4,3.5,0.032964826,0.967035174,0.957936154,0.221742317,0.316965038,0.994279597,0.934595576,0.999960604,0.953547587,0.880313345,0.680546811,0.927132147,0.81763989,0.709652245,0.638077441
558,558,558,3.5,"They are differntiated by number, types and order of arguments in the function call.",5,5,5,0.014526606,0.985473394,0.98146373,0.441897243,0.510183191,0.992521306,0.914492087,0.999975864,0.971540668,0.939141778,0.837564572,0.950538687,0.876217425,0.852570713,0.816227247
559,559,559,3.5,"it looks at the number, types, and order of arguments in the function call ",5,5,5,0.019073486,0.980926514,0.97566181,0.311187595,0.395466354,0.99124589,0.899909575,0.99997562,0.971252974,0.938615421,0.836159683,0.943187698,0.857820737,0.846281171,0.808387248
560,560,560,3.5,The compiler differentiates overloaded functions by their signature.,5,5,5,0.036749542,0.963250458,0.953106773,0.660758495,0.702265955,0.990631623,0.892886331,0.999825714,0.794496699,0.835062606,0.559768995,0.885868082,0.714371862,0.776852012,0.721842861
561,561,561,3.5,"By the number, types, and order of their arguments",5,5,5,0.034925878,0.965074122,0.955433808,0.099861309,0.209996625,0.992653617,0.91600487,0.999944041,0.934017419,0.895709232,0.721639656,0.942026038,0.85491355,0.792833626,0.74176416
562,562,562,3.5,"Compiler selects proper function to execute based on number, types and order of arguments in the function call.",5,5,5,0.015821099,0.984178901,0.979811928,0.575424612,0.627372989,0.994689135,0.93927804,0.999947932,0.938605997,0.964259012,0.904604464,0.937967158,0.84475574,0.886616468,0.858665743
563,563,563,3.5,paremeters,4,5,4.5,0.473995805,0.526004195,0.395170881,0.076904245,0.189848442,0.954759029,0.482735786,0.999498449,0.408614416,0.787005403,0.431500503,0.928492904,0.821045339,0.357279986,0.198840647
564,564,564,3.5,"By the number, and the types and order of the  parameters.",5,5,5,0.030570567,0.969429433,0.960991282,0.203704432,0.301134155,0.992772452,0.917363581,0.999950347,0.941453589,0.895709232,0.721639656,0.942026038,0.85491355,0.788510621,0.736375475
565,565,565,3.5,by the number and type of arguments,5,5,5,0.041335285,0.958664715,0.947255264,0.068799213,0.182735091,0.983989936,0.816948371,0.999931177,0.918849981,0.828999972,0.543587343,0.926734888,0.816645704,0.711771488,0.640719107
566,566,566,3.5,"by their signature (return type, argument list)",3,5,4,0.042658031,0.957341969,0.94556741,0.315768212,0.399486515,0.989877867,0.884268243,0.999917377,0.902577803,0.902077031,0.738635818,0.931120854,0.827622084,0.788178265,0.735961189
567,567,567,3.5,overloaded function simply invovles haing a method with the same name within the class. is used to implement a method for subclass which overrides in other words replaces the implementation of the super class. Overloading the concept of providing different meaning to a object based on the context of its presence. Overloading is one type of polymorphism and this is also a feature in programing.,1,5,3,0.019435346,0.980564654,0.975200069,0.491503954,0.553720336,0.99246477,0.913845683,0.999960827,0.953810683,0.94216796,0.845641692,0.942887898,0.857070453,0.847038209,0.809330907
568,568,568,3.6,"A base case that is the simplest case for a problem so that the function will lead to it, if this does not happen then it will end up as an infinite loop. And a condition to know when to terminate.   ",5,5,5,0.015117288,0.984882712,0.980710007,0.506578207,0.566950198,0.990043322,0.886159978,0.999980051,0.976478305,0.95997349,0.893166066,0.974317365,0.935726278,0.818475902,0.773727604
569,569,569,3.6,badly designed algorithyms. using recursion for a non recursive problem.,2,3,2.5,0.049965739,0.950034261,0.936242613,0.337335527,0.418414989,0.98783564,0.860918362,0.9999652,0.958966382,0.968184955,0.915083118,0.963650782,0.909031937,0.752065778,0.690946484
570,570,570,3.6,Infinite recursion can occur when the base case is omitted or the recursion step is written incorrectly so that it never converges on the base case.,5,5,5,0.009326398,0.990673602,0.98809931,0.676694036,0.716251722,0.994276341,0.93455834,0.999974746,0.970222392,0.95319013,0.875060739,0.97849628,0.946184489,0.89466697,0.868700802
571,571,571,3.6,"Infinite recursion is an infinite loop if the condition is not met.  Either omitting the base case, or writing the recursion step incorrectly so that it does not converge on the base case causes ""indefinite"" recursion, eventually exhausting memory.  ",5,5,5,0.009333968,0.990666032,0.98808965,0.625678718,0.671478319,0.99406095,0.932095668,0.999973903,0.969228692,0.919903045,0.786214865,0.979182227,0.947901149,0.860200584,0.825737985
572,572,572,3.6,Either omitting the base case or writing the recursion step incorrectly so that it does not converge on the base case can cause an infinite recursion.,5,5,5,0.013277411,0.986722589,0.98305773,0.59766382,0.646891147,0.994822073,0.940797992,0.999964569,0.958222616,0.967431695,0.913072607,0.976051659,0.940066546,0.879755259,0.850113152
573,573,573,3.6,Not having a base case that returns a base value.,3,5,4,0.028217912,0.971782088,0.963993321,0.306063265,0.390969004,0.990533464,0.891764026,0.999962989,0.956359677,0.984934919,0.959790102,0.979514341,0.948732303,0.829600096,0.787594062
574,574,574,3.6,Incorrect or missing base case. Must reduce to the base case. The function must get simpler each time it is run (converge to the base case).,5,5,5,0.016480744,0.983519256,0.978970207,0.506062746,0.566497806,0.989640312,0.881552151,0.99996516,0.958919598,0.943759246,0.84988896,0.97259188,0.931408055,0.851320267,0.81466855
575,575,575,3.6,no base case no change in values.,4,5,4.5,0.056619287,0.943380714,0.92775254,0.332530886,0.414198214,0.986996253,0.851321207,0.999901099,0.883384607,0.976146155,0.936332193,0.969887014,0.924638819,0.800132751,0.750862618
576,576,576,3.6,"If at each recursive call the problem does not diminish or if it does not diminish to a base case, can cause infinite recursion.",5,5,5,0.014068961,0.985931039,0.982047695,0.582293391,0.633401348,0.993827336,0.929424633,0.999975763,0.971421645,0.980674382,0.948418391,0.97835487,0.945830594,0.801846445,0.75299876
577,577,577,3.6,Omitting the base case or incorrectly calling the recursive step.,5,5,5,0.026590884,0.973409116,0.966069445,0.568945706,0.621686801,0.992567326,0.91501826,0.999965043,0.958782162,0.984478131,0.958570899,0.981674157,0.954137488,0.878653944,0.848740348
578,578,578,3.6,The recursive problem cannot be reduced to reach the base case.,4,5,4.5,0.019049883,0.980950117,0.975691929,0.397581011,0.471289214,0.99185342,0.906855792,0.9999842,0.981370386,0.981770857,0.951344969,0.950288694,0.875591789,0.806663752,0.759003598
579,579,579,3.6,"Lack of defining a base case, or writing the recursion step incorrectly so that it does not converge on the base case",5,5,5,0.015078008,0.984921992,0.980760128,0.55939126,0.613301378,0.99581978,0.952205303,0.999987025,0.984701343,0.976497324,0.937269491,0.979523107,0.948754241,0.862518847,0.828627732
580,580,580,3.6,Not having the proper case to leave the recursion,3,5,4,0.029809356,0.970190644,0.961962604,0.297338158,0.383311447,0.991359716,0.901211007,0.999954176,0.945968642,0.967894744,0.914308522,0.909619666,0.773812909,0.809397101,0.762410756
581,581,581,3.6,"no base case, or the recursive calls do not converge to the base case",5,5,5,0.020518184,0.979481816,0.973818344,0.361028493,0.439209032,0.99256539,0.914996122,0.999979026,0.975269296,0.975146425,0.933663834,0.979793892,0.949431911,0.769898891,0.713175702
582,582,582,3.6,"No base case, or an incorrectly written recursion step that does not converge on the base case will lead to infinite recursion.",5,5,5,0.013731778,0.986268222,0.982477948,0.598273873,0.647426559,0.993405636,0.924603111,0.999983137,0.980116507,0.966427177,0.910391469,0.976085975,0.940152426,0.878542304,0.848601188
583,583,583,3.6,"If the recursion function never reaches or successfully defines the base case it will recurse forever.  This happens many ways, such as the function doesn't progress towards the base case, or the function is coded poorly and doesn't even contain a base case.",5,5,5,0.01105994,0.98894006,0.985887272,0.601939678,0.650643839,0.991097099,0.898208373,0.999982065,0.97885296,0.881661563,0.684145312,0.980089618,0.950171999,0.881381989,0.852140893
584,584,584,3.6," not creating a base case, or in the case where the base case will never be met.",5,5,5,0.018180311,0.981819689,0.976801522,0.500654697,0.561751452,0.993574983,0.926539342,0.999967682,0.961893096,0.927889092,0.807530259,0.893940426,0.734573823,0.829402447,0.78734769
585,585,585,3.6,improper handling of cases such that not all possible values are able to be handled.,2,5,3.5,0.025348604,0.974651396,0.967654622,0.258663952,0.349369174,0.991547151,0.903354056,0.999976286,0.972038549,0.97217104,0.925722295,0.965321784,0.913213811,0.710552037,0.639199044
586,586,586,3.6,There is no base case. The recursion step doesn't reduce the problem during each recursive call.,4,5,4.5,0.020912409,0.979087591,0.973315304,0.531745613,0.589038278,0.992239638,0.911271625,0.999981982,0.978755165,0.985443488,0.961147513,0.980028515,0.950019082,0.818479896,0.773732582
587,587,587,3.6,"no base case, as in a single return that does not include calling the function again.  a static value to end at.",2,5,3.5,0.018685222,0.981314778,0.976157244,0.453834951,0.520660275,0.992000192,0.908533912,0.999878752,0.857034728,0.957667458,0.887011083,0.970521048,0.926225561,0.817856252,0.772955202
588,588,588,3.6,"Either omitting the base case, or writing the recursion step incorrectly so the it does not reach the base case can cause infinite recursion.",5,5,5,0.012632489,0.987367511,0.983880665,0.624608874,0.670539374,0.995555265,0.949180972,0.99998432,0.981511858,0.962614187,0.900214296,0.928090827,0.820039096,0.884826303,0.856434277
589,589,589,3.6,omitting the base case or writing the recursive call so that it does not converge upon the base case.,5,5,5,0.017804086,0.982195914,0.977281593,0.444332093,0.512320127,0.992021378,0.908776145,0.999947524,0.938124475,0.946025722,0.855938365,0.981339645,0.953300334,0.831358373,0.789785779
590,590,590,3.6,"Either omitting the base case, or writing the recursion step incorrectly so that it does not converge on the base case",5,5,5,0.017599761,0.982400239,0.977542316,0.560276985,0.614078731,0.996430178,0.959184312,0.99998735,0.985083961,0.973107974,0.928223047,0.975082653,0.937641498,0.880347013,0.850850783
591,591,591,3.6,Infinite recursion may occur if no base case is defined or if the call is not varied.,4,5,4.5,0.010471702,0.989528298,0.986637877,0.731747687,0.764569355,0.993122389,0.921364596,0.999981306,0.97795738,0.984633429,0.958985401,0.9609854,0.902361515,0.832171738,0.790799649
592,592,592,3.6,"Not having a base case, or building a recursion process that doesn't converge on the base case.",5,5,5,0.017353773,0.982646227,0.977856202,0.432700157,0.502111402,0.991507315,0.902898592,0.999983134,0.980113204,0.965932722,0.909071729,0.957045386,0.892501181,0.855552852,0.819944525
593,593,593,3.6,"Either omitting the base case, or writing the recursion step incorerectly ",5,5,5,0.039389253,0.960610747,0.949738443,0.508070171,0.568259614,0.996599662,0.961122114,0.999984142,0.981301336,0.98820323,0.968513484,0.967372686,0.918346427,0.854614496,0.818774851
594,594,594,3.6,no base case or if the programmar does not define the base case as the simplest case and it never gets reached,5,5,5,0.017748594,0.982251406,0.977352402,0.517765522,0.576768703,0.991053487,0.897709734,0.99997124,0.966088274,0.938871856,0.836844128,0.978306959,0.945710692,0.851475298,0.814861799
595,595,595,3.6,No easily reached base case and no base case at all,5,5,5,0.040070355,0.959929645,0.948869342,0.2535851,0.344911738,0.990646645,0.893058095,0.999974242,0.969628498,0.931731689,0.817786455,0.970699528,0.926672228,0.844427526,0.806076655
596,596,596,3.6,function is never allowed to reach the 'base case',5,5,5,0.032469809,0.967530191,0.958567806,0.208831146,0.305633597,0.99041704,0.890432888,0.999963907,0.957441713,0.97975197,0.9459564,0.956916786,0.892179345,0.820585966,0.776357827
597,597,597,3.6,"it has no base case, or the base case is never met",5,5,5,0.021644294,0.978355706,0.972381402,0.437571704,0.506386897,0.990080717,0.886587532,0.999934167,0.92237589,0.950652745,0.868288257,0.809701736,0.523756897,0.822214723,0.778388095
598,598,598,3.6,recursion refers to situations in which functions call themselves. These types of functions are known as recursive functions. That being said Infinite recursion occurs when the function is designed in such a way as to call it self forever without stopping possible causes,1,5,3,0.020491719,0.979508281,0.973852114,0.408362716,0.480751738,0.989039101,0.87467818,0.999973902,0.969227842,0.93242767,0.819644084,0.967733809,0.919250178,0.79110378,0.739607883
599,599,599,3.7,"Both involve a controlled repetition structures, and they both have a termination test.  Also both of them can loop forever. ",5,5,5,0.018811584,0.981188417,0.975996004,0.769042492,0.797301002,0.997590832,0.97245469,0.999982413,0.979262715,0.960060345,0.893397888,0.969269807,0.923094188,0.888319433,0.860788511
600,600,600,3.7,"As discussed earlier, recursion may be used to process iterative actions. Recursion is used for calculations where the answer can be described in a function that relates to itself.",1,3,2,0.051482379,0.948517621,0.934307347,0.339045674,0.419915893,0.997433205,0.970652457,0.999982432,0.97928541,0.935872994,0.828839927,0.959751692,0.89927402,0.736528099,0.671578557
601,601,601,3.7,Both iteration and recursion are based on control statements and involve repetition. They can both also occur indefinitely.,5,5,5,0.025611997,0.974388003,0.967318526,0.720869482,0.755022138,0.991640429,0.904420554,0.999983606,0.980669566,0.958043853,0.888015711,0.969640501,0.924021892,0.886212826,0.858162597
602,602,602,3.7,Both are based on a control statement         - Iteration-repetition structure         - Recursion-selection structure        Both involve repetition         -Iteration-explicitly uses repetition structure         -Recursion-repeated function calls        Both involve a termination test         -Iteration-loop-termination test         -Recursion-base case         Both gradually approach termination         -Iteration-modifies counter until loop-termination test fails         -Recursion-produces progressively simpler versions of problem        Both can occur indefinitely         -Iteration-if loop-continuation condition never fails         -Recursion-if recursion step does not simplify the problem,5,5,5,0.061344266,0.938655734,0.921723361,0.458606273,0.524847808,0.988935743,0.873496436,0.999928861,0.916119398,0.74025949,0.306731948,0.972882515,0.932135402,0.860554576,0.826179241
603,603,603,3.7,"Iteration and recursion have many similarities: both are based on a control statement, involve repetition, involve a termination test, gradually approach termination and can occur infinitely.",5,5,5,0.025367618,0.974632382,0.96763036,0.650595605,0.693346532,0.995958124,0.953787074,0.999979955,0.976364409,0.977261941,0.939310314,0.97602116,0.939990219,0.92550391,0.907139465
604,604,604,3.7,"Both rely on repetition, both have a base case, both can become an infinite loop. Anything recursive can also be solved with iteration.",5,5,5,0.033173501,0.966826499,0.957669879,0.616787791,0.66367523,0.994649364,0.938823315,0.99998234,0.979177053,0.940486724,0.841154339,0.965181522,0.912862789,0.811899483,0.765530009
605,605,605,3.7,"Both will repeat (loop) until a condition is met, and exit the loop. Both are capable of entering an infinite loop.",3,5,4,0.033677816,0.966322184,0.957026362,0.407867461,0.480317079,0.991875182,0.907104614,0.999944647,0.934733048,0.936460669,0.830408479,0.962092575,0.905132347,0.760889888,0.701945857
606,606,606,3.7,anything you can do iterativly you can do recursively,2,4,3,0.118809223,0.881190777,0.848396806,0.299165785,0.384915457,0.977912171,0.74745804,0.999968891,0.963318497,0.958694365,0.889751979,0.978140798,0.945294855,0.67661649,0.596897925
607,607,607,3.7,Both are repetative and both have a end test.,4,5,4.5,0.045408189,0.954591811,0.942058147,0.59522295,0.644748927,0.989138652,0.875816396,0.999938655,0.927667157,0.961565001,0.897413935,0.935875851,0.839522006,0.731224954,0.664968115
608,608,608,3.7,"Incorrectly writing either can result in infinite loops, both perform the same task over and over.",3,4,3.5,0.039762795,0.960237205,0.949261795,0.407710135,0.480179002,0.994416708,0.936163231,0.999980635,0.977166077,0.961560534,0.897402012,0.978469066,0.946116383,0.790049911,0.738294221
609,609,609,3.7,Both are based on a control statement. Both involve repetition. Both involve a termination test. Both gradually approach termination. Both can occur infinitely.,5,5,5,0.021463394,0.978536606,0.972612235,0.740942538,0.772639181,0.990194035,0.887883155,0.999972676,0.967782422,0.889810171,0.705894594,0.965901706,0.914665131,0.865327835,0.832129173
610,610,610,3.7,"Both are based on a control statement, Both involve repetition, Both involve a termination test, Both gradually approach termination, Both can occur infinitely",5,5,5,0.019250214,0.980749786,0.975436302,0.732208908,0.764974143,0.992012354,0.90867297,0.99997831,0.974425207,0.889810171,0.705894594,0.965901706,0.914665131,0.865327835,0.832129173
611,611,611,3.7,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
612,612,612,3.7,anything you can do recursively you can do iteratively,2,4,3,0.115918696,0.884081304,0.852085183,0.311864823,0.39606072,0.977912171,0.74745804,0.999968891,0.963318497,0.958694365,0.889751979,0.978140798,0.945294855,0.6368922,0.547381059
613,613,613,3.7,"Many problems can be solved by both iteration and recursion, and either may go into a condition of infinite execution if a termination test is omitted.",2,5,3.5,0.031967759,0.968032241,0.959208433,0.527900815,0.585663906,0.993963218,0.930978239,0.999983394,0.980419945,0.956134001,0.882918164,0.947560391,0.868763899,0.810888827,0.764270212
614,614,614,3.7,"Iteration and recursion both use repetition and perform several simple operations and algorithms successively until they reach a certain limit.  So both involve a termination test to find that limit and both slowly approach that termination limit.  Both are based on a control statement as well.    If coded poorly, both can continue on for forever until the compiler or the computer either locks up, shuts down or halts the operation.",5,5,5,0.021923423,0.978076577,0.972025228,0.622647643,0.668818107,0.990589507,0.892404796,0.999982576,0.979455062,0.874994962,0.666351625,0.965722516,0.914216688,0.865044057,0.831775441
615,615,615,3.7,"both based on control statement, involve repetition, and involve a termination test within loops",5,5,5,0.028964043,0.971035957,0.963041242,0.502648354,0.563501177,0.994553144,0.937723177,0.999975892,0.971574431,0.972379966,0.926279935,0.973296601,0.933171699,0.886253715,0.858213566
616,616,616,3.7,they are methods of repeating the same task.,1,3,2,0.047599614,0.952400386,0.939261841,0.31503576,0.398843682,0.983780064,0.814548795,0.999970825,0.965599601,0.965611837,0.908215262,0.978140798,0.945294855,0.690975666,0.614796832
617,617,617,3.7,Both involve a termination test.   They use a control statement and repition to solve the problem.  They can also result in an infinite loop.,5,5,5,0.030421436,0.969578564,0.961181576,0.61074239,0.658369506,0.988935262,0.87349093,0.999983013,0.97997065,0.910253694,0.760459981,0.968328221,0.920737762,0.859663308,0.825068263
618,618,618,3.7,"based on a control statement, involve repetition, involve a termination test.",5,5,5,0.038760901,0.9612391,0.950540235,0.461517841,0.527403135,0.990744636,0.894178475,0.999963426,0.956874543,0.974207089,0.931156672,0.974000075,0.934932223,0.876631498,0.846219343
619,619,619,3.7,Both are bases on a control statement. Both involve repetition. Both involve a termination test. Both gradually approach termination. Both can occur infinitely.,5,5,5,0.021039426,0.978960574,0.973153227,0.743908465,0.775242216,0.990194035,0.887883155,0.999974177,0.969551797,0.912117593,0.765434875,0.969596426,0.92391159,0.867278397,0.834560575
620,620,620,3.7,"both based on a control statement, both involve repitition, both involve a termination test, both gradually approach termination, both can potentially occur infinetly.",5,5,5,0.021803677,0.978196323,0.972178026,0.736532629,0.768768841,0.992815729,0.91785839,0.999972902,0.968048259,0.952349758,0.872817719,0.973026385,0.932495453,0.880068243,0.850503291
621,621,621,3.7,"they are both based on a control statement, both involve repetition, both involve a termination case, both graduatlly approach that termination case, and both can occur infinitely",5,5,5,0.017527223,0.982472777,0.977634877,0.75536859,0.785300153,0.991549117,0.903376536,0.999983945,0.981069554,0.948263077,0.861910043,0.974248501,0.935553938,0.875047207,0.844244502
622,622,622,3.7,"They both use repetition, a control or test to terminate, and both can infinitely repeat if not defined correctly.",5,5,5,0.019942462,0.980057538,0.974552977,0.657611728,0.699504206,0.99123024,0.899730644,0.999979202,0.975477338,0.937132444,0.8322015,0.974485614,0.93614734,0.893194437,0.86686527
623,623,623,3.7,"Both are based on a control statement; both gradually approach termination ending with a termination test; both involve repetition, and can both repeat infinitely if their  termination requirements are not met.",5,5,5,0.014013827,0.985986173,0.982118047,0.782342196,0.808973437,0.990108726,0.886907773,0.999983958,0.981084326,0.952169903,0.872337672,0.97255276,0.931310152,0.878475368,0.848517751
624,624,624,3.7,"both are based on a control statement, involve repetition and involve a termination test. both gradually approach termination, both can occur infinitely",5,5,5,0.018779218,0.981220782,0.976037303,0.75229007,0.782598301,0.991492669,0.902731131,0.999980347,0.976826812,0.952877814,0.874227143,0.973150773,0.932806748,0.920582235,0.901004531
625,625,625,3.7,they are used to solve the same type of problems. they do a task over and over again until a cirtain conditional statement is reached (its called the base case in recursion).,3,4,3.5,0.040023029,0.959976971,0.948929731,0.333643109,0.415174352,0.985159073,0.830315746,0.999981995,0.978769517,0.938706967,0.836404026,0.977297252,0.943183785,0.701720357,0.628190235
626,626,626,3.7,Based on control statement;  involve repetition; involve a terminal test; both can occur infinitly,5,5,5,0.028768718,0.971231282,0.96329048,0.696781397,0.73388132,0.992764037,0.917267366,0.999964536,0.958184337,0.961339978,0.896813331,0.97169288,0.929158205,0.880643249,0.851220044
627,627,627,3.7,"repetition, termination test, eventually terminate, occur infinately",5,5,5,0.04625988,0.95374012,0.940971371,0.466334999,0.531630896,0.992582842,0.915195669,0.999923205,0.909450364,0.968342029,0.915502361,0.979316542,0.948237288,0.873359323,0.842140531
628,628,628,3.7,both need to have some kind of base case to tell when the loop needs to stop.,3,3,3,0.043828189,0.956171811,0.944074262,0.259771764,0.350341441,0.980815921,0.780658168,0.999932853,0.92082561,0.950293186,0.867328565,0.947975065,0.869801668,0.680216014,0.601384781
629,629,629,3.7,"they both are able to do repetiive tasks. however recurisve calls itself with different parameters and defines and exit clause that is guaranteeed to be reached. Iterative includes a loop which iterates a pre-determined number of times, or checks for an exit clause every time through",2,5,3.5,0.036154807,0.963845193,0.953865668,0.391814351,0.466228126,0.990368513,0.889878054,0.999982105,0.978899271,0.880049365,0.679842228,0.976691548,0.941667941,0.831182897,0.789567046
630,630,630,4.1,int n[10]; //array of 10 integers and int n[arraySize] //where arraySize is some positive integer defined by the user,3,5,4,0.059214473,0.940785527,0.924441025,0.271807551,0.360904605,0.985448563,0.833625637,0.999982625,0.979512449,0.95204891,0.872014732,0.961836979,0.904492689,0.627601862,0.535800527
631,631,631,4.1,by either inputing the different elements in the array at coding or giving the array specifacations as to the size of the array. it is also possible when giving it specifacations to tell the array to grow as needed.,3,5,4,0.021540403,0.978459597,0.972513969,0.533420026,0.590507821,0.988911059,0.873214211,0.999936538,0.925171032,0.883895924,0.690108999,0.921925092,0.804608641,0.738835514,0.674454781
632,632,632,4.1,You can initialize and array by using an initializer list in its declaration or by initializing its size with a constant variable.,5,5,5,0.013311625,0.986688376,0.983014073,0.730401814,0.763388154,0.992049041,0.909092435,0.999967024,0.961117957,0.972402385,0.926339774,0.971724502,0.929237342,0.87733674,0.847098437
633,633,633,4.1,Pass the length along with the array or use a vector.,2,4,3,0.020963728,0.979036272,0.973249819,0.534325659,0.591302646,0.993986137,0.931240293,0.999916304,0.901312554,0.970539906,0.921368669,0.96624794,0.915531622,0.729044676,0.662250369
634,634,634,4.1,"One way is to declare a size of the array using a variable that is equal to an integer. The other way, if the size is omitted in the declaration, the compiler determines the size of the array based on the size of the initializer list.",5,5,5,0.01897043,0.98102957,0.975793312,0.562035561,0.615622138,0.984451705,0.822228022,0.999934609,0.92289612,0.859820453,0.625849655,0.957939733,0.894739386,0.844020128,0.805568828
635,635,635,4.1,"In the declaration (int array [x]) or with an initilizer (int array[]={0,1,2,etc.}",5,5,5,0.042874336,0.957125664,0.9452914,0.459921777,0.526002356,0.986389784,0.844387124,0.999914364,0.899025454,0.947596211,0.860130125,0.959839371,0.899493447,0.751893103,0.690731243
636,636,636,4.1,"1. Declare the length of the array (int array[10];) 2. Initialize the array (int array[] = {0, 1, 2, 3}; //compiler will assume size of 4)",5,5,5,0.040916204,0.959083796,0.947790019,0.449348748,0.516722976,0.971360043,0.67254405,0.999913722,0.898268259,0.930748337,0.815161811,0.945802512,0.864364607,0.670414746,0.589167367
637,637,637,4.1,statically and dynamically,2,3,2.5,0.164840579,0.835159421,0.789659779,-0.006020246,0.117070071,0.984832015,0.826576311,0.99990185,0.884269897,0.938171078,0.834973696,0.963949117,0.909778555,0.3953273,0.246267139
638,638,638,4.1,Explicitly int array[10]; or by variable const int size = 10; int array[size];,3,5,4,0.061623037,0.938376963,0.921367644,0.368294925,0.445586389,0.985624898,0.835641775,0.999834949,0.805386143,0.916084303,0.776022339,0.935658064,0.838976969,0.64579165,0.558474344
639,639,639,4.1,"Array lengths can be explicitly specified by inputing the number of elements between the brackets [ ] during declaration, or implicitly by including an initializer list WITHOUT specifying a number between [ ], the compiler will automatically declare the array with the proper number of elements needed for the list. ",5,5,5,0.016361117,0.983638883,0.979122853,0.595199108,0.644728002,0.983638664,0.812932093,0.999913345,0.897823498,0.830715605,0.548166504,0.969545594,0.923784377,0.828481913,0.786200232
640,640,640,4.1,Specify an arrays size with a constant variable. And setting array elements with calculations.,2,5,3.5,0.027478158,0.972521842,0.964937263,0.516768158,0.57589337,0.989432432,0.87917534,0.999948543,0.939326459,0.958106518,0.888182969,0.967519552,0.918713976,0.745213687,0.682405261
641,641,641,4.1,"statically, using {} and dynamically, using []",4,4,4,0.065752864,0.934247136,0.916097893,0.337324411,0.418405233,0.990909227,0.896060326,0.999942541,0.93224934,0.971252118,0.92326962,0.932864582,0.831985962,0.670299828,0.58902412
642,642,642,4.1,"define it as array[5] or array[1,2,3,4,5]",4,5,4.5,0.077096224,0.922903776,0.901623515,0.334331423,0.415778448,0.994161354,0.933243638,0.999932417,0.920311856,0.948603728,0.862819268,0.963949116,0.909778552,0.498048723,0.374310784
643,643,643,4.1,Static and dynamic.,2,3,2.5,0.070817709,0.929182291,0.909635039,0.308390558,0.393011544,0.986299479,0.843354617,0.999907149,0.890518109,0.938174593,0.834983078,0.954207565,0.88539921,0.347038835,0.186074913
644,644,644,4.1,manually inside the brackets or automatically via an initializer list,5,5,5,0.043717802,0.956282198,0.944215119,0.418890268,0.489991204,0.995425885,0.947701691,0.999899163,0.881101333,0.967129213,0.912265259,0.973489585,0.933654664,0.781113625,0.727155019
645,645,645,4.1,"You can use an initializer list, or simply tell the compiler how many elements you want in the array.  For an Initializer list:  int a[] = {10, 2, 3, -4, 5};  For an elemental declaration: int b[5];  Both arrays have 5 elements in them, but array a is already initialized.",5,5,5,0.021938562,0.978061438,0.97200591,0.561920643,0.615521281,0.978445051,0.75355074,0.99997846,0.974601445,0.914404139,0.771537848,0.971224541,0.927986133,0.842006266,0.803058522
646,646,646,4.1,"In a string you can specify with the strlen(arrayname) command. This gets the length of the string. Another way is with integers where you initiate the size from the start, ex array[40] specifying a possible length of up to 40. Then it is passed by an object the actual ammout in the array. Another way is to declare it in an initializing program. ",4,5,4.5,0.019331276,0.980668724,0.975332864,0.52977103,0.587305293,0.978717348,0.756664056,0.999967228,0.961357484,0.909566709,0.758626363,0.964858335,0.912053977,0.828262448,0.785926667
647,647,647,4.1,"Implicit, namely when you give it values, like {1,2,3,4,5,6,7,8,9}, at which the compiler will automatically give this a size. Static, during the declaration. ",5,5,5,0.025740325,0.974259675,0.967154776,0.468511015,0.533540669,0.98771718,0.859563946,0.999975044,0.970573824,0.945186486,0.853698377,0.967377675,0.918358912,0.808176875,0.760889727
648,648,648,4.1,"Supply an integer inside the brackets or the compiler counts the number of elements in the initializer list. int n[5]; int n[] = { 1,2,3,4,5 }",5,5,5,0.036919594,0.963080406,0.952889783,0.411697984,0.483678923,0.994533845,0.937502525,0.999945154,0.935329783,0.915728282,0.775072091,0.973437647,0.933524683,0.758535683,0.699011309
649,649,649,4.1,either initializing the array with a specific length or initializing an array while declaring its contents.,5,5,5,0.021690607,0.978309393,0.972322306,0.584936917,0.635721428,0.991436478,0.902088675,0.999956681,0.948922292,0.971760721,0.924627121,0.963803806,0.909414898,0.816959262,0.771837092
650,650,650,4.1,within the brackets or by using an initializer list.,5,5,5,0.011409462,0.988590539,0.985441275,0.73647368,0.768717105,0.995483166,0.948356627,0.999970669,0.965414831,0.999242444,0.997978023,0.96853804,0.921262858,0.906315088,0.88322034
651,651,651,4.1,specify the number of elements in the array declaration with a constant or using a constant variable for future scalability,3,5,4,0.027052283,0.972947717,0.965480689,0.367698044,0.445062539,0.990827044,0.895120693,0.999938716,0.927738659,0.967132978,0.912275308,0.964908932,0.912180601,0.780093372,0.72588326
652,652,652,4.1,with a number and with a variable,3,3,3,0.048686445,0.951313555,0.937875021,0.141994238,0.246974433,0.987308017,0.854885767,0.999891517,0.872086515,0.954396198,0.87827983,0.935871369,0.839510789,0.531000137,0.415385169
653,653,653,4.1,"explicitly, by declaring it in brackets (i.e. int array[50];) and implicitly, by initializing several values (i.e. int array[] = {1, 2, 3};)",5,5,5,0.037070215,0.962929785,0.952697587,0.462876886,0.528595896,0.975758497,0.722833932,0.999940831,0.93023285,0.933480185,0.82245333,0.959308457,0.898164774,0.731056869,0.664758595
654,654,654,4.1,"one way of specifying of array is A[10] ; other way of specifying array is a[arraysize] = [1,2,3,4,5,6,7,8,9,10}",4,5,4.5,0.053996921,0.946003079,0.931098736,0.327836663,0.410078346,0.986533688,0.846032456,0.999949423,0.940364043,0.966220534,0.909839922,0.96666531,0.916576138,0.572120607,0.466642391
655,655,655,4.1,1-Initializing an array in a declaration with an initializer list 2-Specifying an arrays size with a constant variable,5,5,5,0.030173123,0.969826877,0.961498429,0.524427891,0.582615907,0.9901577,0.887467725,0.999961451,0.954546421,0.966862957,0.9115546,0.95726056,0.893039678,0.799643397,0.750252632
656,656,656,4.1,"Initializing the size in the brackets: int a[100]; Initializing the length by assigning variables: int a[] = {1,2,3};",5,5,5,0.044680715,0.955319285,0.942986421,0.358885378,0.437328135,0.988368121,0.867006507,0.999898471,0.880286217,0.943874752,0.850197255,0.95667614,0.891577101,0.711497903,0.640378079
657,657,657,4.1,user defined value or by the number of elements in initializer list,5,5,5,0.023671567,0.976328433,0.969794557,0.430722326,0.500375566,0.993561001,0.926379483,0.999931948,0.919758749,0.950422392,0.867673426,0.961914385,0.904686406,0.787198722,0.734740176
658,658,658,4.1,"you can assign the size of it inside the brackets when you declare the array [3], or you can have it set by how many items you set the array equal to {1,2,3}",5,5,5,0.03441304,0.96558696,0.956088201,0.293451428,0.379900273,0.983401967,0.810225809,0.999929766,0.917185705,0.932284697,0.819262478,0.959835419,0.899483557,0.77118969,0.7147847
659,659,659,4.1,"use an arraylist, or have your program ask the array how many elements it has. As an obj it it should have member length that is the number of slots it has. ",3,5,4,0.02794534,0.97205466,0.964341129,0.413108647,0.484916986,0.989104388,0.875424645,0.999963053,0.956434748,0.941002595,0.84253124,0.971154655,0.927811235,0.800712228,0.751584943
660,660,660,4.2,"strings that are used in an char array are much easier to manipulate than as a string object, because each character is stored separately rather than as a whole",1,4,2.5,0.019994736,0.980005264,0.974486276,0.353415847,0.432527822,0.989312028,0.877798703,0.999951509,0.942823952,0.949241365,0.864521171,0.962811845,0.906932402,0.682132483,0.603773684
661,661,661,4.2,"the type string uses less storage and you have to change the string all at once. with an array of characters you can make permutations of words using the characters stored in the array, without needing to actually access and change the variables. with an array of characters you can just change how they're accessed.",1,5,3,0.014151335,0.985848665,0.981942584,0.545767188,0.601344261,0.987615063,0.858396397,0.99992744,0.914443907,0.950611266,0.868177546,0.950660554,0.876522411,0.670494974,0.589267372
662,662,662,4.2,"Unlike in a string declared using type string, in a string declared using an array of characters the programmer must provide the null terminating character and must ensure the array is large enough to hold the string and null terminating character.",5,5,5,0.013914883,0.986085117,0.982244302,0.674486637,0.714314407,0.987151549,0.853096789,0.999968455,0.962804538,0.955289439,0.880663961,0.963208224,0.907924386,0.749226928,0.687407819
663,663,663,4.2,"All strings represented by character arrays end with the null character. You declare an object of type string just like any other type, for example:  string s; ",5,5,5,0.014761329,0.985238671,0.981164219,0.568169832,0.621005859,0.99051961,0.891605632,0.99997068,0.965428898,0.962963018,0.901145353,0.970638148,0.926518618,0.796943426,0.746887081
664,664,664,4.2,"By using an array of characters, one can store and manipulate the strings rather than just having a type string variable.",1,4,2.5,0.012874484,0.987125516,0.983571874,0.545948029,0.601502975,0.991847193,0.906784602,0.999983414,0.980443432,0.94012968,0.84020136,0.957549847,0.893763652,0.661634207,0.578222306
665,665,665,4.2,type string is an array of chars that will make an array of single letter characters while an array of strings will be an actual array of words (or an array of char arrays),0,4,2,0.013281405,0.986718595,0.983052634,0.616072357,0.663047331,0.991001937,0.897120331,0.999890635,0.871045972,0.952366214,0.872861642,0.963120877,0.90770579,0.622300029,0.52919172
666,666,666,4.2,"They're basically the same, however, a string ends w/ a null character, denoting the end of the string (and the size). A char array has potential to be any size, so it must be declared or limited.",2,5,3.5,0.020834386,0.979165614,0.973414863,0.481421769,0.544871743,0.979223111,0.762446716,0.999977426,0.97338252,0.957728104,0.887172952,0.971237716,0.928019105,0.776277542,0.721126777
667,667,667,4.2,string is a class in the standard library and has method that modify it. Whereas the char array is on able to be modifie by the user.,4,4,4,0.024389267,0.975610733,0.968878757,0.43556875,0.504629012,0.99148698,0.902666089,0.999956796,0.949058148,0.948255698,0.861890348,0.959080167,0.897593452,0.647335291,0.560398514
668,668,668,4.2,"By using an array of characters, you are limited to the size of the array of characters.  By declaring by type the end of the string is acknowledged by white space.",3,4,3.5,0.013615549,0.986384451,0.982626259,0.633561373,0.678396501,0.991969209,0.90817967,0.999959592,0.952354793,0.944722936,0.852461126,0.962977357,0.907346615,0.739291012,0.675022566
669,669,669,4.2,"The data class type string are designed to handle character data, and has many functions built into the class library to deal with them. An array of characters however is subject to all the same rules of any other array with no real additional functionality. Another difference is that the string class deals with the null character implicitly, unlike an array of characters, which must handle the null character explicitly. ",5,5,5,0.014584005,0.985415995,0.981390488,0.537081957,0.593721701,0.980598798,0.778175679,0.999948186,0.938905002,0.928792482,0.809941479,0.953896754,0.88462137,0.763838589,0.705621453
670,670,670,4.2,string declared used in an array of characters contains each character in the array and a special string-termination character called the null character versus the type string.,5,5,5,0.015601516,0.984398484,0.980092121,0.658563376,0.700339416,0.995985531,0.954100426,0.99995443,0.946267895,0.946363487,0.856839887,0.938210622,0.845365036,0.65516448,0.570157704
671,671,671,4.2,A char array reads a string as each individual character. A string literal array reads the entire string.,2,4,3,0.020991087,0.979008913,0.973214909,0.580983877,0.632252058,0.995394102,0.947338309,0.999954657,0.946535351,0.938014741,0.83455642,0.961633363,0.903983116,0.654723287,0.56960775
672,672,672,4.2,array of characters can only hold as many characters as the array size and strings are not that limited.,4,4,4,0.021603227,0.978396773,0.972433805,0.59660548,0.645962299,0.995879148,0.952884091,0.999918211,0.903561609,0.927593218,0.806740548,0.94905859,0.872513313,0.533774257,0.418843146
673,673,673,4.2,"Stings can only be modified by functions of the String class, an array of characters can be modified by the user",3,4,3.5,0.020445347,0.979554653,0.973911286,0.384853423,0.460118894,0.991552024,0.903409773,0.999920098,0.905786277,0.956854783,0.884841989,0.96592174,0.914715269,0.603986859,0.506364106
674,674,674,4.2,"if by type string, the array contains an additional terminating null character",3,5,4,0.023756504,0.976243496,0.969686176,0.571612835,0.624027597,0.98718879,0.853522583,0.999969446,0.963973388,0.941230862,0.843140503,0.969254206,0.923055145,0.747526944,0.685288766
675,675,675,4.2,The array of characters has a null character \0 at the end of the array to signify the array's end.  The string does not have this.,5,5,5,0.012125075,0.987874925,0.984528137,0.754921556,0.784907814,0.994773985,0.940248171,0.999957024,0.949325977,0.975002921,0.933280811,0.972762217,0.931834342,0.870583653,0.838680622
676,676,676,4.2,strings with type string are just that. Strings. They are not part of an array list at all where as one declared by an array is actually an array of characters able to be pointed and detected.,2,4,3,0.015350521,0.984649479,0.980412397,0.675526142,0.715226725,0.984597907,0.823899629,0.999952337,0.943800008,0.941596507,0.844116438,0.966760719,0.916814909,0.721663058,0.653049082
677,677,677,4.2,"the array of characters has a set length, while the type string has virtually unlimited length.",4,4,4,0.020559072,0.979440928,0.973766169,0.489041507,0.551559179,0.99050166,0.891400403,0.999978113,0.97419297,0.914285701,0.771221728,0.958682005,0.896597007,0.549714923,0.438713402
678,678,678,4.2,Char array - Individual letters can be accessed directly with array subscript notation.  String array - array subscript will return the entire string.,1,3,2,0.030444384,0.969555616,0.961152294,0.5204283,0.57910568,0.990398217,0.890217674,0.999948631,0.939429554,0.949494697,0.865197335,0.96814382,0.920276277,0.669138193,0.587576127
679,679,679,4.2,array of characters need a termination character as well as size specification whether its explicit or implicit.,5,5,5,0.02530998,0.97469002,0.967703907,0.414798379,0.486399973,0.991790208,0.906133062,0.999955057,0.947006745,0.934086331,0.824071182,0.970002785,0.924928549,0.661298275,0.577803562
680,680,680,4.2,when using an array individual characters can be accessed and manipulated.,1,4,2.5,0.029670417,0.970329583,0.962139892,0.446260601,0.514012676,0.993604659,0.926878646,0.999945852,0.93615349,0.883774108,0.689783863,0.967544622,0.918776716,0.474151969,0.344523157
681,681,681,4.2,strings declared using an array of characters could result in data loss if character array not initialized large enough.,4,4,4,0.028006971,0.971993029,0.964262486,0.644857347,0.688310371,0.996899254,0.964547508,0.999980772,0.977328482,0.957193314,0.885745555,0.962004881,0.904912883,0.672545433,0.591823297
682,682,682,4.2,"an array is passed by reference therefore if an array of characters is changed, the memory is changed not just the variable",3,4,3.5,0.019485533,0.980514467,0.975136029,0.431282997,0.500867637,0.99133403,0.900917335,0.999969505,0.96404338,0.953625372,0.876222434,0.959788062,0.89936504,0.635117888,0.545169356
683,683,683,4.2,"the type string has several built-in functions not available when using a char array, but the individual characters in an array or more directly accessible than the characters in a string type string.",3,4,3.5,0.018781543,0.981218457,0.976034336,0.567500353,0.620418293,0.987251943,0.854244642,0.999972502,0.967576294,0.929975114,0.813098017,0.96931084,0.923196878,0.606373012,0.509338478
684,684,684,4.2,"declaring a string, it includes white spaces but declaring a array of character does not include white spaces",0,3,1.5,0.027544022,0.972455978,0.96485322,0.4044604,0.477326885,0.990487046,0.891233311,0.999950812,0.942001709,0.951446184,0.870406009,0.965599731,0.913909405,0.615903437,0.521218282
685,685,685,4.2,"an array of characters has one element a string doesnt have. it is the termination element, or ""null""",5,5,5,0.017380893,0.982619107,0.977821596,0.607117415,0.65518806,0.99452107,0.93735646,0.99997485,0.970345228,0.964135813,0.904275636,0.968065319,0.92007982,0.854153693,0.818200453
686,686,686,4.2,Strings declared using the type string can vary in length. Strings declared using an array of characters can not extend past the array length.,4,4,4,0.013477266,0.986522734,0.982802711,0.657506704,0.699412032,0.995924583,0.953403577,0.999919656,0.905265174,0.936407613,0.830266868,0.964945101,0.912271118,0.587111533,0.485328783
687,687,687,4.2,"cant modify individual characters of a type string array, character type array can modify individual characters",1,4,2.5,0.040939868,0.959060133,0.947759825,0.458036244,0.524347525,0.995633889,0.950079914,0.99994882,0.939653489,0.932971993,0.821096925,0.970002194,0.92492707,0.506518304,0.384868232
688,688,688,4.2,"the type string is a class and is safer, while the other is just an array of characters.",3,4,3.5,0.018210828,0.981789172,0.976762581,0.453828603,0.520654704,0.981572938,0.789313544,0.999956301,0.948473723,0.832073495,0.55179082,0.932917924,0.832119456,0.439670265,0.301541245
689,689,689,4.2,"array  it is the collection of similar data types ex:int a[10]  ten indicates the size of array. [ ] is index of array, we can give only integer values to array of a.  where as string mean collection of group of characters.  string declarations have a datatype usually causes storage to be allocated in memory that is capable of holding some predetermined number of symbols.    However  Arrays can be declared to contain values of any non reference data type. Multiple arrarys of the same type ",1,4,2.5,0.014341474,0.985658526,0.981699963,0.524184406,0.582402213,0.97219741,0.682118118,0.999950043,0.941094787,0.918516212,0.782513298,0.96618319,0.915369577,0.711989284,0.640990591
690,690,690,4.3,by reference only,5,5,5,0.100285649,0.899714351,0.872033296,0.657952905,0.699803639,0.996596597,0.961087069,0.999954807,0.946712344,1,1,1,1,1,0.999999851
691,691,691,4.3,a reference pointer to an element in the array.,4,5,4.5,0.112875462,0.887124538,0.855968417,0.623755992,0.669790845,0.992738986,0.916980948,0.999892844,0.873651079,0.922661778,0.793578143,0.945770359,0.86428414,0.675858736,0.595953374
692,692,692,4.3,Arrays are passed to functions by reference.,5,5,5,0.079484284,0.920515716,0.898576298,0.62204057,0.668285311,0.993197688,0.922225532,0.999886768,0.866486465,0.97898199,0.943901262,0.877631017,0.693757668,0.751703501,0.690494901
693,693,693,4.3,#NAME?,5,5,5,0.165067673,0.834932327,0.789370003,0.278628826,0.366891271,0.982840132,0.803802057,0.99975336,0.709183773,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
694,694,694,4.3,Arrays are passed by reference.,5,5,5,0.05469811,0.94530189,0.930204004,0.695956409,0.733157273,0.99425614,0.934327374,0.999916185,0.901173157,0.97898199,0.943901262,0.877631017,0.693757668,0.751703501,0.690494901
695,695,695,4.3,"you must pass the array and its size to the function. Ex. function(array, size);",4,4,4,0.133409321,0.866590679,0.829766759,0.307616681,0.392332354,0.984704622,0.825119758,0.999845726,0.818093487,0.830895776,0.548647394,0.928875978,0.822004026,0.414068758,0.269628621
696,696,696,4.3,"Usually the same way you pass anything else... you do not have to specify the length of a char array, just pass it to the function by sending the name of the array.  Example: char str[20]; isPalindrome(str); // this sends the char array to the function isPalindrome.  Otherwise, would need to send the length of the array as well.",3,4,3.5,0.13481915,0.86518085,0.827967786,0.276469827,0.364996433,0.964826437,0.597841848,0.999875862,0.853626948,0.681567343,0.150077946,0.928847711,0.821933284,0.432961226,0.293178337
697,697,697,4.3,you pass a pointer to the first item and also pass the size.,4,3,3.5,0.142725468,0.857274532,0.81787915,0.182633132,0.282641007,0.989526732,0.880253525,0.999841205,0.812763291,0.870528022,0.654429007,0.93993106,0.849670629,0.395905584,0.246987978
698,698,698,4.3,By reference.,5,5,5,0,1,1,0.948016524,0.954376896,0.992687258,0.916389515,0.999877009,0.85497931,0.980277803,0.94735989,0.935375654,0.838270206,0.806881011,0.759274415
699,699,699,4.3,"In two parts, the array itself, and it's size, so that the function it's being passed to can avoid out of bounds errors.",4,4,4,0.149700761,0.850299239,0.808978522,0.149981707,0.253984606,0.976275424,0.728744235,0.999905376,0.888427541,0.825211632,0.533475963,0.925923557,0.814615255,0.410433024,0.265096629
700,700,700,4.3,Specify array name without brackets. Array size is normally passed as another argument so the function can process the specific number of elements in the array. Arrays are passed by reference. Individual array elements passed by value. Functions that take arrays as arguments.,5,5,5,0.131216824,0.868783176,0.832564433,0.459072173,0.525256704,0.983316853,0.809252657,0.999838733,0.809848151,0.77034513,0.387032911,0.920018761,0.79983783,0.504643202,0.382530891
701,701,701,4.3,Arrays are passed by reference.,5,5,5,0.05469811,0.94530189,0.930204004,0.695956409,0.733157273,0.99425614,0.934327374,0.999916185,0.901173157,0.97898199,0.943901262,0.877631017,0.693757668,0.751703501,0.690494901
702,702,702,4.3,the same way but with [] at the declaration and the actual function.,3,3,3,0.155363917,0.844636083,0.801752209,0.299551696,0.38525415,0.985257392,0.831439873,0.999864602,0.840349941,0.914748839,0.77245788,0.930056036,0.824957255,0.523337007,0.405832972
703,703,703,4.3,specify the array name without brackets.,3,3,3,0.149711609,0.850288391,0.808964679,0.342216611,0.422698854,0.988823204,0.872209719,0.9998728,0.85001697,0.904105463,0.744049864,0.922958097,0.807193854,0.429122448,0.288393249
704,704,704,4.3,by reference,5,5,5,0.066319585,0.933680415,0.915374745,0.802811801,0.826938511,0.996143597,0.955907683,0.99995552,0.947553304,1,1,1,1,1,0.999999851
705,705,705,4.3,"You pass the name of the array to the function. So for: int bin [10]; you pass it to an array like so: jingle(bin); but jingle must be declared correctly in order to receive an array, either with prototype void jingle (int []); or with the definition in its initialization: void jingle (int array[]);  It's also worth noting that arrays are passed to function by reference, so as to not copy large arrays over and over and burn memory.  This gives the function complete control over the array however.",5,5,5,0.140442729,0.859557271,0.820791975,0.372671485,0.449427461,0.943821125,0.357676875,0.999890201,0.870534544,0.711178263,0.229111843,0.907264966,0.767920004,0.484463155,0.35737619
706,706,706,4.3,They are called by the function then the function must loop through the array to get the set of characters.,1,3,2,0.147524536,0.852475464,0.811755433,0.239357725,0.332425135,0.985195136,0.83072807,0.99981392,0.780591272,0.829427516,0.544728492,0.920859366,0.80194154,0.443808675,0.306699829
707,707,707,4.3,"by reference by default, unless you specify const, at which the later will make the array unmodifiable.",5,5,5,0.112021625,0.887978375,0.857057932,0.591091037,0.641122569,0.984536607,0.823198753,0.999906129,0.88931572,0.857887822,0.620691309,0.939669788,0.849016766,0.596103668,0.496537602
708,708,708,4.3,"The function recieves both the array and the array size as parameters. function(arrayName, arraySize)",4,4,4,0.171391964,0.828608036,0.781300067,0.206145868,0.303276872,0.983532427,0.811717435,0.999874542,0.852070431,0.896249127,0.723080679,0.925401174,0.813307932,0.405438036,0.258870308
709,709,709,4.3,specifying array name and passing as reference in an argument into the function,5,5,5,0.155314684,0.844685316,0.801815032,0.380381525,0.456194149,0.988063928,0.863528507,0.999907638,0.891094766,0.863030385,0.634417218,0.940241147,0.850446657,0.655862153,0.571027362
710,710,710,4.3,1st you must specify the array name without brackets and then the array name and size are passed as two arguments in the function call.,4,4,4,0.162462354,0.837537646,0.792694447,0.190209895,0.289290725,0.978975092,0.759610986,0.999859182,0.833959767,0.834401073,0.55800331,0.925274614,0.812991202,0.462890565,0.330485664
711,711,711,4.3,"arrays are passed by reference, passing the starting address of array. programmer specifies the array name without brackets and passes the array size as another argument so the function can process the specific number of elements in the array",5,5,5,0.15840596,0.84159404,0.797870496,0.302858621,0.388156461,0.977036768,0.737449091,0.999853521,0.827284903,0.813154805,0.501295334,0.926852149,0.816939163,0.529439569,0.413439898
712,712,712,4.3,by reference only,5,5,5,0.100285649,0.899714351,0.872033296,0.657952905,0.699803639,0.996596597,0.961087069,0.999954807,0.946712344,1,1,1,1,1,0.999999851
713,713,713,4.3,by reference,5,5,5,0.066319585,0.933680415,0.915374745,0.802811801,0.826938511,0.996143597,0.955907683,0.99995552,0.947553304,1,1,1,1,1,0.999999851
714,714,714,4.3,by reference,5,5,5,0.066319585,0.933680415,0.915374745,0.802811801,0.826938511,0.996143597,0.955907683,0.99995552,0.947553304,1,1,1,1,1,0.999999851
715,715,715,4.3,by refrence,5,5,5,0.164900243,0.835099757,0.789583646,0.410512716,0.482638677,0.996143597,0.955907683,0.999620153,0.552117194,0.999897562,0.999726585,0.918206246,0.795301805,0.698088348,0.623662887
716,716,716,4.3,"function( int [], int length)",4,4,4,0.181474745,0.818525255,0.768434216,0.106535383,0.2158541,0.974710194,0.710848121,0.999858425,0.83306687,0.934889776,0.826215641,0.890811857,0.726744223,0.331202507,0.166334716
717,717,717,4.3,by reference,5,5,5,0.066319585,0.933680415,0.915374745,0.802811801,0.826938511,0.996143597,0.955907683,0.99995552,0.947553304,1,1,1,1,1,0.999999851
718,718,718,4.3,by reference,5,5,5,0.066319585,0.933680415,0.915374745,0.802811801,0.826938511,0.996143597,0.955907683,0.99995552,0.947553304,1,1,1,1,1,0.999999851
719,719,719,4.3,"The function reads the variables, stores them. then returns the what ever the variable reads. The function then prints the content of the array. ",1,4,2.5,0.150035679,0.849964321,0.808551158,0.326881409,0.409239971,0.973463531,0.696594353,0.999876739,0.854661707,0.81450478,0.504898524,0.930301214,0.825570841,0.466286629,0.334718904
720,720,720,4.4,a static array will store the new values that were assigned to each of its elements. meaning if you call a function twice it will use the last values that were returned the first time.  if you don't declare it static then the new values will not be stored and will be reset to their original value,5,5,5,0.014407337,0.985592663,0.98161592,0.469175637,0.534123971,0.989563314,0.88067179,0.999980388,0.976875465,0.958008462,0.88792125,0.982644799,0.956566631,0.852844179,0.816568126
721,721,721,4.4,a static array can only be referenced not accessed. Also static arrays can be used without creating an object.,3,5,4,0.025081098,0.974918902,0.967995965,0.409509718,0.4817584,0.985000778,0.82850587,0.999976146,0.971873353,0.93812991,0.834863816,0.978249892,0.945567875,0.805076957,0.757025637
722,722,722,4.4,An array declared as static is not created and and initialized each time the function and it is also not destroyed when the function terminates.,5,5,5,0.011656702,0.988343298,0.985125791,0.642567694,0.686300866,0.990092769,0.88672533,0.999982532,0.979403257,0.976725364,0.937878148,0.981895438,0.954691269,0.85607928,0.820600725
723,723,723,4.4,"A program intializes static local arrays when their declarations are first encountered.  If a static array is not initialized explicityly by the programmer, earch element of that array is intialized to zero by the compiler when the array is created.  Non-static array members cannot be initialized at all in C++.",3,5,4,0.013538897,0.986461103,0.982724068,0.598630846,0.647739854,0.993148375,0.92166171,0.999985492,0.982893065,0.92516343,0.80025525,0.981149068,0.952823393,0.869722366,0.837607016
724,724,724,4.4,Arrays that are static remain the same size throughout the program execution.,3,5,4,0.012992322,0.987007678,0.98342151,0.457059562,0.523490343,0.98952763,0.880263793,0.999967838,0.962077086,0.934542584,0.825288957,0.966787562,0.916882087,0.843985438,0.805525587
725,725,725,4.4,"a static array will only be initilized once, a non static array will be re-initilized once the program reaches the initilization line again.",5,5,5,0.020113826,0.979886174,0.974334314,0.490371555,0.55272649,0.988328668,0.866555424,0.999974411,0.969827237,0.948872112,0.863535606,0.978329644,0.945767463,0.818739295,0.774055927
726,726,726,4.4,An array declared as static is available from beginning of program to end. One w/o static declaration disappears if it is not accessed within the right scope.,4,5,4.5,0.014071524,0.985928476,0.982044424,0.49112609,0.553388705,0.987944469,0.862162672,0.999973283,0.968498016,0.97736708,0.939590939,0.986562272,0.966370554,0.854458869,0.818580859
727,727,727,4.4,a static array has pre-runtime size and that size cannot be changed. A dynamic array gets its size at runtime.,1,5,3,0.019804955,0.980195046,0.974728441,0.332311183,0.414005392,0.987810817,0.860634548,0.999968848,0.963267807,0.95088028,0.868895566,0.981357464,0.953344928,0.75329715,0.692481407
728,728,728,4.4,"If an array is declared as static, it is not created each time the array is called.",5,5,5,0.010802567,0.989197433,0.986215686,0.705411673,0.74145565,0.989461387,0.879506403,0.999959248,0.951948781,0.948516451,0.862586318,0.962171763,0.905330524,0.774042487,0.71834075
729,729,729,4.4,"An array that is not declared as static will re-initialize every time the function declaring it is called. A static array will initialize only once, at the declaration, and will store the values in it's elements throughout the duration of the program, even if the same function is called multiple times, a static array will only initialize once.",5,5,5,0.005197525,0.994802475,0.993367843,0.77354151,0.801249548,0.993286665,0.923242849,0.999992927,0.991659945,0.963826825,0.903450923,0.976356618,0.940829741,0.913309515,0.891938987
730,730,730,4.4,"All elements are initialized to zero if not explicitly initialized, this does not happen for automatic local arrays  ",4,5,4.5,0.024899185,0.975100815,0.96822809,0.360919058,0.439112988,0.992578349,0.915144289,0.999974801,0.970287241,0.957552714,0.886704822,0.964974276,0.912344132,0.825471997,0.782448332
731,731,731,4.4,"All elements are initialized to zero if not explicitly initialized for a static array, while a non-static array is not initialized to zero.",4,5,4.5,0.023480237,0.976519764,0.9700387,0.416106463,0.487548008,0.993166037,0.921863647,0.99996029,0.953177006,0.926381913,0.803507478,0.967895539,0.919654926,0.699979842,0.626020659
732,732,732,4.4,static cannot be changed,1,5,3,0.059840918,0.940159082,0.923641667,0.103927068,0.213564923,0.972046506,0.680392751,0.999907435,0.890855856,0.834447274,0.558126625,0.976344955,0.940800553,0.474027961,0.34436858
733,733,733,4.4,"A static array has a set size that cannot change. The data may not need all of the space assigned, or could go beyond the size.",3,5,4,0.014166296,0.985833705,0.981923494,0.363853276,0.441688193,0.991661674,0.904663454,0.999959264,0.951967122,0.967271565,0.912645207,0.983933349,0.959791374,0.818434834,0.773676413
734,734,734,4.4,"A static member prevents naming conflicts (not put into global namespace) while allowing for information hiding (private, public).",1,5,3,0.030632794,0.969367206,0.960911878,0.24594903,0.33820997,0.986359062,0.844035862,0.999948375,0.939127732,0.966672609,0.911046546,0.984012963,0.959990617,0.77041316,0.713816745
735,735,735,4.4,A static local array exists for the duration of the program and its elements are initialized to 0 if not explicitly initialized. So a static local array's elements will still be the same when called later unless specifically initialized to something else.  This doesn't happen for automatic arrays.,5,5,5,0.013973713,0.986026287,0.982169234,0.564067662,0.617405604,0.990360597,0.889787553,0.99998751,0.985272297,0.960076724,0.893441605,0.976659459,0.941587635,0.887279332,0.859492011
736,736,736,4.4,"Static arrays are those with a declared size, that is known to the program, whereas non-static arrays leave the size undeclared and open so it can be assigned later. Usually used for input purposes. ",1,5,3,0.012213469,0.987786531,0.984415344,0.574657798,0.626699998,0.993742123,0.92845035,0.999979506,0.975834846,0.974074398,0.930802509,0.961283925,0.903108608,0.880339265,0.850841124
737,737,737,4.4,"static arrays keep the values after the end of a function, while non static reinitialize every time.",5,5,5,0.017190218,0.982809782,0.978064902,0.444503069,0.512470184,0.990196774,0.887914479,0.999971256,0.966106992,0.974018755,0.930653993,0.978681611,0.946648301,0.840462625,0.801134352
738,738,738,4.4,"Static arrays are created and initialized only once, and the values aren't destroyed  when the function terminates in the program. Automatic arrays reset everytime the function is called.",5,5,5,0.009993255,0.990006745,0.987248386,0.654135346,0.696453173,0.992206345,0.910890975,0.999984715,0.9819776,0.949124716,0.864209826,0.980866665,0.952116648,0.881731987,0.852577171
739,739,739,4.4,"its not created and initialized each time program calls the function, and is not destroyed every time the function ends in the program.",5,5,5,0.015858114,0.984141886,0.979764696,0.481121153,0.544607909,0.9938986,0.930239425,0.999975735,0.971388951,0.972201819,0.925804447,0.963624105,0.908965175,0.890463412,0.86346101
740,740,740,4.4,"When we declare it static the array is not destroyed after the function is over.  When an array is not declared as static, the array is created and initialized every time a function calls it.",5,5,5,0.00808686,0.99191314,0.989680988,0.780956149,0.807756979,0.993507595,0.925768856,0.999983476,0.980515976,0.974216525,0.931181857,0.961125148,0.90271125,0.880119145,0.850566741
741,741,741,4.4,the static array exists for the duration of the program,4,5,4.5,0.027330816,0.972669184,0.965125275,0.331208646,0.413037755,0.987195389,0.853598032,0.999972598,0.967689627,0.914484929,0.771753483,0.971916398,0.929717584,0.744532466,0.681556109
742,742,742,4.4,an array declared as static can only be declared once,2,5,3.5,0.028298438,0.971701562,0.963890568,0.548958063,0.604144721,0.98051593,0.777228203,0.999976278,0.972028798,0.962428992,0.899719995,0.968347856,0.920786901,0.824906886,0.781743912
743,743,743,4.4,"A static array exists in memory until the program terminates, whereas an automatic (or normal) array is removed when the function that created it terminates",5,5,5,0.013886631,0.98611337,0.982280353,0.548698068,0.603916537,0.991843605,0.906743573,0.999985445,0.982837548,0.982492828,0.953271967,0.971165652,0.927838756,0.864090323,0.830586598
744,744,744,4.4,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
745,745,745,4.4,Only constants can be used to declare the size of automatic and static arrays Exists for the duration of the program Is initialized when its declaration is first encountered All elements are initialized to zero if not explicitly initialized,5,5,5,0.01319474,0.98680526,0.983163221,0.523919046,0.582169321,0.99054865,0.891937663,0.999972261,0.967293035,0.947616617,0.86018459,0.956164753,0.890297296,0.897092998,0.871724879
746,746,746,4.4,A static array cannot be changed in the program.,1,5,3,0.01987499,0.98012501,0.974639074,0.390672118,0.465225649,0.985040974,0.82896545,0.99993005,0.917521234,0.902820234,0.740619486,0.951329542,0.87819663,0.756830812,0.696886164
747,747,747,4.4,static arrays are available throughout the program,5,5,5,0.046451867,0.953548133,0.940726392,0.442471951,0.510687581,0.985631617,0.835718588,0.999968272,0.96258956,0.922413858,0.792916424,0.953854763,0.884516283,0.803493321,0.755051614
748,748,748,4.4,"a static array is allocated when the program starts and is freed when the program exits but has limited scope, while an array that is not declared static is allocated and freed when it comes into and out of scope.",5,5,5,0.009386063,0.990613937,0.988023177,0.56303829,0.616502179,0.994290211,0.934716925,0.999985019,0.98233543,0.970894726,0.922315712,0.96892872,0.922240579,0.811206698,0.764666443
749,749,749,4.4,"if they are declared fixed or static that means they can't change size once their storage has been allocated, however one that is not or dynamic arrarys can be resized.   ",1,5,3,0.017051816,0.982948184,0.978241506,0.500872612,0.561942704,0.990194789,0.887891784,0.999976834,0.972684624,0.963088317,0.901479786,0.976460433,0.94108955,0.776432693,0.721320174
750,750,750,4.5,"at least 2, depending on how many arrays are being used.",1,4,2.5,0.035372555,0.964627445,0.954863838,0.273927629,0.362765283,0.989664722,0.881831236,0.999961943,0.955125966,0.923545152,0.795935938,0.924099461,0.810050247,0.597027421,0.497689072
751,751,751,4.5,all of them.,2,5,3.5,0.054656565,0.945343435,0.930257015,0.44297418,0.51112836,0.982031455,0.794556018,0.999925913,0.91264259,0.920919732,0.788928483,0.944168473,0.860275238,0.783888221,0.730613591
752,752,752,4.5,"When passing a multi-dimensional array, all dimensions must be specified except for the first dimension.",5,5,5,0.025122344,0.974877656,0.967943333,0.63108027,0.67621897,0.992583313,0.915201048,0.999962438,0.955710125,0.95284918,0.874150716,0.930962953,0.827226918,0.775365949,0.719990463
753,753,753,4.5,It depends what parameters you are passing in a multidimensional.  A multideminsional can have more than two dimensions.,2,5,3.5,0.038877666,0.961122334,0.950391239,0.386142105,0.461249901,0.990016697,0.885855556,0.999957532,0.949925865,0.936698407,0.83104302,0.931010505,0.827345923,0.71622628,0.646272065
754,754,754,4.5,The first dimension is not required however the subsequent dimension(s) are needed for the compiler.,5,5,5,0.031775832,0.968224168,0.959453336,0.423512429,0.494047827,0.994921071,0.941929887,0.999950454,0.941579349,0.94234021,0.846101441,0.933040721,0.83242677,0.679473042,0.600458656
755,755,755,4.5,all but the first,5,5,5,0.056272328,0.943727672,0.928195266,0.485456377,0.548412703,0.975404698,0.718788764,0.99993229,0.920162207,0.888748684,0.703061401,0.927681709,0.819015231,0.747688591,0.685490262
756,756,756,4.5,All of the dimensions must be specified.,2,5,3.5,0.035638273,0.964361727,0.954524777,0.516887128,0.575997784,0.992468651,0.913890057,0.999968476,0.962829439,0.89181611,0.711248605,0.927772125,0.819241508,0.706126153,0.63368212
757,757,757,4.5,just the first one at least.,1,3,2,0.025235951,0.974764049,0.967798369,0.52074343,0.579382253,0.981358688,0.786863912,0.999947777,0.938422839,0.931477105,0.817106951,0.92264941,0.806421329,0.877591252,0.847415689
758,758,758,4.5,"Two paramaters, the array and how many columns.  array(a[],[3])",4,4,4,0.062045217,0.937954783,0.920828933,0.253347248,0.344702988,0.992105511,0.909738087,0.99994679,0.937258943,0.913307488,0.7686108,0.927215175,0.817847677,0.562484026,0.454630262
759,759,759,4.5,"The size of the first dimension can be omitted, same as a regular array. However, for every dimension outside the first, the size of those dimensions must be specified when passed, for example, a multi-dimensional array of [2][4][6] with the name MultiArray would be passed as: ""MultiArray[][4][6], 2""",4,5,4.5,0.044058144,0.955941856,0.943780835,0.335816771,0.417082058,0.984092131,0.818116829,0.999942317,0.931985136,0.922483455,0.793102184,0.922554393,0.806183538,0.746199846,0.683634521
760,760,760,4.5,Size of subsequent dimensions are required. Compiler must know how many elements to skip to move to the second element in the first dimension,4,5,4.5,0.037138283,0.962861717,0.95261073,0.392753571,0.46705243,0.992425284,0.913394224,0.999963391,0.956833563,0.943630595,0.849545581,0.933046186,0.832440447,0.659093142,0.575054834
761,761,761,4.5,Every dimension after the first.,5,5,5,0.030055344,0.969944656,0.961648717,0.597107709,0.646403078,0.98158798,0.789485531,0.99993211,0.919950531,0.9296663,0.812273768,0.90546466,0.763414533,0.786980391,0.734468022
762,762,762,4.5,both,2,3,2.5,0.238494873,0.761505127,0.695675273,0.193241417,0.29195133,0.966186142,0.613388079,0.999501501,0.412213697,0.888981464,0.703682709,0.904085627,0.759963346,0.494067848,0.369348569
763,763,763,4.5,"the size of the first dimension does not need to be specified, but all other dimensions do.",5,5,5,0.022492826,0.977507174,0.971298657,0.501126945,0.562165918,0.988433715,0.867756483,0.999849788,0.822883002,0.947950343,0.861075331,0.917097899,0.79252804,0.581522465,0.478361934
764,764,764,4.5,"when passing (in main) a multidimensional array to a function, no dimensions need be specified",1,3,2,0.052564859,0.947435141,0.932926078,0.188642725,0.287915305,0.990066237,0.886421974,0.999959036,0.951698224,0.887200151,0.698928243,0.75814168,0.394721978,0.460291475,0.327245863
765,765,765,4.5,"All dimensions except for the first one need to be specified when passing an array to a function, the compiler needs to know how many memory addresses to skip to make it back to the 2nd element in the first dimension.  The size of the first dimension does not need to be specified.",5,5,5,0.026752472,0.973247528,0.965863255,0.520108879,0.578825342,0.990720466,0.893902126,0.999931998,0.919818037,0.940936628,0.842355169,0.94382433,0.859413981,0.800647497,0.751504256
766,766,766,4.5,as many as there are dimensions. Most commonly just rows and columns,2,5,3.5,0.038854599,0.961145401,0.950420673,0.362590522,0.440579941,0.99112046,0.898475474,0.999964313,0.957921465,0.92982036,0.812684967,0.923820728,0.809352686,0.578158438,0.47416863
767,767,767,4.5,"at least 2, but it should always equal the number of dimensions that the argument is expecting... like...  blah[][][][] will require 4 dimensional array input. blah[][][] will require a 3 dimensional array. blah[][] will require a 2 dimensional array.",1,5,3,0.066727936,0.933272064,0.914853679,0.261989176,0.352287544,0.973235481,0.693986946,0.999654885,0.593070826,0.882055819,0.685197613,0.929625957,0.823880933,0.665017784,0.58243998
768,768,768,4.5,"None, just pass the array name.",1,3,2,0.042016447,0.957983553,0.946386086,0.368957639,0.446168018,0.993273797,0.923095727,0.999933255,0.921300002,0.930879487,0.815511861,0.929984287,0.824777695,0.607474566,0.510711579
769,769,769,4.5,all subsequent dimensions after the first dimension.  first is not needed to be specified.,5,5,5,0.020851195,0.979148805,0.973393415,0.562512755,0.616040946,0.98848215,0.868310262,0.999959637,0.952407861,0.939947946,0.839716298,0.924901876,0.812058382,0.734814644,0.669442712
770,770,770,4.5,"all dimensions, excluding the first one.",5,5,5,0.014119446,0.985880554,0.981983275,0.747593701,0.77847655,0.991897545,0.907360294,0.999984354,0.981552083,0.984032436,0.957381303,0.935856679,0.839474026,0.918637395,0.898580262
771,771,771,4.5,all dimensions but the first,5,5,5,0.043555856,0.956444144,0.944421766,0.592780471,0.642605294,0.987878828,0.861412163,0.999977581,0.973565738,0.888748684,0.703061401,0.927681709,0.819015231,0.747688591,0.685490262
772,772,772,4.5,the first needs to be specified by size and the rest need only be stated( first like this [3] then [][][]),1,5,3,0.059649348,0.940350652,0.923886114,0.199250534,0.297225209,0.986290171,0.843248189,0.999858579,0.833248172,0.95634046,0.88346922,0.936149238,0.840206188,0.78625381,0.73356233
773,773,773,4.5,one less than the number of dimensions the array contains,4,5,4.5,0.04415679,0.95584321,0.943654961,0.326957524,0.409306773,0.98210381,0.795383294,0.999957682,0.950102806,0.939230162,0.837800475,0.92554207,0.813660541,0.733330965,0.667593287
774,774,774,4.5,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
775,775,775,4.5,one,1,3,2,0.160912514,0.839087486,0.794672077,0.313976198,0.397913761,0.962290641,0.568848738,0.999689145,0.633466664,0.982113953,0.95226072,0.919953975,0.799675696,0.402240932,0.254885075
776,776,776,4.5,All subsequent dimensions after the first one.,5,5,5,0.016156316,0.983843684,0.979384184,0.70361203,0.7398762,0.987545819,0.857604691,0.999965969,0.959873046,0.93893318,0.837007807,0.962849134,0.907025722,0.904107094,0.880468045
777,777,777,4.5,two or more,1,4,2.5,0.12651962,0.87348038,0.838558169,0.153495535,0.257068504,0.972602691,0.686751915,0.999830509,0.800151477,0.888692446,0.702911297,0.906618203,0.766301406,0.617885947,0.523689508
778,778,778,4.5,1 less than the total number of dimensions,4,5,4.5,0.062065899,0.937934101,0.920802541,0.266530573,0.356273285,0.980932865,0.781995251,0.999908196,0.891753119,0.958054127,0.888043133,0.91869443,0.796523541,0.642054617,0.553816083
779,779,779,4.5,"Multi dimensional arrays are accessed using more than 1  index, one for each dimension at least. ",2,5,3.5,0.038857996,0.961142004,0.950416338,0.410076827,0.48225612,0.993048655,0.920521557,0.999964253,0.957850116,0.957625607,0.886899379,0.9335051,0.833588931,0.623217642,0.530335538
780,780,840,5.1,"Takes an element of an array and compares it with the next element, depending on the values of the two elements they will switch and then the program will compare the new switched element with the next one in the array.",1,5,3,0.015623748,0.984376252,0.980063752,0.481111646,0.544599565,0.99495663,0.942336452,0.999955935,0.948042392,0.939471134,0.838443649,0.98241246,0.955985176,0.862814963,0.828996844
781,781,841,5.1,"Insertion sort divides the list into sorted and unsorted regions, then takes each item from the unsorted region and inserts it into its correct order in the sorted region.",5,5,5,0.023081601,0.976918399,0.970547368,0.384882122,0.460144082,0.993823496,0.929380728,0.999973443,0.96868659,0.955429254,0.881037139,0.990141822,0.975328786,0.801616549,0.752712193
782,782,842,5.1,The sorted array or list is built one entry at a time.,3,4,3.5,0.022954166,0.977045834,0.970709977,0.36927855,0.446449665,0.989484929,0.879775574,0.999957529,0.949922057,0.947602003,0.860145584,0.965966189,0.914826508,0.83569324,0.795189249
783,783,843,5.1,It starts with the second element and checks it to see if it is less than the element(s) to the left of it and if it is it inserts it into its corrected position.,5,5,5,0.013369858,0.986630142,0.982939765,0.490435839,0.552782908,0.990099163,0.886798432,0.999966449,0.960439259,0.965631981,0.908269027,0.979588346,0.948917509,0.91428268,0.89315205
784,784,844,5.1,Compare two numbers at a time and swap until the entire list is sorted.,1,3,2,0.022979558,0.977020443,0.970677577,0.273262203,0.362181274,0.988279008,0.86598763,0.999970249,0.964919876,0.950219609,0.867132182,0.976286084,0.940653221,0.821490943,0.777485894
785,785,845,5.1,"Assume the first number is sorted, then move down the list and 'insert' the numbers you come across into the corresponding place on the sorted side of the list.",5,5,5,0.017649174,0.982350826,0.977479264,0.279390335,0.367559607,0.989634575,0.881486557,0.999969165,0.963641593,0.965382513,0.907603178,0.98361158,0.95898611,0.877780139,0.847651139
786,786,846,5.1,insertion sort is were after k iterations the first k items in the array are sorted it take the k+1 item and inserts it into the correct position in the already sorted k elements.,5,4,4.5,0.017204344,0.982795656,0.978046877,0.47321403,0.537668252,0.988735507,0.871207022,0.999967163,0.961280873,0.961346891,0.896831782,0.979623877,0.949006429,0.857097507,0.821869957
787,787,847,5.1,Looking at the 2nd element move forward and place the element in the correct spot.,4,5,4.5,0.017644465,0.982355535,0.977485273,0.453528076,0.520390948,0.992257475,0.911475568,0.999962017,0.955213634,0.953580881,0.876103684,0.982398682,0.955950695,0.873977244,0.842910779
788,788,848,5.1,"Starting at the beginning of an array, take each element in order and place it in it's correct position relative to all previously sorted elements. ",5,5,5,0.011802256,0.988197744,0.984940061,0.612484634,0.65989858,0.994875508,0.941408943,0.999971708,0.966641025,0.966192966,0.909766341,0.986720564,0.966766697,0.916995943,0.896534169
789,789,849,5.1,To sort the elements in an array by removing an element from the input data and inserting it at the correct position.,5,5,5,0.016002357,0.983997643,0.979580639,0.57879895,0.630334464,0.993346167,0.923923163,0.999986813,0.984450426,0.944980745,0.853149238,0.985997946,0.964958263,0.854991972,0.819245381
790,790,850,5.1,"Insertion sort removes an element from the data, and inserts it at the correct position in the already sorted list.",5,5,5,0.014541209,0.985458791,0.981445096,0.565161884,0.618365944,0.994833958,0.940933874,0.999977697,0.973702114,0.953863334,0.876857574,0.980101953,0.950202869,0.866186321,0.833199287
791,791,851,5.1,Take a number and choose a pivot point and insert the number in the correct position from the pivot point.,2,4,3,0.032601595,0.967398405,0.958399645,0.345508784,0.425588218,0.990109005,0.886910965,0.99997678,0.972620602,0.952329772,0.872764375,0.98315621,0.957846495,0.839681149,0.800160231
792,792,852,5.1,have a marker and sort everything to the left of the value for every new value when moving to the right.,3,3,3,0.018440068,0.981559932,0.976470066,0.357875556,0.436441869,0.990229876,0.888292947,0.999974973,0.970490619,0.951910037,0.871644069,0.966122738,0.915218289,0.854294181,0.818375574
793,793,853,5.1,The main idea behind insertion sort is to take a random variable from the right and insert it in order to the left.,4,5,4.5,0.009821177,0.990178824,0.987467962,0.50476712,0.565360704,0.991821451,0.906490277,0.999975349,0.970933554,0.951163504,0.869651513,0.988009164,0.969991566,0.913097918,0.891675229
794,794,854,5.1,Insertion sort progresses through a list of elements and determines where the next element should be inserted into an already sorted array starting with sorting and using the first two elements.,5,4,4.5,0.016855478,0.983144522,0.978492037,0.524655759,0.582815895,0.990781466,0.894599575,0.99997373,0.969024301,0.966963036,0.911821719,0.980250628,0.950574945,0.901173174,0.876810874
795,795,855,5.1,"it goes through the list only once, picking each integer and putting it in its desired position, then continuing. ",4,4,4,0.013030171,0.986969829,0.983373213,0.362658441,0.44063955,0.993549208,0.926244649,0.999980317,0.976791941,0.944806163,0.852683265,0.981851407,0.954581077,0.826063514,0.783185665
796,796,856,5.1,Inserting array items in to their appropriate positions from smallest to largest at a pivot which starts on the second element of the array.,3,4,3.5,0.016446054,0.983553946,0.979014472,0.501242697,0.562267508,0.991929283,0.90772318,0.999985222,0.982575267,0.962073183,0.898770313,0.977477496,0.943634866,0.859081566,0.824343115
797,797,857,5.1,Insert the item into its proper position by shifting larger sorted array values to the right.,1,5,3,0.014796078,0.985203922,0.981119877,0.504535377,0.565157316,0.99035379,0.889709721,0.999962293,0.955539285,0.951560284,0.87071055,0.990110394,0.975250133,0.909871876,0.887653924
798,798,858,5.1,a comparison sort in which the sorted array is built one entry at a time,4,4,4,0.021587551,0.978412449,0.972453809,0.332541585,0.414207604,0.991299478,0.900522276,0.999966943,0.961021936,0.934643868,0.825559293,0.965017943,0.912453414,0.7923733,0.741190356
799,799,859,5.1,"Insertion sort is an algorithm where the first element of the array is in the sorted list, all the other pick one by one and taken from the unsorted array, to the sorted array.",5,4,4.5,0.013124108,0.986875892,0.983253348,0.476027072,0.540137107,0.988797515,0.871916001,0.999977074,0.972968162,0.951194991,0.869735554,0.982538776,0.956301296,0.842734039,0.8039657
800,800,860,5.1,"Every iteration of an insertion sort takes away an element from the input data, inserting it at the right position in the sorted list.",5,5,5,0.012845159,0.987154841,0.983609294,0.578800201,0.630335563,0.994700274,0.939405396,0.999979158,0.975424896,0.95829819,0.888694557,0.980964919,0.952362539,0.911691308,0.88992187
801,801,861,5.1,the insertion sort creates a new array and inserts each item in its place with respect to the new array.,4,4,4,0.021005213,0.978994787,0.973196884,0.402845085,0.475909209,0.990718066,0.893874687,0.999971169,0.966004981,0.945438833,0.854371912,0.986357731,0.965858666,0.809200346,0.762165498
802,802,862,5.1,"Insertion sort takes each entitity of an unsorted array in order, and sorts it into the correct position between the entities it has sorted.",5,5,5,0.015318513,0.984681487,0.980453239,0.468551934,0.533576581,0.99532059,0.946497804,0.999978581,0.974745091,0.95544895,0.881089709,0.986206817,0.965480987,0.84607929,0.808135601
803,803,863,5.1,"it takes the second element and swaps it with the 1st if it is less and keeps it there if its larger, then it goes to the third element and inserts it in the right places with respect to the first 2 elements and so on... ",5,5,5,0.012379885,0.987620115,0.984202994,0.488630474,0.551198436,0.989593589,0.881017938,0.999964617,0.958279576,0.970001708,0.919932176,0.983163926,0.957865805,0.911189616,0.889296504
804,804,864,5.1,"Starting with the first element in the array, each following element is put in place by determining if it is smaller or larger than the starting element.",3,5,4,0.017207205,0.982792795,0.978043226,0.466147304,0.531466166,0.989376874,0.878540119,0.999988394,0.986314657,0.945842597,0.85544959,0.986051138,0.965091382,0.868191957,0.835699341
805,805,865,5.1,"one by one, each item is taken and placed into the correct place in the sorted portion of the array until there are no more items",5,4,4.5,0.014677286,0.985322714,0.981271459,0.414564967,0.48619512,0.989715719,0.882414313,0.99997627,0.972019523,0.959230499,0.891182964,0.983233294,0.958039407,0.870790064,0.838937916
806,806,866,5.1,you take each element and insert it in the correct position with respect to all the elements before it,5,5,5,0.015642226,0.984357774,0.980040174,0.549111664,0.604279529,0.986721287,0.848177369,0.999957214,0.949549893,0.952106988,0.872169747,0.980307952,0.950718405,0.871989787,0.840433386
807,807,867,5.1,"Insertion sort is a simple sorting algorithm, a comparison sort in which the sorted array (or list) is built one entry at a time.",4,4,4,0.018904805,0.981095195,0.975877051,0.312244386,0.396393842,0.992369155,0.912752468,0.999964866,0.958573432,0.951160071,0.86964235,0.984792989,0.961942721,0.798330426,0.748615995
808,808,868,5.2,Searches an array for the largest or the smallest element and is moved out to the front of the array then it will search for the next largest or the smallest element to move out to the front,5,5,5,0.013600945,0.986399055,0.982644893,0.38450256,0.45981096,0.989603909,0.88113593,0.999930054,0.917526042,0.964405282,0.90499487,0.970566562,0.926339465,0.839741409,0.800235346
809,809,869,5.2,"Selection sort searches the whole array for the largest item and puts it at the end of the array, then searches for the second largest item and puts it at the second to last spot and so on.",5,4,4.5,0.014038324,0.985961676,0.982086788,0.363949299,0.441772467,0.992640771,0.915857994,0.99993948,0.928639651,0.948986506,0.863840933,0.981914226,0.954738288,0.832366705,0.791042678
810,810,870,5.2,Finds the minimum value and swap it with the value in the first position.,5,5,5,0.015821397,0.984178603,0.979811548,0.331972361,0.413708026,0.992199937,0.910817708,0.9999717,0.966631079,0.951112341,0.869514955,0.979128027,0.947765508,0.781143904,0.727192762
811,811,871,5.2,It finds the minimum element in the array and swaps it with the first element then repeats this step swapping the minimum element with nth positions in the array.,5,5,5,0.012692451,0.987307549,0.983804152,0.709085047,0.744679573,0.992287921,0.911823681,0.999968568,0.962937764,0.969107049,0.91754426,0.987858034,0.969613346,0.919686675,0.899888204
812,812,872,5.2,"Find the lowest value and place it at the front, then find the next lowest and place it in front of the last value, etc.",4,5,4.5,0.016057551,0.983942449,0.97951021,0.226866379,0.321462152,0.996082511,0.95520925,0.999966877,0.960944544,0.957333615,0.886120029,0.969300523,0.923171059,0.776155472,0.720974614
813,813,873,5.2,"Cycle through the unsorted list, place the minimum in the next slot in the sorted list, and repeat.",5,4,4.5,0.02715385,0.97284615,0.965351088,0.328613758,0.410760361,0.989007881,0.874321222,0.999960587,0.953527535,0.961448527,0.897103056,0.981649091,0.954074758,0.801792085,0.752931
814,814,874,5.2,find the minimum value in the list swap it with the first element in the list the find the second largest and swap it with the second element in the array continue like this until  the array is sorted.,5,5,5,0.014653564,0.985346437,0.981301729,0.55682826,0.61105197,0.989449697,0.879372745,0.999871698,0.848717949,0.961085392,0.89613382,0.985572229,0.963892858,0.870301306,0.838328672
815,815,875,5.2,Find the smallest and put it in the current position till you get to the end.,5,5,5,0.020424724,0.979575276,0.973937601,0.262321919,0.352579575,0.991525663,0.903108372,0.999972246,0.967274735,0.950903808,0.868958364,0.979593575,0.948930595,0.805608451,0.757688152
816,816,876,5.2,"Find the lowest unsorted value in the array and place it at the current position (starting at the first element in the array) and advance the ""current"" position by one. ",5,5,5,0.015137076,0.984862924,0.980684756,0.467803478,0.532919701,0.995719288,0.951056334,0.999968619,0.962998285,0.957767508,0.887278124,0.984380482,0.960910375,0.886420667,0.858421674
817,817,877,5.2,To sort the elements by comparing two elements and swapping the smaller one to sort the elements in the array.,2,5,3.5,0.013248324,0.986751676,0.983094845,0.587200046,0.637707655,0.99108829,0.898107654,0.999961755,0.954904575,0.946437186,0.857036595,0.98793555,0.969807338,0.838879764,0.799161294
818,818,878,5.2,"Selection sort finds the minimum value in the list, swaps it with the first value in the list, and repeats throughout the list.",5,4,4.5,0.018985808,0.981014192,0.97577369,0.36353597,0.441409711,0.994400149,0.935973914,0.999970336,0.965022381,0.957333259,0.886119079,0.976342163,0.940793565,0.792817831,0.741744471
819,819,879,5.2,"Select the minimum number from the array and put it in the current position, then move on",5,5,5,0.013205886,0.986794114,0.983148998,0.464656264,0.53015756,0.994933761,0.942074976,0.999917442,0.902654763,0.965484565,0.907875562,0.969585609,0.923884519,0.846332312,0.808450996
820,820,880,5.2,Find the lowest value and place it in the front of the list and swap it with that value. Continue moving right.,5,5,5,0.015887141,0.984112859,0.979727657,0.350900561,0.43032029,0.993126356,0.921409956,0.999972285,0.967320574,0.965581601,0.908134559,0.979046813,0.94756226,0.830142975,0.788270768
821,821,881,5.2,The main idea behind selection sort is to take the least variable from the right and put it directly to the left.,5,4,4.5,0.011749268,0.988250732,0.985007675,0.441262454,0.50962607,0.991016344,0.89728506,0.999981312,0.977964293,0.954456357,0.878440399,0.985677053,0.964155192,0.810212255,0.763426855
822,822,882,5.2,"Find the smallest value in the list and make it the first element, then find the smallest value of the leftover list and make it the first element of the leftover list and continue until the list is sorted.",5,5,5,0.015453458,0.984546542,0.980281046,0.372012198,0.44884884,0.987298278,0.854774421,0.999892977,0.873807827,0.948832391,0.863429587,0.976288434,0.940659103,0.829963326,0.788046834
823,823,883,5.2,It runs through and finds the lowest (or highest) value and puts it in its desired position.,5,4,4.5,0.024726868,0.975273132,0.968447971,0.255893797,0.346937957,0.992825641,0.917971721,0.99996026,0.953142322,0.952990589,0.874528148,0.986076279,0.965154301,0.766387582,0.708798807
824,824,884,5.2,"Places the smallest item in the list at position 1, and then proceeds to each value until the last position of the ray is reached.",5,5,5,0.013888836,0.986111164,0.982277539,0.284879059,0.372376765,0.995183818,0.944934014,0.999986856,0.984501672,0.957910496,0.887659771,0.974971911,0.937364354,0.829967558,0.788052109
825,825,885,5.2,Search for the largest item in an array and swap it with the last unsorted item.,5,4,4.5,0.020503461,0.979496539,0.97383713,0.353370041,0.43248762,0.991253683,0.899998676,0.999948193,0.938913559,0.957861974,0.887530262,0.97985382,0.949581888,0.845392823,0.807279911
826,826,886,5.2,finds the smallest element and places in 1st position. then the process is repeated on the rest of the array.,5,5,5,0.014454186,0.985545814,0.981556139,0.42316851,0.493745988,0.991895563,0.907337641,0.999981302,0.977952535,0.964104708,0.904192615,0.988147583,0.970337975,0.874250412,0.843251286
827,827,887,5.2,Selection sort is an algorithm that selects the larges item the array and puts it in its place; then select the next largest until the array is sorted,5,4,4.5,0.018813193,0.981186807,0.97599395,0.32257086,0.405456834,0.994355916,0.935468164,0.999983819,0.980920437,0.96902407,0.917322782,0.988528033,0.971290095,0.8105762,0.763880519
828,828,888,5.2,Select the smallest number in the list and move it to the front of the list and then advance to the next number.,5,5,5,0.017888129,0.982111871,0.977174352,0.293344617,0.37980653,0.992142412,0.910159991,0.999955258,0.947243729,0.959627416,0.892242367,0.968715468,0.921706892,0.770591319,0.714038822
829,829,889,5.2,the selection sort chooses the largest or smallest value in an unsorted list and creates a new list using the selection depending on how it is sorted.,5,4,4.5,0.017014205,0.982985795,0.978289498,0.229742795,0.323986628,0.992475341,0.913966545,0.999977346,0.973288616,0.955856787,0.882178258,0.984318431,0.960755086,0.794000745,0.743218989
830,830,890,5.2,"Selection sort finds the smallest number left unsorted in an array, and puts it at the end of what it has sorted",4,5,4.5,0.013435483,0.986564517,0.982856027,0.347205579,0.427077404,0.995650409,0.950268805,0.999978123,0.974204648,0.96043761,0.894404839,0.991822452,0.979534754,0.840605736,0.801312742
831,831,891,5.2,"selects the minimum from the remaining elements of the array, and palces the miminum in the current position and moves to the next position",5,5,5,0.013002634,0.986997366,0.983408352,0.580187798,0.631553381,0.99419972,0.933682302,0.999972444,0.9675087,0.968600279,0.916191651,0.987026678,0.967532783,0.900004387,0.875353965
832,832,892,5.2,"To put the biggest element at the end of the list and place the next highest element behind it, and so on.",3,4,3.5,0.01636219,0.98363781,0.979121484,0.479126543,0.542857347,0.994401733,0.935992017,0.999965114,0.958865281,0.965331478,0.907466961,0.959313434,0.89817723,0.832196116,0.790830037
833,833,893,5.2,"the sort finds the largest item and places it at the end, then then next largest is found and placed next to last, continue until there is only one number left, this is the beginning of the sorted array",5,4,4.5,0.015643835,0.984356165,0.980038121,0.284033567,0.371634722,0.992881605,0.91861158,0.999946166,0.936523125,0.95979085,0.892678585,0.954823923,0.886941716,0.819558859,0.775077524
834,834,894,5.2,"you loop through the entire list, and for each iteration you find the smallest element and move it to the current position.",5,5,5,0.011049986,0.988950014,0.985899974,0.468127608,0.533204173,0.98253756,0.800342583,0.999975449,0.971051121,0.968444015,0.91577457,0.986381414,0.965917936,0.874421656,0.843464744
835,835,895,5.2,Find the minimum value in the list swap it with the value in the first position; repeat the steps above for remainder of the list(starting in the second position.,5,5,5,0.017923951,0.982076049,0.977128642,0.366648614,0.444141511,0.992022116,0.908784585,0.999968649,0.963033951,0.962927797,0.901051346,0.979400979,0.948448601,0.832725406,0.791489803
836,836,896,5.3,"The run time for this sorting program is n^2.  Best case is the list is already sorted, worst case is the list is sorted but in reverse. ",4,3,3.5,0.032769978,0.967230022,0.958184784,0.308363795,0.392988056,0.984804347,0.826259975,0.999963611,0.957093672,0.947126005,0.858875108,0.978435296,0.946031869,0.771919608,0.715694553
837,837,897,5.3,"Insertion sort is O(n) and performs n-1 operations in the best-case scenario, which is when the list or array is already sorted.",5,4,4.5,0.019453168,0.980546832,0.975177328,0.545034111,0.600700879,0.99183682,0.906665992,0.999979724,0.976092495,0.970397455,0.920988456,0.982392239,0.95593457,0.834338605,0.793500679
838,838,898,5.3,"The number of operations for insertions sort, under best-case, is  n(n-1)/2. The best case for insertion sort is on a sorted list where it runs is O(n). ",3,3,3,0.016328454,0.983671546,0.979164532,0.564256847,0.617571642,0.98594366,0.839286351,0.999971324,0.966188059,0.954981638,0.879842416,0.980257776,0.950592833,0.735022783,0.669702161
839,839,899,5.3,"Best case would be O(n) or n-1, because that's what it takes to scan the array and make one swap. The array would then be sorted and would take only 1 operation.",4,4,4,0.031140029,0.968859971,0.960264635,0.489047825,0.551564724,0.991304209,0.900576368,0.999957451,0.949829844,0.914661844,0.772225683,0.972931777,0.932258686,0.762725115,0.704233492
840,840,900,5.3,Best case-1 Worst Case-N,0,4,2,0.255855441,0.744144559,0.673522805,-0.019212814,0.105491663,0.982943597,0.804985018,0.999707282,0.654852839,0.940458026,0.841077742,0.976491438,0.941167143,0.441011727,0.303213396
841,841,901,5.3,It will do (n) operations where (n) is the number of elements in the array. Best case is when all the elements are already sorted.,5,5,5,0.019546926,0.980453074,0.975057691,0.605852902,0.654078265,0.988779123,0.871705707,0.999978158,0.974245326,0.974159537,0.931029752,0.978928389,0.947265891,0.825835168,0.782901029
842,842,902,5.3,O(n),3,4,3.5,0.119796097,0.880203903,0.847137533,0.271219492,0.360388497,0.981725154,0.791053914,0.999882754,0.861753901,0.910753436,0.761793832,0.91695524,0.79217102,0.480024546,0.351843404
843,843,903,5.3,Best case is all elements sorted. n-1.,5,3,4,0.051891625,0.948108375,0.93378514,0.396471441,0.470315404,0.985631909,0.835721927,0.999928409,0.915585537,0.946870672,0.858193604,0.975197688,0.937929386,0.737812042,0.67317901
844,844,904,5.3,"The best case scenario for an insertion sort, where all the elements of the array have been already sorted, will cause the for loop to iterate ""x"" times (""x"" being the number of elements in the array) and the while loop to never have to iterate, resulting in the insertion sort to require ""x"" operations. ",5,5,5,0.022772372,0.977227628,0.970941951,0.478665084,0.542452349,0.987881382,0.861441358,0.999968993,0.963439169,0.902101174,0.738700257,0.981896366,0.954693592,0.818340123,0.773558353
845,845,905,5.3,1 operation. the best case scenario s where it is already sorted and does one comparision.,3,3,3,0.038547337,0.961452663,0.950812746,0.345081568,0.425213273,0.979015379,0.760071605,0.999964579,0.958234273,0.972062459,0.925432484,0.981159028,0.952848319,0.70085305,0.627109125
846,846,906,5.3,"n operations, where n is the number of items.",3,5,4,0.031458139,0.968541861,0.959858719,0.410197884,0.482362366,0.991116824,0.898433903,0.999944265,0.934282339,0.963732605,0.903199442,0.973990944,0.934909372,0.639549077,0.550692892
847,847,907,5.3,n-1,3,4,3.5,0.658367217,0.341632783,0.159908886,-0.058362663,0.071131944,0.95848009,0.52528066,0.999535393,0.452176469,0.909240949,0.757756884,0.982545872,0.956319055,0.364911556,0.208353502
848,848,908,5.3,"O(n), the list is already sorted.",5,4,4.5,0.032300293,0.967699707,0.958784112,0.535207748,0.592076809,0.993504647,0.925735156,0.999980381,0.976867245,0.969726923,0.919198753,0.978396132,0.945933857,0.695159912,0.620012552
849,849,909,5.3,Insertion sort will take n-1 operations if the array is in reverse order.,4,4,4,0.033061504,0.966938496,0.95781279,0.478625476,0.542417588,0.987522201,0.85733465,0.999976673,0.972494841,0.972104161,0.92554379,0.980277082,0.950641149,0.801604271,0.752696887
850,850,910,5.3,"In the best case scenario of an already sorted list, insertion sort will progress once through the list.  So the number of operations is directly proportional to the number of elements in the list.  Also noted as O(n) in big o notation. ",5,5,5,0.020237267,0.979762733,0.9741768,0.477660716,0.541570869,0.984992241,0.828408267,0.999970706,0.965459146,0.924401502,0.798221604,0.983839628,0.959556826,0.731848776,0.665745718
851,851,911,5.3,1 where there is a list of two ints and only one must be moved.,2,3,2.5,0.05176729,0.94823271,0.933943795,0.14134635,0.246405817,0.976058203,0.726260635,0.999916236,0.901232262,0.953622047,0.87621356,0.965186465,0.912875159,0.650557578,0.564415138
852,852,912,5.3,"Best case is N, while the worst case is N factorial.",2,4,3,0.041905701,0.958094299,0.946527399,0.242497519,0.335180764,0.992615675,0.915571068,0.99995412,0.945902288,0.950737198,0.868513669,0.969193684,0.922903682,0.678650558,0.599433418
853,853,913,5.3,n-1 The best case is when the array is already sorted.,5,4,4.5,0.033178329,0.966821671,0.957663719,0.441485047,0.509821428,0.980443602,0.776401242,0.999959742,0.952530836,0.978466045,0.942524164,0.983609598,0.95898115,0.80428654,0.756040371
854,854,914,5.3,worst case its = O(n) time best case its = O(n^2) time,2,4,3,0.051793218,0.948206782,0.93391071,0.341865242,0.422390476,0.990570135,0.892183311,0.999954808,0.946713836,0.947301088,0.859342418,0.976450646,0.941065057,0.652649641,0.567022923
855,855,915,5.3,O(n),3,4,3.5,0.119796097,0.880203903,0.847137533,0.271219492,0.360388497,0.981725154,0.791053914,0.999882754,0.861753901,0.910753436,0.761793832,0.91695524,0.79217102,0.480024546,0.351843404
856,856,916,5.3,N number of times.  Where N equals the number of elements in the list.  Best-case scenario is that the elements in the list are already sorted.,5,5,5,0.025579453,0.974420548,0.967360054,0.40921092,0.481496161,0.982442182,0.799252079,0.999937035,0.925756876,0.958593407,0.889482514,0.978756584,0.946835929,0.77411598,0.71843236
857,857,917,5.3,the best case scenario for insertion sort is a list that is already sorted. the number of operations would be the same as the number of elements,5,5,5,0.026469171,0.973530829,0.966224753,0.331335038,0.413148682,0.981688588,0.790635833,0.999953293,0.944927229,0.978748335,0.943277618,0.975644651,0.939047962,0.704994321,0.632271276
858,858,918,5.3,"insertion sort will make zero operations (and length - 1 comparisons) in the best case scenario, that is, when the array its given is already in order.",3,4,3.5,0.023016632,0.976983368,0.97063027,0.467273891,0.532454911,0.988255295,0.865716507,0.999964636,0.958301721,0.951632194,0.870902484,0.976020476,0.939988507,0.799330175,0.749862196
859,859,919,5.3,theta(n) the best case senario is that everything is already sorted,5,4,4.5,0.03257072,0.96742928,0.958439042,0.349141777,0.4287767,0.995612097,0.949830756,0.999950129,0.941195913,0.971770236,0.924652518,0.98030822,0.950719075,0.648926556,0.562382047
860,860,920,5.3,n operations  The best case scenario is when all the numbers are in increasing order.,5,5,5,0.028614879,0.971385121,0.963486783,0.259205669,0.34984461,0.98282731,0.803655456,0.999942433,0.932121575,0.967798896,0.914052696,0.974831429,0.937012781,0.735298038,0.670045269
861,861,921,5.3,"it could be considered that having only one item would be the easiest to sort, but this could also be a trivial result as nothing is moved  having two items allows the algorithm to sort the items into the correct order",2,3,2.5,0.039005041,0.960994959,0.950228706,0.032712296,0.151063543,0.982516937,0.80010679,0.999932344,0.920225632,0.899223955,0.731020731,0.959600317,0.898895187,0.693592668,0.61805896
862,862,922,5.3,the best case is if it only has to look through the list once. The best case scenario is when it goes through the list and doesn't have to make any changes (the list is already sorted),5,3,4,0.03297025,0.96702975,0.957929233,0.14986144,0.253879054,0.976419389,0.730390265,0.999926769,0.913652915,0.942007568,0.845213593,0.972838536,0.932025339,0.68314302,0.605033333
863,863,923,5.3,very simplistic it moves one element from the list by one and inserting them in their correct position into a new slot then starting over. best case is (0)1,2,3,2.5,0.027309,0.972691,0.965153112,0.204071805,0.301456579,0.987300627,0.854801281,0.999951907,0.943292798,0.941263341,0.843227192,0.979035417,0.947533741,0.727265835,0.66003302
864,864,924,5.4,"The base case for a recursive merge sort is one number.  One number by itself is a sorted list, regardless of what number it is.",5,5,5,0.026907921,0.973092079,0.965664899,0.355841488,0.434656677,0.993058228,0.920631006,0.999970969,0.965769661,0.945416859,0.854313261,0.950191602,0.875348805,0.712977052,0.642221858
865,865,925,5.4,The base case for a recursive implementation of merge sort is when the sequence being passed to merge sort has less than 2 elements.,5,5,5,0.02304703,0.97695297,0.970591481,0.308529019,0.393133065,0.994888286,0.941555038,0.99996583,0.959709111,0.950756362,0.868564819,0.961798974,0.904397577,0.77157855,0.71526942
866,866,926,5.4,The base case for a recursive implementation of merge sort is one.,5,5,5,0.033232331,0.966767669,0.957594811,0.186888203,0.286375455,0.993645222,0.927342426,0.99996246,0.955735846,0.883333414,0.688607615,0.91647077,0.790958578,0.598024189,0.498931558
867,867,927,5.4,The best case is the same as the worst case O(n log n) for a recursive merge sort.,1,3,2,0.029440641,0.970559359,0.962433091,0.357301146,0.43593774,0.995221904,0.945369472,0.999960943,0.953947632,0.94800169,0.86121238,0.949459402,0.873516391,0.659253299,0.575254472
868,868,928,5.4,there is one object in the split array to sort.,5,5,5,0.035808504,0.964191496,0.954307558,0.325964272,0.408435049,0.994088593,0.932411728,0.999913816,0.898379905,0.954995171,0.879878537,0.943414641,0.858388687,0.73816973,0.673624872
869,869,929,5.4,The base case is when the length of the current array is 1.,5,5,5,0.020513892,0.979486108,0.97382382,0.412081242,0.484015288,0.994669456,0.939053044,0.999969621,0.964179327,0.959838838,0.892806669,0.962728692,0.906724302,0.818608582,0.773892991
870,870,930,5.4,O(nlog(n)),1,4,2.5,0.114221752,0.885778248,0.854250521,0.298514843,0.38434416,0.981970435,0.793858338,0.999803231,0.767987404,0.855275123,0.613717808,0.954996324,0.88737317,0.408017397,0.262085517
871,871,931,5.4,Best case is one element.  One element is sorted.,5,5,5,0.054056823,0.945943177,0.931022299,0.240071923,0.333051948,0.993295078,0.923339042,0.99995064,0.94179945,0.941789203,0.844630759,0.953699372,0.884127399,0.6876055,0.610595875
872,872,932,5.4,If the array being sorted has 0 or 1 elements,5,4,4.5,0.026042342,0.973957658,0.966769396,0.601552904,0.650304387,0.996434377,0.95923233,0.999971842,0.966798679,0.967712215,0.913821337,0.961165051,0.902811112,0.881765902,0.852619446
873,873,933,5.4,"T(n) = 0, if n&lt;2.",4,4,4,0.067502022,0.932497978,0.913865929,0.512278557,0.571953089,0.982902595,0.80451622,0.999925406,0.912045759,0.919445406,0.78499339,0.946046482,0.86497517,0.499614269,0.376262258
874,874,934,5.4,"A list size of 1, where it is already sorted.",5,5,5,0.025732219,0.974267781,0.96716512,0.546215892,0.601738065,0.995334786,0.946660112,0.999968251,0.96256446,0.969751564,0.919264522,0.96547349,0.913593472,0.860504508,0.826116831
875,875,935,5.4,Single element in the array,5,5,5,0.088789105,0.911210895,0.88670314,0.242803454,0.335449267,0.992457204,0.913759175,0.999924681,0.91119048,0.94352723,0.849269691,0.954996319,0.887373157,0.638645768,0.549566906
876,876,936,5.4,O(nlog(n)),1,3,2,0.114221752,0.885778248,0.854250521,0.298514843,0.38434416,0.981970435,0.793858338,0.999803231,0.767987404,0.855275123,0.613717808,0.954996324,0.88737317,0.408017397,0.262085517
877,877,937,5.4,n * log( n ),1,3,2,0.12538451,0.87461549,0.840006596,0.398718357,0.472287402,0.977644741,0.744400366,0.999923944,0.910320788,0.942723879,0.847125484,0.920734308,0.801628568,0.478962719,0.350519822
878,878,938,5.4,A list or array of only 1 element.,5,5,5,0.026462495,0.973537505,0.966233271,0.422625721,0.49326961,0.99325041,0.922828328,0.999933338,0.921398546,0.966423145,0.910380707,0.964788842,0.911880062,0.823079109,0.779465564
879,879,939,5.4,where you only must merge sort once,3,4,3.5,0.066763639,0.933236361,0.914808121,0.199789599,0.297698316,0.988707358,0.87088518,0.999946662,0.937108166,0.857155948,0.618737879,0.954996324,0.88737317,0.450905323,0.315545897
880,880,940,5.4,A single Element on the Array.,5,5,5,0.048399031,0.951600969,0.938241767,0.289134026,0.376111121,0.993727273,0.928280554,0.999920903,0.906735329,0.949030934,0.863959514,0.952130698,0.880201614,0.67619282,0.596369815
881,881,941,5.4,There is only one element in the subarray.,5,5,5,0.056901038,0.943098962,0.927393019,0.145869285,0.250375354,0.994366643,0.935590811,0.999968344,0.962673686,0.950106129,0.866829295,0.951132231,0.877702836,0.668720245,0.587055149
882,882,942,5.4,"if the array length is less than or equal to 1, then that array is returned to the other array and merged together",5,4,4.5,0.022107959,0.977892041,0.971789756,0.409498185,0.481748277,0.995207088,0.945200078,0.999962045,0.955246431,0.963456292,0.902461941,0.965746611,0.914276989,0.829928219,0.788003073
883,883,943,5.4,"if (right &gt; left)   {     mid = (right + left) / 2;     m_sort(numbers, temp, left, mid);     m_sort(numbers, temp, mid+1, right);      merge(numbers, temp, left, mid+1, right);   } ",2,2,2,0.044648409,0.955351591,0.943027644,0.452817351,0.519767182,0.960738494,0.551102208,0.999793206,0.756166969,0.902035594,0.738525219,0.949814145,0.874404176,0.631825864,0.541065803
884,884,944,5.4,The sequence of numbers has zero or one elements.,5,5,5,0.032283902,0.967716098,0.958805028,0.263856351,0.353926264,0.994670934,0.939069935,0.999967239,0.961370897,0.943204293,0.848407747,0.954451929,0.886010759,0.678484857,0.59922687
885,885,945,5.4,one element in an array,5,5,5,0.06903863,0.930961371,0.911905184,0.225272536,0.320063322,0.990926267,0.89625516,0.999841619,0.813250393,0.948885387,0.863571038,0.948878043,0.872061474,0.707613289,0.635535855
886,886,946,5.4,array of length 1,5,5,5,0.054207385,0.945792615,0.93083018,0.414445519,0.486090287,0.990266726,0.888714274,0.999872463,0.849619348,0.941328473,0.843401034,0.941358922,0.853244016,0.80956316,0.76261775
887,887,947,5.4,the array has one element,5,5,5,0.058704734,0.941295266,0.925091463,0.2578502,0.348654987,0.990513526,0.891536064,0.999901518,0.883878985,0.945227924,0.853808979,0.94287998,0.857050637,0.707613289,0.635535855
888,888,948,5.4,"When there is only one element in the array, or when the starting element in the array is the same as the ending element.",4,5,4.5,0.023558557,0.976441443,0.969938761,0.359826386,0.438154008,0.994152203,0.933139012,0.999832018,0.801930485,0.888990499,0.703706824,0.95662804,0.891456725,0.743902624,0.680771002
889,889,949,5.4,"when each half or the original array has nothing else to sort, and puts the halfs back together",2,3,2.5,0.02745074,0.97254926,0.964972249,0.305166394,0.390181869,0.994166432,0.933301692,0.999961051,0.954074731,0.949065275,0.864051173,0.95617252,0.890316734,0.726034403,0.658498023
890,890,950,5.4,the size of the list being sent is &lt;= 1,5,4,4.5,0.033644199,0.966355801,0.957069258,0.559239149,0.613167878,0.995429836,0.947746868,0.999946489,0.936904518,0.959621752,0.892227249,0.958223803,0.895450304,0.784282267,0.731104775
891,891,951,5.4,O(n log n),1,3,2,0.107451797,0.892548204,0.862889134,0.37747857,0.453646381,0.982658125,0.801721067,0.999906545,0.889806538,0.950058277,0.866701574,0.924041257,0.809904585,0.623117089,0.530210197
892,892,952,6.1,Its a location in memory that contains the memory address of another location in memory that contains information.,5,5,5,0.018495083,0.981504917,0.976399866,0.59504056,0.644588853,0.99792855,0.976315999,0.999983967,0.981095392,0.950973162,0.869143475,0.972486763,0.931144987,0.832290769,0.790948022
893,893,953,6.1,A pointer is a variable that contains a memory address as its value.,5,5,5,0.014306843,0.985693157,0.981744152,0.760268569,0.789600601,0.996986048,0.965539878,0.999978113,0.974193104,0.985227258,0.960570378,0.968615373,0.921456393,0.950495124,0.938291353
894,894,954,6.1,A pointer is a variable which stores the address of another variable.,5,5,5,0.01263243,0.98736757,0.983880741,0.784710765,0.811052203,0.997568997,0.972205037,0.99995426,0.946067311,0.979815872,0.946126959,0.992078385,0.980175255,0.940460682,0.925783285
895,895,955,6.1,Pointers are variables that contain as their values memory addresses of other variables.,5,5,5,0.035292327,0.964707673,0.954966211,0.682730794,0.721549861,0.997193647,0.967913467,0.999947911,0.938581503,0.93537617,0.827513865,0.964806899,0.911925252,0.822959423,0.779316374
896,896,956,6.1,A data type whose value refers to another value stored elsewhere in the computer memory using its address.,4,5,4.5,0.021462262,0.978537738,0.97261368,0.398396224,0.472004683,0.991963166,0.90811058,0.999982585,0.979465951,0.971529778,0.924010716,0.973644442,0.934042211,0.851359546,0.814717512
897,897,957,6.1,a pointer holds a memory location,5,4,4.5,0.055897415,0.944102585,0.928673664,0.24785614,0.339883738,0.99125664,0.900032493,0.999957375,0.949740274,0.918576803,0.78267502,0.953545163,0.883741474,0.698366523,0.624009636
898,898,958,6.1,a name that represents actual location or value of a data type. int *bPtr points to an integer value.,5,4,4.5,0.028299212,0.971700788,0.96388958,0.323063821,0.405889479,0.995098967,0.943963873,0.999984189,0.981357509,0.956779013,0.884639753,0.934555211,0.836216954,0.798928261,0.749361204
899,899,959,6.1,A variable that stores the address of another variable,5,5,5,0.012996376,0.987003624,0.983416338,0.795270026,0.820319499,0.999573681,0.995125663,0.999978407,0.974539271,0.979815872,0.946126959,0.992078385,0.980175255,0.940460682,0.925783285
900,900,960,6.1,a pointer is a programming language data type whose value refers directly to (or points to) another value stored elsewhere in the computer memory using its address,5,5,5,0.028520882,0.971479118,0.963606724,0.29494679,0.381212671,0.98968195,0.882028222,0.999980464,0.976965226,0.969543957,0.918710402,0.972243674,0.930536629,0.837397397,0.797313503
901,901,961,6.1,A data type whose value refers to another value stored somewhere else in the computer memory using its address.,5,5,5,0.023907959,0.976092041,0.969492916,0.383595049,0.459014487,0.99233119,0.912318391,0.999981363,0.978024336,0.967944873,0.91444232,0.973561555,0.933834777,0.852486312,0.816122041
902,902,962,6.1,"It is like a variable however instead of holding data, it holds a location in memory.",4,5,4.5,0.023017049,0.976982951,0.970629737,0.416909605,0.488252883,0.994376956,0.935708727,0.999967828,0.962065656,0.973102249,0.928207766,0.970318538,0.925718757,0.789681375,0.737834836
903,903,963,6.1,A pointer is a reference to a location in memory,5,5,5,0.039576471,0.960423529,0.949499549,0.263811141,0.353886585,0.992671548,0.916209891,0.999946969,0.937470394,0.943993415,0.850513976,0.959204446,0.897904475,0.753137171,0.692281991
904,904,964,6.1,A pointer is a reference to the memory location of an object.,4,5,4.5,0.030184686,0.969815314,0.961483674,0.353912175,0.432963422,0.994944595,0.942198855,0.999951139,0.942387549,0.966414515,0.910357673,0.946621128,0.866413287,0.787340224,0.734916559
905,905,965,6.1,A pointer is a variable that contains the memory address of a variable that has a value.,5,5,5,0.010383129,0.989616871,0.986750898,0.858264387,0.875606266,0.9978944,0.975925554,0.999986106,0.983617046,0.982305318,0.952771488,0.97475307,0.936816679,0.964786351,0.956105561
906,906,966,6.1,"It is a variable that contains not only a *value but has a memory address associated with it, and can be moved along a string or an array by jumping up one memory address.",2,5,3.5,0.019425213,0.980574787,0.975212999,0.536575437,0.593277155,0.993035021,0.920365667,0.999976852,0.972706211,0.962206353,0.899125754,0.974797786,0.936928586,0.897275746,0.871952677
907,907,967,6.1,Contains a variable's memory address as a value.,5,5,5,0.018881083,0.981118918,0.975907322,0.772461832,0.800301973,0.992807481,0.917764087,0.999940348,0.929663699,0.948743779,0.863193075,0.948275263,0.870552948,0.873475015,0.842284744
908,908,968,6.1,variable that points to the memory address of another variable and it is type specific.,5,5,5,0.011881053,0.988118947,0.984839513,0.790376723,0.81602491,0.996751905,0.96286279,0.999949318,0.94024035,0.977139155,0.938982589,0.97549146,0.938664584,0.930934608,0.913908905
909,909,969,6.1,An element that references a memory cell,5,5,5,0.043339968,0.956660032,0.944697244,0.323971093,0.406685743,0.997178357,0.967738646,0.999963708,0.957207109,0.942453203,0.846403028,0.960259426,0.900544682,0.749490201,0.687735994
910,910,970,6.1,Is a reference call to the place in memory where the object is stored.,4,4,4,0.027613103,0.972386897,0.96476507,0.305332929,0.390328028,0.994828304,0.940869231,0.999964525,0.958170875,0.96983895,0.919497762,0.960379845,0.900846045,0.746843755,0.684437163
911,911,971,6.1,a variable that contains the address of another variable,5,5,5,0.007410944,0.992589057,0.990543472,0.871168852,0.886931822,0.998086224,0.978118777,0.99999169,0.990201085,0.97283732,0.92750065,0.980844984,0.952062388,0.956552684,0.945842184
912,912,972,6.1,"A pointer variable contains the number of a memory address as its value, which may be null or 0, or the address of some value stored in memory.",5,5,5,0.014356911,0.985643089,0.981680264,0.642129898,0.685916636,0.994110665,0.932664081,0.999960958,0.953964925,0.967204535,0.912466299,0.97514829,0.937805762,0.8872509,0.859456571
913,913,973,6.1,A pointer is a variable that contains a memory address of anther variable,5,5,5,0.014245868,0.985754132,0.981821958,0.841835082,0.861187147,0.997416507,0.970461537,0.999977449,0.973409842,0.990046846,0.973434241,0.980306975,0.95071596,0.966053069,0.957684542
914,914,974,6.1,A variable that contains the memory address of another variable that contains a specific value.,5,5,5,0.00496763,0.99503237,0.993661195,0.894813597,0.907683545,0.999253809,0.991468402,0.999994551,0.993574621,0.988524549,0.96937111,0.985026252,0.962526488,0.971731007,0.964762169
915,915,975,6.1,a variable with a memory address as the value,5,4,4.5,0.024092615,0.975907385,0.969257291,0.667458475,0.708146167,0.992269649,0.911614766,0.999945778,0.936066628,0.963667439,0.903025509,0.921347438,0.803162996,0.855439484,0.81980321
916,916,976,6.1,it is a type that points to something else. It is the memory address of something else,5,4,4.5,0.029736578,0.970263422,0.962055469,0.270575523,0.35982332,0.992996557,0.919925895,0.999961217,0.954270168,0.926324911,0.803355336,0.959694797,0.899131634,0.791430414,0.740015036
917,917,977,6.1,A pointer is a way to get at another object. Essentially it is a way to grab an instance of an object and then either pass that instance a message or retreive some data from that object. A pointer is actually just an address of where an instance is held in memory.,4,5,4.5,0.019951403,0.980048597,0.974541569,0.334806413,0.416195321,0.994671475,0.93907612,0.999954246,0.946050309,0.943307554,0.848683359,0.96961152,0.923949364,0.80587405,0.758019224
918,918,978,6.2,This operator returns the memory address of its operand.,5,5,5,0.011843443,0.988156557,0.984887505,0.814400733,0.837109493,0.998248615,0.979975484,0.999983126,0.980103358,0.973901928,0.930342173,0.952257305,0.880518462,0.869385362,0.837186935
919,919,979,6.2,The address operator returns the memory address of its operand.,5,5,5,0.010295451,0.989704549,0.986862777,0.854810894,0.872575321,0.99873675,0.985556582,0.999988527,0.986472185,0.974152028,0.93100971,0.994344933,0.98584755,0.942569673,0.928412171
920,920,980,6.2,Returns memory address of its operand.,5,5,5,0.009145856,0.990854144,0.988329686,0.859239936,0.876462453,1,1,0.99999117,0.989588096,0.999401546,0.998402679,0.969535775,0.923759803,0.858664334,0.823823029
921,921,981,6.2,The address (&) operator returns the memory address of its operand.,5,5,5,0.021297038,0.978702962,0.97282451,0.809967339,0.833218542,0.989705154,0.882293523,0.999988495,0.986433947,0.974152028,0.93100971,0.994344933,0.98584755,0.942569673,0.928412171
922,922,982,6.2,Returns the memory address of its operand.,5,5,5,0.005699396,0.994300604,0.992727445,0.881434321,0.895941273,0.99548797,0.948411551,0.999981546,0.978241164,0.999401546,0.998402679,0.969535775,0.923759803,0.858664334,0.823823029
923,923,983,6.2,returns the place in memory of that element,5,3,4,0.053064287,0.946935713,0.932288798,0.30945757,0.393948004,0.993879572,0.930021877,0.99992696,0.913877082,0.97063242,0.921615596,0.958421189,0.895944285,0.753329277,0.692521453
924,924,984,6.2,The address of the where the data is stored: &b will return the address of b.,4,5,4.5,0.037521183,0.962478817,0.952122141,0.479855031,0.543496702,0.99190847,0.907485213,0.999953886,0.945626722,0.918163929,0.781573026,0.919525477,0.798603331,0.678175569,0.598841338
925,925,985,6.2,The & operator returns the address of a variable,5,5,5,0.048897386,0.951102614,0.937605856,0.329180449,0.411257715,0.995880717,0.952902039,0.999957674,0.950093265,0.99195567,0.978529044,1,1,0.696963191,0.622260364
926,926,986,6.2,"the ampersand (&) means ""pass by reference"". When the function is called, a pointer to the variable, instead of the variable itself, will be passed into the function.",3,3,3,0.03536278,0.96463722,0.954876311,0.26965794,0.359018006,0.979865834,0.76979531,0.99994983,0.940843799,0.845779911,0.588374333,0.956054355,0.890021013,0.710296273,0.638880231
927,927,987,6.2,& returns the memory address of its operand.,5,5,5,0.015653789,0.984346211,0.980025419,0.838146448,0.857949832,0.992081741,0.909466304,0.999980648,0.977181582,0.999549791,0.998798356,0.969535775,0.923759803,0.858664334,0.823823029
928,928,988,6.2,the address of the variable in memory,5,5,5,0.039458156,0.960541844,0.949650522,0.564321399,0.617628295,0.990684427,0.893490076,0.999939543,0.928714791,0.99340903,0.982408178,0.96953577,0.923759791,0.679055929,0.599938719
929,929,989,6.2,Returns the address location in memory of the item.,5,4,4.5,0.025344551,0.974655449,0.967659794,0.66098392,0.702463798,0.994251352,0.934272633,0.999939236,0.928352431,0.964354168,0.904858443,0.948554716,0.871252311,0.710081697,0.638612758
930,930,990,6.2,The address operator returns the memory address of its operand.,5,5,5,0.010295451,0.989704549,0.986862777,0.854810894,0.872575321,0.99873675,0.985556582,0.999988527,0.986472185,0.974152028,0.93100971,0.994344933,0.98584755,0.942569673,0.928412171
931,931,991,6.2,The & operator returns the memory address of the variable it precedes.,5,5,5,0.027972579,0.972027421,0.964306371,0.61815089,0.664871548,0.995556054,0.94918999,0.999985439,0.982830315,0.962122868,0.898902926,0.989230656,0.973048489,0.801794767,0.752934344
932,932,992,6.2,"The memory address of operand, 0x000000 or something along those lines. ",4,5,4.5,0.025500536,0.974499464,0.967460753,0.626061678,0.671814422,0.993718345,0.92817848,0.999962696,0.956014154,0.936924163,0.831645581,0.966782852,0.9168703,0.835743368,0.795251734
933,933,993,6.2,The object's memory address.,4,5,4.5,0.028971732,0.971028268,0.96303143,0.736517251,0.768755345,0.998286825,0.980412349,0.999834196,0.804497891,0.993088046,0.981551446,1,1,0.845575273,0.807507337
934,934,994,6.2,the reference to a variable,5,4,4.5,0.060204268,0.939795733,0.923178025,0.045016252,0.161862064,0.989367649,0.87843464,0.999911308,0.895422015,0.991384014,0.977003249,0.943544354,0.858713309,0.48051399,0.352453502
935,935,995,6.2,returns the memory address of its operand,5,5,5,0.019472778,0.980527222,0.975152305,0.722644985,0.756580402,0.995232803,0.945494086,0.999977103,0.973002247,0.999549791,0.998798356,0.969535775,0.923759803,0.858664334,0.823823029
936,936,996,6.2,memory address of its operand,5,5,5,0.018136919,0.981863082,0.976856891,0.817086935,0.839467029,0.999384689,0.992964824,0.999983013,0.979970367,0.963655208,0.902992863,0.96953577,0.923759791,0.905285299,0.881936693
937,937,997,6.2,returns the address number of the specified variable,5,4,4.5,0.045406103,0.954593897,0.942060809,0.22800833,0.322464381,0.994523908,0.937388911,0.999948899,0.939745687,0.972578373,0.926809499,0.957819087,0.894437456,0.576853096,0.472541503
938,938,998,6.2,"It returns the memory address of it's operand. That is, if applied to a normal variable, it gives the variable's memory address, just as a pointer variable might.",4,5,4.5,0.023839295,0.976160705,0.969580533,0.562133312,0.615707929,0.988407095,0.867452118,0.999956937,0.949223683,0.82611799,0.535895104,0.966753741,0.916797446,0.780762315,0.726717107
939,939,999,6.2,The & is a unary operator that returns the memory address of its operand,5,5,5,0.028132439,0.971867561,0.964102387,0.621488214,0.667800538,0.993369698,0.924192207,0.999972712,0.967824504,0.973927496,0.930410416,0.989230656,0.973048489,0.908674836,0.886161797
940,940,1000,6.2,the address of the variable it is attached to,5,3,4,0.030088961,0.969911039,0.961605821,0.245952174,0.338212729,0.991716075,0.905285458,0.999954438,0.946277664,0.963641322,0.9029558,0.96953577,0.923759791,0.451285988,0.316020402
941,941,1001,6.2,the memory address of its operand,5,5,5,0.012026846,0.987973154,0.984653478,0.837708712,0.857565654,0.996959855,0.965240399,0.999980624,0.977153128,0.963655208,0.902992863,0.96953577,0.923759791,0.905285299,0.881936693
942,942,1002,6.2,returns the address of what it is put in front of,5,4,4.5,0.036064923,0.963935077,0.953980362,0.234568283,0.328221699,0.990023107,0.885928846,0.999904456,0.887342379,0.975839544,0.935513824,0.921210178,0.802819487,0.598762393,0.499851738
943,943,1003,6.2,returns a pointer,4,3,3.5,0.106042624,0.893957377,0.86468727,-0.081226341,0.051065721,0.987495354,0.857027698,0.999901147,0.883440827,0.988060762,0.968133225,0.90908391,0.772472119,0.621293366,0.527936901
944,944,1004,6.3,returns a synonym for the object to which its pointer operand points.,5,5,5,0.020754695,0.979245305,0.973516551,0.642766893,0.686475692,0.98796643,0.862413754,0.999988525,0.986469634,0.950337957,0.867448063,0.973603727,0.933940317,0.885979772,0.857872092
945,945,1005,6.3,The star operator returns a synonym for the object to which its pointer operand points.,5,5,5,0.014833272,0.985166729,0.981072418,0.672287285,0.712384154,0.988727965,0.871120798,0.999988199,0.986085445,0.955825589,0.882094988,0.977538894,0.943788521,0.911530495,0.889721414
946,946,1006,6.3,Returns synonym for the object its operand points to.,5,5,5,0.030310273,0.969689727,0.961323422,0.680470109,0.719565779,0.990470233,0.891041076,0.999987543,0.985311634,0.952349941,0.872818208,0.976341534,0.940791991,0.856455803,0.821070065
947,947,1007,6.3,"It returns a synonym, alias or nickname of the name of the object that its operand points to in memory (dereferencing the pointer).",5,5,5,0.005056083,0.994943917,0.993548326,0.860273659,0.877369697,0.997217354,0.968184521,0.99999431,0.993290261,0.991561348,0.977476568,0.98259208,0.956434695,0.97150147,0.964476047
948,948,1008,6.3,Returns an alias/nickname for the object to which the pointer operand points.,5,5,5,0.025926292,0.974073708,0.966917479,0.550632715,0.605614473,0.986656869,0.847440847,0.999988848,0.986850122,0.962007465,0.898594906,0.973603727,0.933940317,0.863503814,0.829855506
949,949,1009,6.3,the * operator returns the value in the memory address the element points to.,4,4,4,0.021852672,0.978147328,0.972115508,0.469503433,0.53441166,0.984893176,0.827275598,0.999957894,0.950352439,0.953402609,0.875627862,0.970260799,0.925574259,0.825790823,0.782845751
950,950,1010,6.3,The * returns the value,4,4,4,0.077508867,0.922491133,0.901096974,0.052412774,0.168353595,0.993661128,0.927524282,0.999947745,0.938385136,0.907889202,0.754148964,0.932077374,0.830015884,0.725242794,0.657511271
951,951,1011,6.3,The * operator returns the dereferenced pointer variable (ie: it returns the value of whatever variable the pointer is pointing to),5,5,5,0.025188804,0.974811196,0.96785853,0.316938937,0.400513997,0.997866583,0.975607501,0.999968056,0.962334706,0.95506792,0.88007271,0.965875259,0.914598945,0.851378798,0.81474151
952,952,1012,6.3,The dereferencing operator returns the dereferenced object.,4,5,4.5,0.037965417,0.962034583,0.951555289,0.529946148,0.587458985,0.990112808,0.886954444,0.999947255,0.937808203,0.927485297,0.806452498,0.961766926,0.904317373,0.83729887,0.797190689
953,953,1013,6.3,* returns the synonym for the object its operand points to.,5,5,5,0.024331987,0.975668013,0.968951847,0.684409738,0.72302338,0.990271128,0.888764598,0.999980818,0.977382714,0.939012073,0.837218379,0.976341534,0.940791991,0.856455803,0.821070065
954,954,1014,6.3,it returns the information in the address the pointer points to.,4,4,4,0.021084368,0.978915632,0.97309588,0.404523075,0.47738189,0.989392346,0.87871702,0.999960011,0.952848863,0.940284736,0.840615217,0.944222642,0.860410802,0.796120405,0.745861174
955,955,1015,6.3,the star operator returns the value at the memory address the pointer is pointing at.,5,4,4.5,0.028501093,0.971498907,0.963631975,0.467044741,0.532253798,0.988149303,0.864504642,0.999956826,0.949092858,0.960139368,0.893608807,0.943066544,0.857517535,0.825558245,0.782555841
956,956,1016,6.3,The star operator returns the object at that memory location.,4,4,4,0.028186679,0.971813321,0.964033175,0.560347498,0.614140616,0.987600224,0.858226726,0.999968183,0.962484463,0.951834408,0.871442209,0.964085792,0.9101206,0.823345482,0.779797602
957,957,1017,6.3,The * operator returns the value of the object's memory address it precedes.,4,3,3.5,0.022612333,0.977387667,0.971146163,0.515046835,0.574382658,0.998423491,0.98197493,0.999974899,0.970402697,0.972315982,0.926109157,0.96715152,0.917792933,0.844959021,0.80673917
958,958,1018,6.3,The value of the object that the operand points to,4,5,4.5,0.022497296,0.977502704,0.971292953,0.377305508,0.453494494,0.991498212,0.902794513,0.999957416,0.949788126,0.966936931,0.911752043,0.976025039,0.939999927,0.868544936,0.836139333
959,959,1019,6.3,The value stored in the object being pointed to.,4,4,4,0.026856542,0.973143458,0.96573046,0.408611268,0.480969878,0.990422007,0.890489679,0.999979868,0.976262587,0.951485167,0.870510057,0.966508583,0.91618391,0.804213583,0.755949431
960,960,1020,6.3,the value of the variable the pointer points to.,4,4,4,0.025790095,0.974209905,0.967091269,0.347071111,0.426959388,0.985768237,0.837280645,0.99988105,0.859744182,0.958320767,0.888754817,0.960209885,0.9004207,0.798925817,0.749358158
961,961,1021,6.3,returns synonym for the object its operand points to,5,5,5,0.039556384,0.960443616,0.94952518,0.522073031,0.580549172,0.990144342,0.887314996,0.999978032,0.974097586,0.939012073,0.837218379,0.976341534,0.940791991,0.856455803,0.821070065
962,962,1022,6.3,synonym for the object its operand points to,5,5,5,0.039331555,0.960668445,0.949812066,0.592390001,0.6422626,0.987042939,0.851854989,0.999979306,0.975599695,0.929096755,0.810753607,0.970376083,0.92586277,0.855194628,0.819497994
963,963,1023,6.3,Returns synonym for the object its operand points to,5,5,5,0.039556384,0.960443616,0.94952518,0.526054442,0.584043443,0.990144342,0.887314996,0.999985386,0.982768591,0.952349941,0.872818208,0.976341534,0.940791991,0.856455803,0.821070065
964,964,1024,6.3,"It dereferences a pointer, meaning it returns the value stored in the memory address a pointer refers to.",4,5,4.5,0.018326163,0.981673837,0.976615411,0.417113692,0.488431999,0.994735504,0.939808202,0.999981325,0.97798019,0.97054811,0.921390566,0.937084289,0.84254626,0.880142808,0.850596238
965,965,1025,6.3,It is unary operator that returns the value of the variable located at the address,4,4,4,0.028218925,0.971781075,0.963992028,0.180783749,0.281017903,0.990249062,0.88851231,0.999980652,0.977186816,0.954204958,0.877769395,0.969781828,0.924375579,0.82440424,0.781117357
966,966,1026,6.3,a reference to a = variable,1,3,2,0.075906634,0.924093366,0.903141458,0.176284581,0.277069225,0.982049289,0.794759924,0.999935492,0.923937964,0.899889783,0.732797879,0.957339129,0.893236306,0.635870695,0.54610774
967,967,1027,6.3,a synonym for the object to which its pointer operand points,5,5,5,0.024949729,0.975050271,0.968163594,0.551865995,0.606696857,0.988330934,0.866581332,0.99998777,0.985579872,0.947685945,0.860369632,0.97765683,0.94408367,0.88194567,0.852843529
968,968,1028,6.3,it returns the actual data at the address pointed to,4,3,3.5,0.033580303,0.966419697,0.957150791,0.136177003,0.241868959,0.989931658,0.884883263,0.999974521,0.969957303,0.940577664,0.841397065,0.952803457,0.88188527,0.763516605,0.705220096
969,969,1029,6.3,will return zero or many characters placed before the operator,1,3,2,0.046084404,0.953915596,0.941195282,0.145675629,0.250205393,0.990671247,0.893339373,0.999960555,0.953489609,0.92007574,0.786675802,0.969085183,0.922632146,0.589473009,0.488272395
970,970,1030,6.4,The array itself can be signed to a pointer or each element of the array can be assigned to a pointer.,2,4,3,0.015711606,0.984288395,0.979951644,0.658911228,0.700644708,0.993996767,0.931361822,0.999974594,0.970043141,0.969033851,0.917348889,0.959354361,0.898279654,0.896071851,0.870452006
971,971,1031,6.4,An array can be addressed in pointer/offset notation by setting a pointer variable equal to the variable name of the array. Elements of the array can then be accessed by adding an offset value to the pointer variable.,5,4,4.5,0.011854053,0.988145948,0.984873967,0.611894369,0.659380536,0.99559827,0.949672671,0.999977319,0.973256165,0.955639617,0.881598614,0.976476497,0.941129752,0.821096301,0.776993967
972,972,1032,6.4,Element b[ n ] can be accessed by  *( bPtr + n ).,5,3,4,0.068449378,0.931550622,0.912657081,0.115653969,0.223856994,0.981880297,0.792827751,0.999884608,0.863939895,0.903207244,0.741652446,0.947249181,0.867985061,0.665124476,0.582572974
973,973,1033,6.4,Using either the name of the array as a pointer or using a separate pointer that points to the array.,3,3,3,0.014777899,0.985222101,0.981143075,0.652766407,0.695251728,0.994947347,0.942230321,0.999976237,0.97198088,0.97272171,0.927192077,0.960204326,0.900406788,0.810003698,0.763166887
974,974,1034,6.4,An element b[3] can be referenced by using *( bPtr + 3) instead.,5,3,4,0.053143919,0.946856082,0.932187186,0.175321296,0.276223801,0.987554668,0.857705858,0.999910435,0.894392665,0.939677953,0.838995665,0.968581329,0.921371194,0.704270542,0.631369075
975,975,1035,6.4,you get the memory location of the first element and the you add an offset to it to get other elements.,5,5,5,0.018128276,0.981871724,0.976867919,0.401956201,0.475129083,0.99068966,0.893549901,0.999909036,0.892742652,0.951485599,0.87051121,0.971237928,0.928019635,0.832540572,0.791259405
976,976,1036,6.4,yes *(array +offset),5,3,4,0.135344863,0.864655137,0.827296965,0.208500639,0.305343528,0.979248714,0.762739449,0.999912283,0.89657208,0.820672599,0.521360923,0.957193667,0.892872271,0.528779268,0.412616825
977,977,1037,6.4,"The name of an array is considered to be a pointer in C++, and can be passed as such in functions parameters. Declaring int a[10]; creates a pointer ""a"" which stores the address of a[0].",3,4,3.5,0.021041691,0.978958309,0.973150337,0.316185683,0.399852907,0.993042016,0.920445644,0.999947057,0.937574175,0.946397356,0.856930286,0.967261374,0.918067856,0.839683056,0.800162609
978,978,1038,6.4,Element b[ n ] can be accessed by  *( bPtr + n ) is an example of how an array can be addressed as pointer/offset notation.,5,4,4.5,0.035119057,0.964880943,0.955187308,0.21530655,0.311316711,0.978769419,0.757259419,0.999930546,0.918105386,0.923042598,0.794594581,0.960309221,0.9006693,0.683685958,0.605710113
979,979,1039,6.4,*(array + element),5,3,4,0.107583344,0.892416656,0.862721276,0.345472753,0.425556595,0.986348305,0.843912875,0.999895025,0.876222398,0.796721693,0.457434052,0.963549813,0.908779251,0.66837126,0.586620134
980,980,1040,6.4,*f[3],2,3,2.5,0.263055146,0.736944854,0.664335822,0.010253355,0.131352537,0.983154579,0.807397295,0.999715243,0.664239335,0.798675558,0.462649073,0.963549813,0.908779251,0.274472207,0.095619628
981,981,1041,6.4,you can have a pointer to the front of the array and add to the memory location (or offset from the initial value).,5,5,5,0.015352309,0.984647691,0.980410115,0.506674469,0.567034682,0.996141676,0.955885723,0.999936633,0.925283629,0.948874071,0.863540835,0.970372359,0.92585345,0.821693003,0.777737764
982,982,1042,6.4,"The pointer to the array will initially point to the first element of that array.  When the pointer is incremented, it will point to the next element, and so on.",2,5,3.5,0.009833455,0.990166545,0.987452294,0.812372088,0.835329061,0.997825905,0.975142412,0.999979912,0.976314313,0.98298371,0.95458217,0.979917602,0.949741509,0.949961901,0.937626683
983,983,1043,6.4,With int x[10]; int *xPtr; xPtr = x; Address &x[1] is the same as xPtr + 1.,5,3,4,0.065882266,0.934117734,0.915932774,0.132936642,0.239025067,0.972483497,0.68538911,0.999906074,0.889250741,0.939295741,0.837975511,0.966196135,0.915401974,0.655953884,0.571141707
984,984,1044,6.4,Takes the number of array elements and points to each at a time,1,3,2,0.019146264,0.980853736,0.975568945,0.507917464,0.568125592,0.995765935,0.951589668,0.999965155,0.958914112,0.912938887,0.767626974,0.959870296,0.89957084,0.731082201,0.664790172
985,985,1045,6.4,The array can act as a pointer or be referenced by a pointer.  *(arrayPtr + 3) or *(array + 3),5,3,4,0.035750389,0.964249611,0.954381714,0.375001133,0.451472068,0.994491478,0.937018119,0.999947049,0.93756441,0.964294016,0.904697893,0.968287944,0.920636964,0.779676616,0.725363769
986,986,1046,6.4,by using the *(pointer + element-index),5,3,4,0.079039216,0.920960784,0.899144214,0.343614608,0.423925801,0.992094632,0.909613694,0.999953936,0.945685031,0.874226931,0.664301689,0.907530383,0.76858424,0.762746334,0.704259943
987,987,1047,6.4,using the star operator.   array: b[n] can be accessed by *(bpointer +n),5,4,4.5,0.047894061,0.952105939,0.938886121,0.206334382,0.303442321,0.992607764,0.915480607,0.999939196,0.928304657,0.914022433,0.770519045,0.965668557,0.914081649,0.682190418,0.603845902
988,988,1048,6.4,Element A[n] can be accessed by *(APtr + n),5,3,4,0.065055609,0.934944391,0.916987606,0.066323936,0.180562674,0.98534815,0.832477567,0.999887653,0.867530749,0.898374386,0.728753164,0.946717719,0.866655017,0.745086908,0.682247229
989,989,1049,6.4,"by referencing a pointer and referring to other pointers relative to the first pointer(pointer+1, pointer +2, etc)",2,4,3,0.023493826,0.976506174,0.970021359,0.478480101,0.542289999,0.996768881,0.963056893,0.999967171,0.961291092,0.971039575,0.922702325,0.978155357,0.94533129,0.834623694,0.793856046
990,990,1050,6.4,"First, some pointer variable must reference the first entity in the array. Any variable in the array can then be accessed by referring to that first entity's address plus some offset. i.e. ptrToArray = array;  nthEntity = *(ptrToArray + n);",5,5,5,0.01784271,0.98215729,0.977232308,0.471557319,0.536214246,0.993901795,0.930275958,0.999972008,0.966994077,0.963141986,0.901623033,0.973245959,0.933044962,0.831256568,0.789658878
991,991,1051,6.4,&[b3] is as bptr + 3. Array can be treated as pointer,4,3,3.5,0.040160477,0.959839523,0.948754344,0.267689139,0.357290095,0.984611016,0.82404951,0.999895193,0.876420259,0.930487037,0.81446438,0.968362479,0.920823496,0.687097192,0.609962262
992,992,1052,6.4,a[i] = *(a+i),5,3,4,0.109027863,0.890972138,0.860878039,0.054666877,0.170331899,0.983684053,0.813451051,0.999918944,0.904426342,0.82004621,0.519689041,0.872669443,0.681340763,0.451667011,0.316495352
993,993,1053,6.4,&b[3]  bPtr + 3,5,3,4,0.132490158,0.867509842,0.830939631,0.007838937,0.129233531,0.982779529,0.803109147,0.999880726,0.859361928,0.870674017,0.654818679,0.917223509,0.792842393,0.408064783,0.262144583
994,994,1054,6.4,*(arrayName + index),5,3,4,0.119007826,0.880992174,0.848143385,0.094971262,0.205704893,0.986348305,0.843912875,0.99988664,0.866336322,0.820312425,0.52039959,0.934170218,0.835253465,0.664813757,0.582185658
995,995,1055,6.4,multi-dimensional array,0,2,1,0.349974096,0.650025904,0.553425322,0.405374587,0.478129217,0.983917672,0.816122148,0.999734911,0.687430438,0.798675558,0.462649073,0.963549813,0.908779251,0.278138936,0.100190255
996,996,1056,6.5,the number of bytes of an array during program compilation.,4,5,4.5,0.03734684,0.96265316,0.952344607,0.435026616,0.50415321,0.994968789,0.942475476,0.999945794,0.936085432,0.962750113,0.900577093,0.963858484,0.909551735,0.708402872,0.636520081
997,997,1057,6.5,The sizeof operator returns the size of the operand.,5,3,4,0.026280463,0.973719537,0.966465549,0.647907138,0.690987009,0.997410113,0.97038844,0.99991387,0.898443306,0.976901571,0.938348458,0.975122799,0.937741968,0.880461216,0.850993138
998,998,1058,6.5,Returns size of operand in bytes.,5,5,5,0.013230503,0.986769497,0.983117586,0.803456426,0.827504263,0.999569919,0.99508265,0.999982208,0.979020628,0.977403723,0.939688742,0.972445397,0.931041464,0.90364033,0.879886217
999,999,1059,6.5,It returns the size of an array in bytes.,4,5,4.5,0.017002702,0.982997298,0.978304177,0.712152541,0.747371748,0.996389262,0.958716503,0.999964323,0.957932579,0.968223407,0.915185749,0.972450152,0.931053364,0.843353391,0.804737731
1000,1000,1060,6.5,Returns the size of the array in bytes during the program compilation.,4,5,4.5,0.028958976,0.971041024,0.963047706,0.589925528,0.640099664,0.993989003,0.931273051,0.99993482,0.923145808,0.952199434,0.872416493,0.965600413,0.913911111,0.797488391,0.747566388
1001,1001,1061,6.5,it returns the size of the argument passed in,5,3,4,0.034025013,0.965974987,0.956583331,0.301847994,0.387269488,0.99447756,0.936858986,0.99991376,0.898312828,0.970257497,0.920614897,0.972445397,0.931041464,0.687767267,0.61079752
1002,1002,1062,6.5,The byte size of the date stored ina variable.,4,5,4.5,0.035022199,0.964977801,0.9553109,0.541842282,0.597899582,0.998107131,0.978357811,0.999981802,0.978542192,0.943779172,0.849942145,0.969016818,0.922461054,0.834695041,0.793944981
1003,1003,1063,6.5,sizeof returns the size of the operand in bytes,5,5,5,0.024988294,0.975011706,0.968114385,0.670163274,0.710520024,0.996042783,0.954755021,0.999900814,0.883048963,0.986903116,0.965043376,0.972445397,0.931041464,0.90364033,0.879886217
1004,1004,1064,6.5,"The amount of memory required for a specific parameter such as ints, doubles.",4,3,3.5,0.033867419,0.966132581,0.956784425,0.248922572,0.340819687,0.997161763,0.967548914,0.999974344,0.969749072,0.943061815,0.848027462,0.978828284,0.947015367,0.727159321,0.659900249
1005,1005,1065,6.5,sizeof returns the size of the operand in bytes.,5,5,5,0.011333048,0.988666952,0.98553878,0.811824858,0.834848786,0.996100284,0.955412463,0.999909064,0.892776632,0.986903116,0.965043376,0.972445397,0.931041464,0.90364033,0.879886217
1006,1006,1066,6.5,the size of the information in bits.,1,4,2.5,0.02436626,0.97563374,0.968908114,0.654696345,0.696945531,0.992118754,0.909889494,0.999918985,0.904474399,0.977182352,0.939097885,0.94245916,0.855997487,0.724377096,0.656432167
1007,1007,1067,6.5,the size of the string.,3,3,3,0.030060291,0.969939709,0.961642404,0.585998654,0.636653258,0.990513857,0.891539855,0.999940304,0.929611094,0.958634877,0.889593201,0.867696217,0.668894698,0.728899539,0.662069453
1008,1008,1068,6.5,sizeof returns the size in bytes of the respective object.,4,5,4.5,0.018988788,0.981011212,0.975769887,0.607940376,0.655910329,0.996812222,0.963552433,0.999965819,0.959696234,0.966552617,0.910726278,0.95852396,0.896201481,0.827837467,0.785396922
1009,1009,1069,6.5,The sizeof operator returns the total number of bytes of its operand.,5,5,5,0.01925087,0.98074913,0.975435465,0.616787314,0.663674811,0.997212615,0.968130339,0.99996311,0.956502616,0.954281442,0.877973537,0.982239544,0.955552434,0.843532205,0.804960625
1010,1010,1070,6.5,"The size of an operand in bytes. Used with variable names, type names, and constant values",5,5,5,0.025539517,0.974460483,0.967411012,0.558668375,0.61266694,0.996691655,0.962173921,0.999975837,0.971509226,0.893001124,0.714411501,0.98826435,0.970630198,0.826635063,0.783898108
1011,1011,1071,6.5,the size in bytes needed to store the object in memory,4,5,4.5,0.038527966,0.961472035,0.950837465,0.418481588,0.489632528,0.995816201,0.952164388,0.999905726,0.888840307,0.937652203,0.833588778,0.956799433,0.891885655,0.820087433,0.775736399
1012,1012,1072,6.5,the size of the list object.,4,2,3,0.031212151,0.968787849,0.960172606,0.514397025,0.573812355,0.989322243,0.877915497,0.999930945,0.918576346,0.968766131,0.916634323,0.927368261,0.818230792,0.750349879,0.688807594
1013,1013,1073,6.5,the sizeof operator returns the size in bytes of an array parameter,3,5,4,0.035366833,0.964633167,0.95487114,0.511540234,0.571305103,0.99696199,0.965264806,0.999970614,0.965349997,0.983730803,0.956576221,0.977306859,0.943207827,0.799811125,0.750461706
1014,1014,1074,6.5,the size of operand in bytes,5,5,5,0.022060037,0.977939963,0.971850906,0.800544024,0.824948204,0.994898573,0.941672653,0.999982909,0.979847624,0.971088992,0.922834223,0.950725754,0.876685581,0.935285568,0.919332435
1015,1015,1075,6.5,returns the size in bytes of the specified data,4,5,4.5,0.036577582,0.963422418,0.953326197,0.468677402,0.533686697,0.994962226,0.942400432,0.999949649,0.940630105,0.966988501,0.911889687,0.948089657,0.870088448,0.8151806,0.769619965
1016,1016,1076,6.5,"It returns the size of an operand in memory, which is checked at compiler-time.",5,3,4,0.021925628,0.978074372,0.972022414,0.46045506,0.526470389,0.994613927,0.938418146,0.999953893,0.94563442,0.965181324,0.907066188,0.972510295,0.931203879,0.785971284,0.733210157
1017,1017,1077,6.5,Return size of operand in bytes,5,5,5,0.033822775,0.966177225,0.956841392,0.632797837,0.677726387,0.999221666,0.991100887,0.999977945,0.973994208,0.98177248,0.951349301,0.972445397,0.931041464,0.907250762,0.88438667
1018,1018,1078,6.5,the total number of bytes of an object.,4,5,4.5,0.030755401,0.969244599,0.960755429,0.462290734,0.528081462,0.992425133,0.913392495,0.999881568,0.860355828,0.96488635,0.906278879,0.946568544,0.866281689,0.706368566,0.63398429
1019,1019,1079,6.5,total number of bytes in the array,4,5,4.5,0.053577483,0.946422517,0.931633948,0.353161812,0.432304869,0.993729824,0.928309725,0.999925855,0.912574534,0.965710776,0.908479338,0.954988693,0.887354072,0.688084185,0.611192562
1020,1020,1080,6.5,it returns the size in bytes of a certain variable type,4,5,4.5,0.030046761,0.969953239,0.961659669,0.456861436,0.523316459,0.994375133,0.935687885,0.99997254,0.967621682,0.937402015,0.832921006,0.952672248,0.881556904,0.77409178,0.718402195
1021,1021,1081,6.5,"it yields the size in bytes of the operand, which can be an expression or the parenthesized name of a type",3,5,4,0.025542498,0.974457502,0.967407209,0.516663313,0.575801354,0.990978123,0.896848058,0.999961497,0.95460007,0.941213624,0.843094493,0.974975589,0.937373558,0.832791567,0.791572274
1022,1022,1082,6.6,They can be passed by value or by reference,2,3,2.5,0.073420644,0.926579356,0.906313636,0.039529849,0.157046943,0.983876111,0.815646959,0.999893764,0.874735198,0.815922873,0.508683527,0.864320504,0.660446591,0.570408404,0.464508107
1023,1023,1083,6.6,"Nonconstant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to nonconstant data, constant pointer to constant data.",5,5,5,0.004412115,0.995587885,0.994370044,0.984490335,0.986388,0.99697614,0.965426592,0.999983487,0.980529668,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1024,1024,1084,6.6,#NAME?,5,5,5,0.051407337,0.948592663,0.934403102,0.883480251,0.897736875,0.991224973,0.899670419,0.999921673,0.907644085,0.923819609,0.796668485,0.974882983,0.937141801,0.418235689,0.274822757
1025,1025,1085,6.6,"Four different ways: Nonconstant pointer to nonconstant data, a nonconstant pointer to constant data, a constant pointer to nonconstant data and a constant pointer to constant data.",5,5,5,0.004411399,0.995588601,0.994370957,0.980459929,0.982850729,0.996432874,0.959215145,0.999991067,0.989466521,0.962499819,0.899909038,0.989198865,0.972968928,0.99451834,0.993166887
1026,1026,1086,6.6,Pass-by-value or pass-by-reference.,2,3,2.5,0.310566843,0.689433157,0.603709847,0.186003253,0.285598781,0.977174068,0.739018914,0.99994595,0.936268791,0.666431752,0.109679851,0.976739513,0.941787979,0.531643927,0.416187661
1027,1027,1087,6.6,you can pass a pointer to a pointer or pass a reference to pointer.,2,3,2.5,0.059674203,0.940325797,0.923854398,0.37567547,0.452063897,0.985626303,0.835657831,0.999861485,0.836674675,0.672135916,0.124904718,0.924502338,0.811058493,0.354920059,0.195898966
1028,1028,1088,6.6,by address &bPtr or directly bPtr.,2,3,2.5,0.103095651,0.896904349,0.868447672,0.030364929,0.149003385,0.98252935,0.80024871,0.999959156,0.951839813,0.77605644,0.402276851,0.96120263,0.902905158,0.580544353,0.477142704
1029,1029,1089,6.6,"Nonconstant pointer to nonconstant data, constant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to constant data. ",5,5,5,0.004412115,0.995587885,0.994370044,0.984490335,0.986388,0.99697614,0.965426592,0.999983487,0.980529668,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1030,1030,1090,6.6,By argument and reference.,1,3,2,0.087231994,0.912768006,0.888690049,0.156745523,0.259920844,0.985694178,0.836433886,0.999814924,0.78177468,0.80420849,0.477416908,0.895045628,0.737339717,0.497859925,0.374075445
1031,1031,1091,6.6,"Nonconstant pointer to nonconstant data, nonconstant pointer to constant data, constant pointer to nonconstant data, and constant pointer to constant data.",5,5,5,0.004012048,0.995987952,0.994880538,0.983364523,0.985399935,0.996819587,0.963636634,0.999986357,0.983913548,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1032,1032,1092,6.6,pass by value and pass by reference with reference or pointer arguments.,2,3,2.5,0.063221931,0.936778069,0.919327419,0.228716388,0.323085806,0.985595049,0.83530049,0.999907594,0.891043371,0.800247593,0.46684496,0.906684791,0.76646805,0.50552249,0.383626935
1033,1033,1093,6.6,you can pass them with the pointer (*) or the memory address (&),2,3,2.5,0.08323884,0.91676116,0.893785401,0.062193479,0.176937594,0.979501235,0.765626659,0.999892808,0.873608562,0.709801266,0.225436529,0.939889099,0.849565617,0.538746059,0.425040565
1034,1034,1094,6.6,nonconst -&gt; nonconst const -&gt; nonconst nonconst -&gt; const const -&gt; const,5,5,5,0.197555661,0.802444339,0.747914612,0.148603916,0.252775393,0.987468526,0.856720955,0.999676256,0.618269189,0.864687782,0.638840942,0.976739521,0.941787999,0.471643269,0.341396028
1035,1035,1095,6.6,Nonconstant pointer to nonconstant data Constant pointer to nonconstant data Nonconstant pointer to constant data Constant point to constant data,5,5,5,0.019654989,0.980345011,0.9749198,0.938250303,0.945805608,0.991224973,0.899670419,0.999968253,0.962566182,0.955528742,0.88130268,0.979921516,0.949751304,0.985868096,0.982384242
1036,1036,1096,6.6,"Non-constant pointer to non-constant data, non-constant pointer to constant data, constant pointer to constant data, constant pointer to non-constant data.",5,5,5,0.029200733,0.970799267,0.96273922,0.926033676,0.935083731,0.99697614,0.965426592,0.999983487,0.980529668,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1037,1037,1097,6.6,Pass by reference with reference arguments. function(int &)  Pass by reference with pointer arguments. function(int *),2,3,2.5,0.06983614,0.93016386,0.910887543,0.194267079,0.292851498,0.98938734,0.878659783,0.999848221,0.821034897,0.856672197,0.617446709,0.970161749,0.925326375,0.598958731,0.500096476
1038,1038,1098,6.6,you can pass the reference or the dereference in a function,2,2,2,0.074329674,0.925670326,0.905153694,0.02715233,0.146183859,0.982893562,0.804412951,0.999916526,0.901574509,0.666718716,0.110445781,0.955320814,0.888185243,0.418854624,0.275594267
1039,1039,1099,6.6,1. nonconstant pointer to nonconstant data. Its delcaration does no include  const qualifier. 2. nonconstant pointer to constant data. Provides the performance of pass-by-reference and the protection of pass-by-value 3. Constant pointer to nonconstant data.  4. Constant pointer to constant date.,5,5,5,0.022186697,0.977813304,0.971689285,0.792563915,0.817944492,0.987975813,0.862521043,0.999961319,0.954390329,0.955606421,0.881510012,0.986908387,0.967236746,0.911280155,0.889409363
1040,1040,1100,6.6,"constant pointer to constant data, constant pointer to nonconstant data, nonconstant pointer to constant data, nonconstant pointer to nonconstant data",5,5,5,0.00590235,0.99409765,0.992468471,0.979436696,0.981952692,0.997101949,0.966865038,0.999979688,0.976050185,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1041,1041,1101,6.6,Nonconstant pointer to nonconstant data Nonconstant pointer to constant data Constant pointer to nonconstant data Constant pointer to constant data,5,5,5,0.016551733,0.983448267,0.978879623,0.940593481,0.94786209,0.991224973,0.899670419,0.999921673,0.907644085,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1042,1042,1102,6.6,"Pointers may be passed to functions by value, by reference with reference arguments, or by reference with pointer arguments.",2,3,2.5,0.047154665,0.952845335,0.939829606,0.236847416,0.330221972,0.991421153,0.90191345,0.999968511,0.962870999,0.84391272,0.583390652,0.963181519,0.907857553,0.611175776,0.515325188
1043,1043,1103,6.6,There are four way to pass pointer to a function 1. non constant pointer to non constant data 2.non constant pointer to  constant data. 3. constant pointer to non constant data. 4. constant pointer to  constant data.,5,5,5,0.020737588,0.979262412,0.973538379,0.862771034,0.879561508,0.990048742,0.886221947,0.999913274,0.897740043,0.937161189,0.832278222,0.98833536,0.970807908,0.855154872,0.819448437
1044,1044,1104,6.6,nonconstant pointer to nonconstant data nonconstant pointer to constant data constant pointer to nonconstant data constant pointer to constant data,5,5,5,0.016551733,0.983448267,0.978879623,0.965997517,0.970157847,0.991224973,0.899670419,0.999921673,0.907644085,0.930528427,0.814574854,0.986096311,0.965204433,0.984531224,0.980717812
1045,1045,1105,6.6,"pass by value, pass by reference with reference arguments, pass by reference with pointer arguments",2,3,2.5,0.070713341,0.929286659,0.909768214,0.194533378,0.293085214,0.988810099,0.872059883,0.999913032,0.897455177,0.829512584,0.544955545,0.863010184,0.657167366,0.499860346,0.376568997
1046,1046,1106,6.6,"you can pass it where either the pointer cant be moved, the data pointed to cant be changed, or both or neither",5,3,4,0.061418235,0.938581765,0.921628975,0.23196952,0.325940905,0.988413315,0.867523232,0.999938615,0.92762016,0.85454197,0.611760964,0.985557028,0.963854816,0.620701313,0.527198899
1047,1047,1107,6.6,"there are only two ways to pass something, by value and by reference. Use of dot or pointer operators within the receiving function and use of '&' operator inside the passing function",2,3,2.5,0.050833404,0.949166596,0.935135453,0.15509972,0.25847641,0.991521935,0.903065754,0.999951013,0.942238829,0.855014174,0.613021314,0.981473797,0.953636065,0.664588213,0.581904515
1048,1048,1108,6.7,A pointer that points to the memory address of the beginning part of a functions.  pretty much the pointer points to the function so it can be called to execute.,5,5,5,0.025383174,0.974616826,0.967610509,0.366796613,0.444271401,0.99612067,0.955645544,0.999948678,0.939485273,0.962314693,0.899414922,0.975689076,0.939159141,0.806749821,0.759110885
1049,1049,1109,6.7,A function pointer is a pointer that contains the address of the  function in memory.,5,5,5,0.019891381,0.980108619,0.974618158,0.556563437,0.610819549,0.997116872,0.967035656,0.999957612,0.950019282,0.948214851,0.861781324,0.965913098,0.914693641,0.820117712,0.775774142
1050,1050,1110,6.7,"Function Pointers are pointers, i.e. variables, which point to the address of a function.",5,5,5,0.056197166,0.943802834,0.928291174,0.439000189,0.507640602,0.990028145,0.885986443,0.999918187,0.903533272,0.946824948,0.858071563,0.972861324,0.932082369,0.761906207,0.703212712
1051,1051,1111,6.7,"A pointer to a function is the address where the code for the function resides. They can be passed to functions, returned from functions, stored in arrays and assigned to other pointers.",5,5,5,0.022559404,0.977440596,0.971213702,0.591336966,0.641338407,0.994783311,0.940354801,0.999945751,0.936033833,0.953300554,0.875355469,0.984210237,0.960484318,0.824260831,0.780938596
1052,1052,1112,6.7,It contains the address of the function in memory.,5,5,5,0.012718737,0.987281263,0.983770611,0.72635138,0.759833306,0.99833646,0.980979855,0.999969577,0.9641274,0.94300513,0.847876165,0.953768199,0.884299647,0.839162946,0.799514284
1053,1053,1113,6.7,when it is dereferenced a function pointer calls its function with zero or more arguments.,4,3,3.5,0.03490454,0.96509546,0.955461036,0.320933729,0.404020012,0.993624039,0.927100228,0.999928574,0.915780333,0.930246581,0.813822584,0.944960159,0.862256522,0.53726548,0.423195003
1054,1054,1114,6.7,a pointer to a function,5,2,3.5,0.057078481,0.942921519,0.927166598,0.144721553,0.249368051,0.983120591,0.807008685,0.999782029,0.742987735,0.942195382,0.845714883,0.935598981,0.838829107,0.656616569,0.571967752
1055,1055,1115,6.7,"A pointer to a function itself, contains the address of the function and can be used to call that function",5,5,5,0.028075516,0.971924484,0.964175021,0.437350422,0.50619269,0.991188949,0.899258538,0.999941413,0.930919605,0.949033741,0.863967007,0.960418139,0.90094188,0.782985806,0.729488719
1056,1056,1116,6.7,"Function Pointers are pointers, i.e. variables, which point to the address of a function.",5,5,5,0.056197166,0.943802834,0.928291174,0.439000189,0.507640602,0.990028145,0.885986443,0.999918187,0.903533272,0.946824948,0.858071563,0.972861324,0.932082369,0.761906207,0.703212712
1057,1057,1117,6.7,A pointer to a function that contains the addresses of the function.,5,5,5,0.026847839,0.973152161,0.965741564,0.559576154,0.613463649,0.996526915,0.960290363,0.99990974,0.893573731,0.918134205,0.781493691,0.948801792,0.871870647,0.622160792,0.52901816
1058,1058,1118,6.7,a pointer that contains the address of a function,5,5,5,0.029746115,0.970253885,0.9620433,0.425054461,0.495401185,0.995816644,0.952169457,0.999920891,0.90672124,0.895650572,0.721483088,0.940339482,0.850692751,0.703600168,0.630533446
1059,1059,1119,6.7,a function pointer is a pointer to a function. It can be used in substitution for calling a function.,5,5,5,0.035355508,0.964644492,0.95488559,0.339907438,0.420672217,0.99318916,0.922128018,0.999911595,0.895760371,0.931923883,0.818299437,0.960508407,0.901167786,0.672828555,0.592176213
1060,1060,1120,6.7,Points to the memory address of a function.  Kind of like breaking a branch off of a tree object and hitting other objects with it.,5,5,5,0.021447301,0.978552699,0.97263277,0.38752985,0.46246785,0.996525182,0.960270544,0.999962973,0.956340848,0.976869326,0.938262394,0.969377521,0.923363755,0.791195393,0.739722079
1061,1061,1121,6.7,"They are pointers that contain the addresses to functions, they can be passed and returned from functions, as well as stored in arrays and assigned to other function pointers.",5,5,5,0.032716811,0.967283189,0.958252627,0.323106289,0.405926751,0.990238545,0.888392069,0.999898457,0.880269847,0.92455836,0.798640271,0.971728797,0.929248091,0.719473422,0.650319671
1062,1062,1122,6.7,Pointer variables that point to function addresses.,5,5,5,0.065690756,0.934309244,0.916177144,0.42048654,0.491392166,0.995837617,0.952409247,0.999938974,0.928044016,0.924847113,0.799410975,0.965215479,0.91294777,0.719622433,0.650505416
1063,1063,1123,6.7,Contains the address of the function in memory.,5,5,5,0.013246298,0.986753702,0.983097431,0.718299091,0.752766244,0.997382921,0.970077535,0.999971172,0.96600869,0.928315647,0.808668768,0.941001026,0.852348341,0.795449793,0.745025248
1064,1064,1124,6.7,"a pointer that points to a function itself, which allows passing a function as a parameter to another function.",5,3,4,0.038619578,0.961380422,0.950720565,0.32677564,0.409147144,0.991418003,0.901877444,0.999909002,0.892703344,0.937694046,0.83370046,0.968702622,0.921674743,0.646217346,0.55900498
1065,1065,1125,6.7,pointers that contain the addresses of functions.,5,5,5,0.048620343,0.951379657,0.937959368,0.496517301,0.558120281,0.992993923,0.919895776,0.999919829,0.905469315,0.928535998,0.809256902,0.950695477,0.87660981,0.649512768,0.563112768
1066,1066,1126,6.7,is a pointer that contains the address of a function,5,5,5,0.031260729,0.968739271,0.960110619,0.412725747,0.484580935,0.995482964,0.948354314,0.999910952,0.895001894,0.895650572,0.721483088,0.940339482,0.850692751,0.703600168,0.630533446
1067,1067,1127,6.7,a pointer that contains the address of the function definition,4,5,4.5,0.023234427,0.976765573,0.970352358,0.473838687,0.53821648,0.997005381,0.965760919,0.999938323,0.927276013,0.928472973,0.809088684,0.615014995,0.03653113,0.701689422,0.628151675
1068,1068,1128,6.7,"A function pointer contains the memory address of a function. Using a function pointer, a function can be passed to or returned by another function. Function pointers can also be stored in arrays.",5,5,5,0.033226013,0.966773987,0.957602873,0.47705093,0.541035693,0.992928473,0.919147449,0.999942018,0.931632638,0.963508583,0.90260151,0.970187356,0.925390459,0.805136681,0.757100084
1069,1069,1129,6.7,Function pointer is a pointer to a function. function pointer contains address of functions,5,5,5,0.053020358,0.946979642,0.932344852,0.397534668,0.471248542,0.994926032,0.941986607,0.999923918,0.910290712,0.939571607,0.838711819,0.954404618,0.885892358,0.697998285,0.623550623
1070,1070,1130,6.7,a pointer that contains the address of a function in memory.,5,5,5,0.018716335,0.981283665,0.976117543,0.597770751,0.646984995,0.996602093,0.961149908,0.999940969,0.93039526,0.928315647,0.808668768,0.941001026,0.852348341,0.795449793,0.745025248
1071,1071,1131,6.7,it contains the address of the function in memory,5,5,5,0.015824795,0.984175205,0.979807212,0.641622067,0.685470939,0.996495083,0.959926411,0.999966922,0.960997745,0.928315647,0.808668768,0.941001026,0.852348341,0.795449793,0.745025248
1072,1072,1132,6.7,it is a pointer that points to the address of a function.,5,5,5,0.031955004,0.968044996,0.959224709,0.421414703,0.492206765,0.994752565,0.940003274,0.999925505,0.912162368,0.907767949,0.75382533,0.940339482,0.850692751,0.771322489,0.714950236
1073,1073,1133,6.7,"When dereferenced, a function pointer invokes a function, passing it zero or more arguments just like a normal function. In programming languages like C, function pointers can be used to simplify code, such as replacing large switch statements.",4,4,4,0.027332962,0.972667038,0.965122537,0.381365985,0.457058157,0.985547253,0.834754014,0.999924179,0.910598267,0.938964746,0.837092059,0.982207734,0.955472826,0.74561882,0.682910264
1074,1074,1134,7.1,"Consists of sequence of nodes, each containing a number of data fields and one or two links called pointers that point to the next or previous nodes. ",4,5,4.5,0.032276034,0.967723966,0.958815067,0.241565198,0.334362516,0.988300967,0.866238704,0.999891258,0.871781058,0.93605208,0.829317922,0.957782263,0.8943453,0.788658261,0.736559511
1075,1075,1135,7.1,A linked list is a list in which each item in the list points to the next item in the list.,4,5,4.5,0.052262306,0.947737694,0.933312143,0.180976287,0.281186883,0.990984235,0.89691794,0.999836301,0.806979906,0.943475715,0.849132194,0.977988876,0.944914653,0.682092309,0.603723608
1076,1076,1136,7.1,"A linked list is a chain of structs or records called nodes and you have the ability to add, delete, or retrieve items. ",4,5,4.5,0.029205143,0.970794857,0.962733592,0.274075002,0.362894624,0.992470704,0.91391353,0.999949557,0.940521895,0.944484347,0.851824313,0.972551868,0.93130792,0.820915699,0.776768844
1077,1077,1137,7.1,"A list of elements, or nodes, that are linked to one another such that each element points to the next element.",4,5,4.5,0.025030077,0.974969924,0.968061069,0.387665927,0.462587278,0.987494093,0.857013275,0.999888789,0.868870084,0.953385141,0.875581239,0.97453793,0.936278267,0.786611617,0.734008341
1078,1078,1138,7.1,"A sequence of nodes, each containing data fields (specified by programmer) and pointer(s) which can point to the next or previous nodes.",4,5,4.5,0.034394681,0.965605319,0.956111627,0.244894967,0.337284875,0.986955012,0.850849679,0.999914468,0.899148223,0.943375371,0.848864368,0.974070358,0.935108114,0.797531486,0.747620105
1079,1079,1139,7.1,a list of nodes where each node contains a data member and also a pointer to the next node.,4,5,4.5,0.032804787,0.967195213,0.958140367,0.205293208,0.302528539,0.996531043,0.960337559,0.999902662,0.885227846,0.926461581,0.803720119,0.962052631,0.905032382,0.684045374,0.60615813
1080,1080,1140,7.1,A list of items linked together.  Each item is linked to its successor.,4,5,4.5,0.033168554,0.966831446,0.957676192,0.310387582,0.394764225,0.996457214,0.959493436,0.9999239,0.910269218,0.964243436,0.904562891,0.972263756,0.930586887,0.766525745,0.70897103
1081,1081,1141,7.1,A linked list is a chain of nodes that each store a single piece of data and pointer variables that point to other nodes in the list.,4,5,4.5,0.025678515,0.974321485,0.967233647,0.209834516,0.306514201,0.992061926,0.90923976,0.999946131,0.936482674,0.938528209,0.835926907,0.945998037,0.86485393,0.772193909,0.716036472
1082,1082,1142,7.1,"one of the fundamental data structures, and can be used to implement other data structures. It consists of a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes. ",4,5,4.5,0.02882421,0.97117579,0.963219671,0.34293592,0.423330153,0.987767584,0.860140247,0.999968645,0.963029346,0.932969336,0.821089834,0.963604751,0.90891674,0.821338356,0.777295691
1083,1083,1143,7.1,"A data structure in a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes.",4,5,4.5,0.039584994,0.960415006,0.949488673,0.228388667,0.322798183,0.98702459,0.851645203,0.999972391,0.967445732,0.918804788,0.78328353,0.971571292,0.928853917,0.806804955,0.75917961
1084,1084,1144,7.1,Information in memory linked to the next piece of information and can only be linked forwards and not backwards.,2,5,3.5,0.036427855,0.963572145,0.953517252,0.213682175,0.309891084,0.996980488,0.965476307,0.999945736,0.936016024,0.974482659,0.93189219,0.973318718,0.93322705,0.622212827,0.529083022
1085,1085,1145,7.1,"A linked list is a data structure that is not necessarily in the same contiguous memory space (such as arrays). It holds the data type and points to the next data item in the list, or in a doubly linked list also to the previous item.",5,5,5,0.031933665,0.968066335,0.959251938,0.2999551,0.385608196,0.985080276,0.82941482,0.99994257,0.932284068,0.889993026,0.706382649,0.973075001,0.93261712,0.786877453,0.73433971
1086,1086,1146,7.1,A linked list is a data structure containing one or more data elements with a pointer to the next node.,4,5,4.5,0.030359685,0.969640315,0.961260371,0.309278071,0.393790467,0.994618937,0.938475424,0.999923719,0.910055932,0.935392731,0.827558067,0.968830339,0.921994369,0.816445589,0.771196791
1087,1087,1147,7.1,"A series of ""Nodes"" structures with a value and a pointer that point to a similar ""Node"". Not quite an array, but still can carry a list of values. ",4,5,4.5,0.028891027,0.971108973,0.963134411,0.306613207,0.391451659,0.995373971,0.947108138,0.999886293,0.8659264,0.89594697,0.722274198,0.971938652,0.929773277,0.785270333,0.732336413
1088,1088,1148,7.1,A data type that contains a pointer to at least the next  element in a list.,4,5,4.5,0.032350659,0.967649341,0.958719844,0.320462287,0.403606252,0.995048059,0.943381811,0.999917899,0.903193363,0.938334946,0.835411073,0.967315048,0.918202181,0.758348823,0.698778385
1089,1089,1149,7.1,Each component contains a Node - a data item and a pointer to the next item in the list,4,5,4.5,0.042571306,0.957428694,0.945678073,0.162947595,0.265364069,0.989693366,0.882158746,0.99986205,0.83734148,0.909739699,0.759088087,0.964270559,0.910583,0.738340735,0.673838033
1090,1090,1150,7.1,"A linked list is a chain of structs or records called nodes.  Each node has at least two members, one of which points to the next item or node in the list.",4,5,4.5,0.031635523,0.968364477,0.959632374,0.278564513,0.366834827,0.990096182,0.886764352,0.999922008,0.908039159,0.900209909,0.733652321,0.968701168,0.921671104,0.795116186,0.744609402
1091,1091,1151,7.1,"An array based list that uses an implicit ordering scheme, often using pointers.",1,4,2.5,0.033661425,0.966338575,0.957047278,0.364177316,0.441972586,0.994701566,0.939420168,0.999906997,0.890338718,0.929144835,0.810881937,0.968964138,0.922329217,0.802923739,0.754341622
1092,1092,1152,7.1,a series of structures containing data items and a pointer that links the structure to the next structure.,4,5,4.5,0.0336833,0.9663167,0.957019365,0.275822818,0.364428589,0.997104649,0.966895899,0.999959279,0.951984879,0.938576758,0.836056488,0.951840442,0.879475215,0.733460128,0.66775429
1093,1093,1153,7.1,"A linked list is a collection of Objects each containing at least one data member, and a pointer to the next object in the list (and the previous object in the case of a doubly linked list)",4,5,4.5,0.03831929,0.96168071,0.95110374,0.205002949,0.302273794,0.987953543,0.862266411,0.999923522,0.909823954,0.915457408,0.774349107,0.958390447,0.895867349,0.806484878,0.75878063
1094,1094,1154,7.1,A link list is a data structure which is built from structures and pointers. It forms a chain of nodes with pointers representing the links of the chain and holding the entire thing together,4,4,4,0.032856524,0.967143476,0.95807435,0.248268142,0.34024533,0.992794542,0.917616144,0.999946099,0.936444105,0.878762669,0.676407934,0.954664846,0.886543608,0.775975466,0.720750234
1095,1095,1155,7.1,its a list of pointers that are linked 2 each other. every pointer points to the next pointer which has the next element,4,5,4.5,0.03672415,0.96327585,0.953139173,0.172558323,0.273798888,0.994577747,0.938004479,0.999861106,0.836228239,0.892727358,0.713680798,0.918801528,0.796791566,0.683404386,0.605359129
1096,1096,1156,7.1,linear collection of self-referential nodes connected by pointers.,4,4,4,0.051479995,0.948520005,0.934310389,0.343479186,0.423806949,0.997991568,0.97703652,0.999966012,0.959923863,0.975837584,0.935508592,0.917421257,0.79333728,0.731997132,0.665930646
1097,1097,1157,7.1,the items of a data structure are linked to each other using pointers,4,5,4.5,0.037421048,0.962578952,0.952249916,0.144348636,0.249040762,0.995952259,0.953720017,0.999900159,0.882276576,0.966316852,0.910097003,0.815936307,0.539359622,0.731143057,0.66486603
1098,1098,1158,7.1,A list of objects where each object contains a link to the next item in the list,4,5,4.5,0.042228043,0.957771957,0.946116084,0.160771385,0.263454126,0.996434623,0.959235137,0.999896889,0.878420091,0.943878589,0.850207496,0.974403211,0.935941117,0.712500215,0.641627474
1099,1099,1159,7.1,"A linked list is one of the fundamental data structures, and can be used to implement other data structures. It consists of a sequence of nodes, each containing arbitrary data fields and one or two references (""links"") pointing to the next and/or previous nodes.  ",4,5,4.5,0.027399361,0.972600639,0.96503781,0.357524306,0.436133596,0.983811574,0.814909064,0.99996824,0.962551594,0.90432488,0.744635505,0.97126872,0.928096696,0.829844534,0.787898758
1100,1100,1160,7.2,Elements can be inserted into a link list at any point and does not need to be resized unlike an array needs to be.,5,5,5,0.033039927,0.966960073,0.957840323,0.444499493,0.512467045,0.994138753,0.932985228,0.999919445,0.905016617,0.948769063,0.86326056,0.946096746,0.865100961,0.678103268,0.598751214
1101,1101,1161,7.2,"Unlike arrays, linked lists can insert and delete without shifting data and change in size easily.",5,5,5,0.031632304,0.968367696,0.959636481,0.436276972,0.505250581,0.990372218,0.889920414,0.999953646,0.945343228,0.917231958,0.779085522,0.946777154,0.86680376,0.702199399,0.628787368
1102,1102,1162,7.2,"Array size is fixed,but Linked is not fixed.",5,5,5,0.030590057,0.969409943,0.960966411,0.312909454,0.396977537,0.990703248,0.893705268,0.999943044,0.932842292,0.964993791,0.906565648,0.935647279,0.838949978,0.657415986,0.572964237
1103,1103,1163,7.2,You can insert into and delete items from a pointer-based linked list without shifting data.,5,4,4.5,0.037994266,0.962005734,0.951518478,0.445567101,0.513404028,0.997014441,0.965864502,0.999942687,0.932420996,0.917812253,0.780634375,0.952381278,0.880828719,0.669014335,0.587421735
1104,1104,1164,7.2,Arrays must be of a defined size... elements can be added to a linked list w/o defining any size.,5,5,5,0.020630896,0.979369104,0.973674521,0.467725813,0.532851539,0.995986786,0.95411478,0.999931356,0.919060702,0.918657374,0.78289007,0.950558591,0.876267237,0.716368675,0.646449562
1105,1105,1165,7.2,"The principal benefit of a linked list over a conventional array is that the order of the linked items may be different from the order that the data items are stored in memory or on disk, allowing the list of items to be traversed in a different order. A linked list is a self-referential datatype because it contains a pointer or link to another datum of the same type. Linked lists permit insertion and removal of nodes at any point in the list in constant time",3,5,4,0.020669043,0.979330957,0.973625844,0.545303881,0.600937642,0.97565876,0.721693586,0.999898238,0.880010554,0.814893032,0.5059348,0.954176018,0.88532026,0.769569933,0.712765652
1106,1106,1166,7.2,You can expand when you need it.  You do not have to predetermine the size.,5,5,5,0.049374819,0.950625181,0.93699664,0.255853295,0.346902411,0.990226936,0.888259329,0.999910537,0.894512569,0.96613567,0.909613413,0.952063306,0.880032958,0.663209856,0.580186374
1107,1107,1167,7.2,Linked lists are able to grow and shrink in size as needed,5,5,5,0.024202347,0.975797653,0.969117271,0.323718786,0.406464307,0.995216508,0.945307772,0.999951833,0.94320546,0.94251766,0.846575069,0.952963096,0.882284785,0.679230928,0.600156858
1108,1108,1168,7.2,Linked list is able to grow in size as needed. Does not require the shifting of items during insertions and deletions,5,5,5,0.022113681,0.977886319,0.971782455,0.411096841,0.483151332,0.989167026,0.876140811,0.999915509,0.900375705,0.920029005,0.786551062,0.951025606,0.877435995,0.707158267,0.634968664
1109,1109,1169,7.2,"A linked list is not fixed in size, and does not require the shifting of items during insertions and deletions.",5,5,5,0.028513849,0.971486151,0.963615699,0.463894218,0.529488754,0.982710464,0.802319486,0.999943359,0.933213973,0.951474297,0.870481044,0.94188817,0.85456852,0.698141754,0.623729458
1110,1110,1170,7.2,There is no limit as to how many you create where an array can only hold a given amount of information.,3,3,3,0.033353984,0.966646016,0.957439579,0.264164954,0.354197108,0.991593247,0.903881095,0.999951271,0.94254256,0.915960827,0.775692772,0.946443907,0.865969771,0.740834713,0.67694681
1111,1111,1171,7.2,Linked lists have constant time insertion and deletion,4,3,3.5,0.050105214,0.949894786,0.93606464,0.37492308,0.451403565,0.995888979,0.952996498,0.999834552,0.804917659,0.975194268,0.933791531,0.948212763,0.870396535,0.655177474,0.570173901
1112,1112,1172,7.2,"Linked lists can be grown dynamically, items don't require shifting, and they have a greater awesome factor than that of arrays.",5,5,5,0.021091938,0.978908062,0.973086221,0.398603886,0.472186937,0.988825429,0.872235157,0.999920025,0.90569995,0.930470376,0.814419911,0.944742242,0.86171116,0.691708028,0.615709732
1113,1113,1173,7.2,Linked lists have an indefinite size. They can be added to and taken away from very easily with little difficulty in the shifting of data.,5,5,5,0.021464705,0.978535295,0.972610562,0.469210744,0.534154783,0.99701729,0.965897086,0.999910824,0.894850976,0.946800573,0.858006504,0.947554915,0.868750195,0.736907363,0.672051315
1114,1114,1174,7.2,"Nearly infinite size, limited only by system memory and also the ability to expand the size dynamically.",5,5,5,0.033101082,0.966898918,0.957762288,0.222669855,0.317779088,0.98709313,0.852428851,0.999912904,0.897303865,0.90591896,0.748890231,0.943878437,0.85954939,0.732942402,0.667108938
1115,1115,1175,7.2,"They grow as needed, while arrays are of fixed size.",5,5,5,0.022165596,0.977834404,0.971716209,0.268474191,0.357979094,0.990593097,0.892445852,0.999950855,0.94205241,0.920888258,0.788844477,0.826308475,0.565317155,0.629491925,0.538156517
1116,1116,1176,7.2,Does not have a fixed size. Linked list is able to grow as needed. The time to access an array bases list takes a contant amount of time where as an linked-base like depends on 'i',5,5,5,0.019404829,0.980595172,0.97523901,0.427239925,0.497319249,0.988679489,0.870566541,0.999933744,0.921876878,0.893110656,0.714703851,0.953606956,0.883896118,0.778796375,0.724266536
1117,1117,1177,7.2,Linked lists can grow and shrink as you need them to.  Arrays have a fixed size.,5,5,5,0.01969403,0.98030597,0.974869982,0.445077449,0.512974286,0.994947237,0.942229053,0.999937132,0.925871315,0.964441177,0.905090677,0.950772225,0.87680188,0.64202559,0.553779899
1118,1118,1178,7.2,more memory can be allocated on the fly for more items,4,5,4.5,0.05153954,0.94846046,0.934234408,0.149928048,0.253937512,0.994891295,0.941589441,0.999953196,0.944812551,0.964560956,0.905410377,0.937206446,0.842851972,0.583952963,0.481391584
1119,1119,1179,7.2,"A linked list may be increased in size as needed, while an array's size is set when it is created",5,5,5,0.027369022,0.972630978,0.965076523,0.353332132,0.43245435,0.988508832,0.86861533,0.999971399,0.966276192,0.912137643,0.76548839,0.951381644,0.878327021,0.731551826,0.665375566
1120,1120,1180,7.2,"Array has a fixed size, but linked list is able to grow in size as needed",5,5,5,0.024403512,0.975596488,0.968860579,0.360945672,0.439136345,0.988851984,0.872538768,0.999929168,0.9164812,0.893767484,0.716456977,0.952426809,0.880942665,0.721678793,0.653068697
1121,1121,1181,7.2,its resizeable,5,5,5,0.184918165,0.815081835,0.764040336,0.042696979,0.159826563,0.99488365,0.941502036,0.999639823,0.575310735,0.945707306,0.855088487,0.942377397,0.855792866,0.362576872,0.205443287
1122,1122,1182,7.2,Linked lists do not have a set size and can grow or shrink as needed.,5,5,5,0.026521325,0.973478675,0.966158203,0.402835757,0.475901022,0.995152514,0.944576101,0.999949312,0.940233195,0.95584162,0.882137776,0.944679669,0.861554564,0.674821794,0.594660812
1123,1123,1183,7.2,linked lists are abe to grow as needed to a new size,5,5,5,0.032721698,0.967278302,0.95824639,0.370385677,0.44742133,0.991444702,0.902182701,0.999911224,0.89532335,0.913953615,0.770335364,0.919797254,0.799283484,0.599737346,0.501067031
1124,1124,1184,7.2,"The size is not fixed, easier sorting because of no shifting, easier to insert items into the list",5,5,5,0.034357131,0.96564287,0.956159542,0.26643908,0.356192986,0.987080439,0.852283744,0.999932393,0.920283713,0.920904821,0.788888685,0.957325812,0.893202979,0.69496733,0.619772495
1125,1125,1185,7.2,The size of array is restricted to declaration. Insertion/Deletion of values in middle of array is not possible.,5,5,5,0.023339987,0.976660013,0.970217661,0.393670082,0.467856802,0.993238642,0.922693782,0.999909043,0.892751275,0.890216283,0.706978539,0.962498556,0.906148361,0.769037068,0.712101427
1126,1126,1186,7.3,Array can retrieve memory from any place in the list while in a link list you have to traverse through each individual node.,5,5,5,0.01781404,0.98218596,0.977268891,0.369691461,0.446812055,0.993795481,0.92906042,0.999945837,0.936135664,0.965130024,0.906929264,0.981434566,0.953537885,0.801689386,0.752802985
1127,1127,1187,7.3,"Arrays require less memory than linked lists and allow direct access to a specified item. Also, insertion and deletion in arrays does not require a list traversal.",4,5,4.5,0.012542546,0.987457454,0.983995435,0.659862101,0.701479238,0.987816847,0.860703497,0.999961121,0.954156717,0.930594904,0.814752286,0.966946724,0.917280408,0.862893462,0.829094695
1128,1128,1188,7.3,"Access to a particular element is very fast, because its location in memory can be determined mathematically and accessed directly.",5,5,5,0.017701387,0.982298613,0.977412639,0.475997418,0.540111082,0.994953568,0.942301443,0.999983393,0.98041809,0.979885109,0.946311758,0.98248012,0.956154503,0.808240592,0.760969152
1129,1129,1189,7.3,Arrays are good for random access and good for sequential access which are both in constant time. Where linked lists are linear for random access. Arrays are faster in this case.,5,5,5,0.025010228,0.974989772,0.968086396,0.450431585,0.517673324,0.975884066,0.72426963,0.999954348,0.946171076,0.943260338,0.848557335,0.976358833,0.940835284,0.778428912,0.723808489
1130,1130,1190,7.3,"An array is capable of accessing any part of that array based on the index. The link list must be traversed from the beginning or the end, that is, data can only be accessed if it is adjacent to the previous or next nodes.",5,5,5,0.016047657,0.983952344,0.979522836,0.581960321,0.63310903,0.989883943,0.88433771,0.999981432,0.978105607,0.950104949,0.866826146,0.982671956,0.956634594,0.855472922,0.819844891
1131,1131,1191,7.3,"On the other hand, arrays allow random access, while linked lists allow only sequential access to elements. Singly-linked lists, in fact, can only be traversed in one direction.",5,5,5,0.012992501,0.987007499,0.983421281,0.595992088,0.645423958,0.983073487,0.806470123,0.999972068,0.967064754,0.945136242,0.853564272,0.97504858,0.937556227,0.837108672,0.796953604
1132,1132,1192,7.3,You have to keep up with the head of the list.,1,3,2,0.03620702,0.96379298,0.953799042,0.1507909,0.254694791,0.985258371,0.83145107,0.999897275,0.878875084,0.955702598,0.881766716,0.836693293,0.591306346,0.625996411,0.533799311
1133,1133,1193,7.3,Arrays are easier to implement and require less memory,3,4,3.5,0.035147369,0.964852631,0.955151181,0.29164204,0.37831227,0.991920951,0.907627914,0.999978995,0.975232276,0.967053406,0.912062924,0.97841882,0.945990636,0.752213836,0.691131041
1134,1134,1194,7.3,Linked list has an increase complexity of the implementation. The linked list has an array that keeps growing which leads to a increase in memory.,2,3,2.5,0.017780662,0.982219338,0.977311483,0.531071186,0.58844637,0.989054118,0.874849878,0.999988405,0.986327763,0.986077711,0.962840305,0.987111788,0.96774578,0.79214251,0.740902675
1135,1135,1195,7.3,You don't have to iterate through the entire list to access elements.,5,4,4.5,0.031525075,0.968474925,0.959773307,0.461722344,0.527582617,0.991952659,0.907990444,0.999987452,0.985204379,0.974829662,0.932818369,0.976557299,0.941331968,0.784285307,0.731108564
1136,1136,1196,7.3,you can go forwards and backwards and point to any piece of data at any given time where linked lists have to point to the next piece of data.,2,4,3,0.030350327,0.969649673,0.961272312,0.263609469,0.353709588,0.985761766,0.83720666,0.999933302,0.92135579,0.935110727,0.826805376,0.967297317,0.918157807,0.753055692,0.692180426
1137,1137,1197,7.3,Take up less memory and are contiguously stored,4,4,4,0.054857314,0.945142686,0.930000856,0.093428656,0.204351031,0.988675447,0.870520334,0.99995162,0.942954134,0.964006305,0.903929969,0.978509431,0.946217401,0.66269362,0.579542879
1138,1138,1198,7.3,"Arrays, being fixed, are less error prone.",1,3,2,0.030012131,0.969987869,0.961703858,0.348088861,0.427852612,0.993302677,0.923425923,0.99990959,0.893395839,0.95369302,0.876402992,0.979562614,0.948853111,0.602802336,0.504887582
1139,1139,1199,7.3,"Arrays have a set list of values. Meaning you can pick a spot in the array such as a[7] picks the 8th spot in the array. With linked lists you have to keep track with pointers if you want to take specific nodes out, otherwise you must traverse the entire list. ",5,5,5,0.015388966,0.984611034,0.98036334,0.475446105,0.539627224,0.987844212,0.861016377,0.999966202,0.960148547,0.961717932,0.89782212,0.973216136,0.932970327,0.808765233,0.761623123
1140,1140,1200,7.3,"direct access to elements, and speed, linked lists have increased search times to access elements even if the list is sorted. ( like getting the last element without a pointer directly to the end of the list. )",5,4,4.5,0.012212694,0.987787306,0.984416333,0.652920187,0.695386692,0.982974501,0.805338362,0.999976155,0.971883967,0.939601903,0.838792682,0.949576607,0.87380971,0.83926785,0.799645049
1141,1141,1201,7.3,Array items are accessed directly with equal access time,5,5,5,0.046878338,0.953121662,0.940182205,0.4015733,0.474793032,0.993986046,0.931239253,0.999981858,0.978607977,0.982515058,0.953331301,0.982526633,0.956270907,0.841310203,0.80219087
1142,1142,1202,7.3,Array-bases implementations require less memory than a pointer-bases one.,3,4,3.5,0.059702873,0.940297127,0.923817815,0.290293783,0.377128977,0.988922593,0.873346084,0.999963901,0.957434969,0.969352112,0.918198353,0.976546609,0.941305215,0.73134017,0.665111733
1143,1143,1203,7.3,You can access specific elements quickly in an array.  In a linked list you must traverse the list to get access the same element.,5,5,5,0.015407145,0.984592855,0.980340143,0.620211184,0.666679758,0.991362022,0.901237374,0.999983868,0.98097875,0.942513469,0.846563883,0.96348071,0.908606313,0.813797891,0.7678964
1144,1144,1204,7.3,link lists only allow sequential access where arrays allow random access,5,4,4.5,0.063041091,0.936958909,0.919558175,0.355666012,0.434502671,0.991816835,0.906437495,0.999955455,0.94747607,0.924595523,0.798739462,0.959481698,0.898598329,0.74498266,0.682117282
1145,1145,1205,7.3,"Any entitiy in an array may accessed immediately, whereas a linked list must be traversed one item at a time because each object only points adjacent objects",5,5,5,0.020480931,0.979519069,0.97386588,0.488394767,0.550991569,0.996216715,0.956743684,0.999985218,0.982569874,0.96929004,0.918032677,0.981515563,0.953740589,0.820726097,0.776532502
1146,1146,1206,7.3,Array based implementation requires less memory than lined lists based implementation,3,4,3.5,0.051053226,0.948946774,0.934854956,0.3936373,0.46782803,0.992014932,0.908702443,0.999960465,0.953384173,0.961852779,0.898182037,0.957440224,0.893489308,0.745166838,0.682346863
1147,1147,1207,7.3,Array-based implementations require less memory than a pointer-based ones,3,4,3.5,0.083575845,0.916424155,0.893355376,0.258685976,0.349388503,0.989857055,0.88403028,0.999968133,0.96242493,0.971072865,0.922791179,0.985006035,0.962475893,0.712432623,0.64154322
1148,1148,1208,7.3,"You can go up and down an array , but you can only go one direction while traversing a linked list.",1,5,3,0.032468259,0.967531741,0.958569784,0.410144597,0.482315599,0.991378212,0.901422485,0.999955967,0.948080135,0.964239824,0.90455325,0.976471485,0.941117209,0.76244086,0.703879165
1149,1149,1209,7.3,"arrays allow for the random access of any item cotained a any time, linked lists must be gone through toget to the desired item",5,5,5,0.021533191,0.978466809,0.972523172,0.387156546,0.462140221,0.985044582,0.829006705,0.999962317,0.955567895,0.971897562,0.924992361,0.98579562,0.964451919,0.761912286,0.703220291
1150,1150,1210,7.3,"In arrays you have direct access to each element, but in linked lists you have to traverse the list up to the element that you need.",5,5,5,0.020086348,0.979913652,0.974369376,0.526670873,0.584584452,0.990336788,0.889515324,0.999953429,0.945087258,0.94164625,0.844249206,0.974657081,0.936576456,0.829800963,0.787844446
1151,1151,1211,7.3,"Array size is fixed. But Linked is not fixed, data is also accessed quicker in array list, also memory requirement is less and no pointers required. Arrays have random access and less overheads compared to Linked list have sequential access only with too much overheads and no cache memory support. On the other hand, arrays allow random access, while linked lists allow only sequential access to elements. Singly-linked lists, in fact, can only be traversed in one direction.",5,5,5,0.013717473,0.986282527,0.982496202,0.62082237,0.667216163,0.977202007,0.739338352,0.999972817,0.967947857,0.890469072,0.707653253,0.954875046,0.887069658,0.858956099,0.824186717
1152,1152,1212,7.4,They are passed by reference because you want the function to change the pointer,4,5,4.5,0.045510471,0.954489529,0.941927634,0.126496896,0.233373249,0.99416182,0.933248967,0.999965018,0.958752271,0.930757652,0.815186673,0.931968216,0.829742704,0.637316763,0.547910283
1153,1153,1213,7.4,Linked lists are passed as arguments to a function by passing the head pointer of the list by reference.,5,5,5,0.106366277,0.893633723,0.864274281,0.469757319,0.534634482,0.990698692,0.893653167,0.999699948,0.64620506,0.915849871,0.775396622,0.909422483,0.773319436,0.715454459,0.64530998
1154,1154,1214,7.4,- A function with access to a linked list's head pointer has access to the entire list.        - Pass the head ponter to a function as a reference argument.,5,5,5,0.115045846,0.884954155,0.853198959,0.453865439,0.520687033,0.981267655,0.78582308,0.999761754,0.719080933,0.849509117,0.59832788,0.94080941,0.8518688,0.646555662,0.559426696
1155,1155,1215,7.4,By using a node.,2,3,2.5,0.108736992,0.891263008,0.861249196,0.555063307,0.609502966,0.998205318,0.979480435,0.999887764,0.867660949,0.956083115,0.882782346,0.942772508,0.856781676,0.68751955,0.610488737
1156,1156,1216,7.4,Pass-by-reference,5,5,5,0.783685491,0.21631451,0,0.270118535,0.359422246,0.980687516,0.779190042,0.999151904,0,0.980530364,0.948033995,0.918742641,0.796644194,0.501807928,0.378996684
1157,1157,1217,7.4,you send a pointer to an object of the LinkedList class,2,3,2.5,0.159825921,0.840174079,0.796058594,0.038231764,0.155907684,0.991603969,0.904003684,0.999681061,0.623935066,0.895144343,0.720131923,0.862993158,0.657124757,0.526112914,0.409293179
1158,1158,1218,7.4,Passed as a pointer to the head.,5,3,4,0.12729454,0.87270546,0.837569354,0.303160071,0.388421028,0.99047323,0.891075341,0.999705587,0.652853939,0.981568035,0.950803621,0.854127565,0.634937599,0.48643291,0.359831516
1159,1159,1219,7.4,Passing the head pointer of a linked list to a function gives that function access to all nodes of that linked list,5,4,4.5,0.151587725,0.848412275,0.806570714,0.069024414,0.182932738,0.987226648,0.853955437,0.999634571,0.569117538,0.899866487,0.7327357,0.919453267,0.798422617,0.561913192,0.45391871
1160,1160,1220,7.4,You have to pass the head pointer to a function since it has access to the entire list.,5,3,4,0.138663769,0.861336231,0.823061968,0.252003491,0.343523645,0.990419231,0.890457939,0.999692618,0.637562443,0.897197569,0.725612146,0.933124893,0.83263742,0.625922322,0.533706958
1161,1161,1221,7.4,You pass the head pointer to a function as a reference argument.,5,5,5,0.113899767,0.886100233,0.85466138,0.5055269,0.566027523,0.993710346,0.928087026,0.999777174,0.737263533,0.905788073,0.748540884,0.926583894,0.816267824,0.702777922,0.629508505
1162,1162,1222,7.4,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
1163,1163,1223,7.4,passes a pointer to a linked list object,2,3,2.5,0.164679825,0.835320175,0.789864905,0.031125948,0.14967129,0.992321106,0.912203096,0.999766239,0.724369875,0.949980611,0.866494278,0.866317944,0.665445413,0.534113765,0.419266347
1164,1164,1224,7.4,"The linked list object contains the head, through which the other elements are accessible.",4,3,3.5,0.144521713,0.855478287,0.815587101,0.299210817,0.384954979,0.986392944,0.844423252,0.999768234,0.726722195,0.928263255,0.80852893,0.934821809,0.836884146,0.593637645,0.493463671
1165,1165,1225,7.4,By the head of the list. It takes the head address and traverses from there on in.,5,3,4,0.129711688,0.870288312,0.834485021,0.457216859,0.523628394,0.986161009,0.841771418,0.999691477,0.636216389,0.931960691,0.81839768,0.939706088,0.849107611,0.678084373,0.598727662
1166,1166,1226,7.4,as a pointer node.,3,3,3,0.123734415,0.876265585,0.842112153,0.366352141,0.443881312,0.993912487,0.930398212,0.99982022,0.788019283,0.992781767,0.980733963,0.890612809,0.726246082,0.368161201,0.212404229
1167,1167,1227,7.4,A method with access to a linked list's head pointer as access to the entire list,5,3,4,0.154797435,0.845202565,0.802475053,0.138224006,0.243665503,0.987820538,0.860745702,0.999744277,0.698474266,0.871354976,0.656636213,0.933234405,0.832911486,0.59053731,0.489599061
1168,1168,1228,7.4,A function with access to a linked list's head pointer has access to the entire list. Pass the head pointer to a function as a reference argument,5,5,5,0.129157424,0.870842576,0.835192274,0.332610101,0.414267736,0.983996693,0.817025637,0.999752542,0.708219444,0.826841384,0.5378259,0.939246403,0.847957197,0.649084449,0.562578863
1169,1169,1229,7.4,the head pointer is passed to a function as a reference argument.,5,5,5,0.112987042,0.887012959,0.855826039,0.480649591,0.544194044,0.991581921,0.903751605,0.999795196,0.758513145,0.956143373,0.882943179,0.92784322,0.819419431,0.690868855,0.61466369
1170,1170,1230,7.4,the pointer to the first element is passed to a function,5,3,4,0.166269898,0.833730102,0.787835936,-0.006185502,0.116925035,0.990253538,0.888563483,0.999727385,0.678555946,0.973530457,0.929350687,0.910084056,0.774975098,0.488581777,0.362510107
1171,1171,1231,7.4,"linked lists are passed by reference, specificly the Head pointer",5,5,5,0.111696303,0.888303697,0.85747305,0.422571302,0.49322185,0.991261713,0.90009049,0.999808874,0.774641329,0.938301058,0.835320623,0.940279793,0.850543373,0.714938164,0.644666411
1172,1172,1232,7.4,Pass the head pointer to a function as a reference argument,5,5,5,0.13525033,0.86474967,0.827417591,0.324348897,0.407017321,0.992162985,0.910395218,0.999784699,0.746135303,0.920793382,0.788591245,0.93383713,0.834419874,0.682612479,0.604372006
1173,1173,1233,7.4,by refrenece,5,5,5,0.195565701,0.8044343,0.750453846,0.362799704,0.440763529,0.987251631,0.854241076,0.999482849,0.390220787,0.980530364,0.948033995,0.918742641,0.796644194,0.274557382,0.0957258
1174,1174,1234,7.4,By passing the head pointer and going through the list as needed inside the function.,5,3,4,0.140515685,0.859484315,0.820698881,0.355801374,0.434621471,0.989807492,0.883463602,0.999606936,0.536532946,0.913687652,0.769625487,0.938684241,0.846550322,0.660829306,0.577218986
1175,1175,1235,7.4,linked lists are passed by using pointers,3,3,3,0.137951195,0.862048805,0.823971227,0.170020253,0.27157136,0.995475028,0.948263578,0.99977641,0.73636169,0.998281263,0.995412554,0.848041549,0.61970665,0.512058854,0.391774602
1176,1176,1236,7.4,the head object is passed to the function,4,3,3.5,0.173882008,0.826117992,0.778122717,-0.040677574,0.086653197,0.990038754,0.886107747,0.9997524,0.708051246,0.99779995,0.994127892,0.914392882,0.785758426,0.488524646,0.362438893
1177,1177,1237,7.4,"Linked lists permit insertion and removal of nodes at any point in the list in constant time,[1] but do not allow random access. ",0,3,1.5,0.146533907,0.853466094,0.813019498,0.237953931,0.331193101,0.988132976,0.864317967,0.999699431,0.645595133,0.903998732,0.74376499,0.933923595,0.834636263,0.515583277,0.396167843
1178,1178,1238,7.5,They are passed by reference because you want the function to change the pointer,0,1,0.5,0.045510471,0.954489529,0.941927634,0.126496896,0.233373249,0.99416182,0.933248967,0.999965018,0.958752271,0.930757652,0.815186673,0.931968216,0.829742704,0.637316763,0.547910283
1179,1179,1239,7.5,"In a circular linked list, every node has a successor which means that the last node's successor is the head or first node.",5,5,5,0.018749118,0.981250882,0.976075711,0.447606057,0.51519351,0.993104123,0.921155747,0.999977476,0.97344139,0.957830709,0.887446813,0.960073167,0.900078548,0.758296013,0.698712557
1180,1180,1240,7.5,A circular linked list is a linked list that links items in a continuous circle. This allows the full list to be traversed by starting at any item in the list; a fixed head or tail is not required.,5,4,4.5,0.013584435,0.986415565,0.982665961,0.691954136,0.729644693,0.992958713,0.919493197,0.999977969,0.974022553,0.954004433,0.877234178,0.968817578,0.921962434,0.82070595,0.776507389
1181,1181,1241,7.5,"In a circular linked list, the last node points to the first node.",5,5,5,0.009234011,0.990765989,0.988217198,0.681072831,0.720094756,0.995315163,0.946435749,0.999979703,0.976067208,0.982580916,0.953507081,0.961607561,0.903918544,0.802271485,0.753528579
1182,1182,1242,7.5,"On a circular linked list, the end element points to the head, thus making the circle. A basic link list has nothing pointing to the head, and the last element points to null.",5,5,5,0.009368777,0.990631223,0.988045233,0.784466028,0.810837411,0.986631408,0.847149742,0.999968795,0.963205922,0.954936191,0.879721114,0.969977081,0.924864222,0.935376167,0.919445368
1183,1183,1243,7.5,the circular linked list's last node points to the begining of the list while a standard linked list points to NULL,5,5,5,0.008859992,0.991140008,0.988694455,0.749185026,0.77987317,0.995661677,0.950397635,0.999979923,0.976326335,0.977934702,0.941105967,0.957108187,0.892658348,0.826589525,0.783841345
1184,1184,1244,7.5,The last item in the list points to the head,5,5,5,0.012144327,0.987855673,0.98450357,0.713865817,0.748875398,0.998838959,0.986725196,0.999975803,0.971469101,0.979976823,0.94655655,1,1,0.971227944,0.964135094
1185,1185,1245,7.5,"In a circular linked list, the last node points back to the first node, there is no NULL",5,5,5,0.01661098,0.98338902,0.978804023,0.545530379,0.601136427,0.992278769,0.911719042,0.999969669,0.964236456,0.981789152,0.9513938,0.963331802,0.908233654,0.811878383,0.765503707
1186,1186,1246,7.5,"Circular linked lists are most useful for describing naturally circular structures, and have the advantage of regular structure and being able to traverse the list starting at any point.",2,3,2.5,0.018843293,0.981156707,0.975955542,0.494954526,0.556748718,0.990763585,0.89439513,0.999947557,0.938164259,0.959725741,0.892504804,0.966419553,0.915961103,0.738770545,0.674373796
1187,1187,1247,7.5,A circular linked list has the last node point back to the head of the linked list.,5,5,5,0.006233335,0.993766666,0.992046128,0.846547127,0.865322656,0.996453209,0.959447637,0.999975927,0.971615269,0.985990367,0.962607177,0.941675643,0.854036647,0.887315631,0.859537259
1188,1188,1248,7.5,Basic linked list points to a NULL at the end and circular points to the head at the end.,5,5,5,0.018566787,0.981433213,0.976308369,0.644725382,0.688194553,0.997014052,0.965860061,0.999974231,0.969615612,0.942394768,0.84624706,0.959448673,0.898515681,0.875984192,0.845412466
1189,1189,1249,7.5,in a circular linked list the the last item points to the first item.,5,5,5,0.008850992,0.991149008,0.988705939,0.73947978,0.771355398,0.996574957,0.96083965,0.999986859,0.984504687,0.965011574,0.906613112,0.952289924,0.880600095,0.856860757,0.821574846
1190,1190,1250,7.5,"The circular linked list's tail points to the head, whereas the basic linked list's tail points to a NULL.",5,5,5,0.010154307,0.989845693,0.98704288,0.711553335,0.746845857,0.994168835,0.933329175,0.999955225,0.947204684,0.957737785,0.887198791,0.970049331,0.925045036,0.830480039,0.788690924
1191,1191,1251,7.5,a basic linked list has an end with a null value where a circular linked list has a pointer from the end to the beginning,5,5,5,0.01959604,0.98040396,0.97499502,0.556344628,0.610627513,0.995533033,0.948926779,0.999926367,0.913178187,0.977495692,0.939934214,0.945593489,0.863841503,0.757476509,0.697691034
1192,1192,1252,7.5,"how to determine the end of the list, in basic linked lists the last element links to a null pointer, while circular linked lists link to the head element at the end.",5,5,5,0.009623826,0.990376174,0.987719786,0.790543437,0.816171226,0.988515138,0.868687426,0.999963171,0.956574481,0.925187495,0.800319482,0.964131129,0.910234061,0.860882103,0.826587509
1193,1193,1253,7.5,"No Node in a circular linked list contains NULL, the last Node points pack to a Node within the list.",5,5,5,0.012019336,0.987980664,0.984663062,0.539451063,0.595800938,0.99501831,0.943041673,0.999950774,0.941956806,0.968496972,0.915915916,0.965022204,0.912464077,0.754769385,0.694316567
1194,1194,1254,7.5,"The difference between a circular linked list and a basic linked list is that a circular linked list, the last node references the first node. Every node in a circular linked list has a successor and no node in a circular linked list contains NULL.",5,5,5,0.011364341,0.988635659,0.98549885,0.708401263,0.744079452,0.990646945,0.893061523,0.999968444,0.962792023,0.956001785,0.882565269,0.967959721,0.919815549,0.709655225,0.638081156
1195,1195,1255,7.5,No node in a circular linked list contains NULL.,3,4,3.5,0.027962387,0.972037613,0.964319377,0.562503815,0.6160331,0.998199105,0.979409402,0.999961551,0.954664435,0.966394117,0.910303229,0.956686936,0.891604119,0.51980418,0.401429256
1196,1196,1256,7.5,in a circular linked list the last element points to the head of the list,5,5,5,0.002309084,0.997690916,0.997053558,0.943678439,0.950569591,0.997600573,0.972566073,0.99999414,0.993090181,0.986426473,0.963771178,0.94054369,0.851203805,0.971700132,0.964723682
1197,1197,1257,7.5,"In a regular linked list the last object points to NULL. In a circular linked list, the last object points back to the beginning of the list",5,5,5,0.004710317,0.995289683,0.993989532,0.773391128,0.801117566,0.994609009,0.938361911,0.999980612,0.977138954,0.96676051,0.911281161,0.966881621,0.91711748,0.884501159,0.856028982
1198,1198,1258,7.5,"In circular linked list each node has successor, no node contains NULL, while in basic linked list last node contain NULL.",3,3,3,0.024259388,0.975740612,0.969044484,0.487140864,0.549891086,0.990659691,0.893207249,0.999960944,0.953948028,0.951901654,0.871621694,0.959222636,0.897949997,0.67994839,0.601051183
1199,1199,1259,7.5,"in a circular linked lists, the last element points to the first",5,5,5,0.009468734,0.990531266,0.987917686,0.810531378,0.833713568,0.994272258,0.934511659,0.999978336,0.974455608,0.994754978,0.98600062,0.964619589,0.911456487,0.883612871,0.854921719
1200,1200,1260,7.5,"A circular linked list does not have a last element. Instead, it's last item points to the head of the list.",5,5,5,0.010678887,0.989321113,0.986373504,0.838975847,0.858677751,0.994639391,0.938709291,0.999959341,0.952057996,0.979569888,0.945470408,0.973467283,0.933598851,0.945878267,0.932536378
1201,1201,1261,7.5,"in a circular linked list, the last node contains a pointer that goes back to the first node; in a basic linked list, the last node contains a null pointer ",5,5,5,0.015575886,0.984424114,0.980124826,0.570659876,0.623191236,0.985046441,0.829027968,0.999976898,0.972759706,0.947272761,0.859266811,0.967007189,0.917431729,0.782936096,0.729426755
1202,1202,1262,7.5,"in a circular linked list, the last object is linked back to the first object.",5,5,5,0.015582323,0.984417677,0.980116612,0.624864101,0.670763373,0.993220827,0.922490086,0.999974478,0.969906575,0.976078057,0.936150434,0.920548757,0.801164206,0.789320827,0.737385407
1203,1203,1263,7.5,"In the case of a non circular link list, if you are at the last node of the list and u want to move to first u need to go to one, step back till u reach to first. But in circular link list from last to first you need to make only one move.  In a single link list u can move only in one direction but in double link list u can move in any direction back or forward or forward.  ",2,5,3.5,0.024243712,0.975756288,0.969064487,0.533348262,0.590444837,0.986696107,0.847889475,0.999915953,0.900899036,0.905908723,0.748862908,0.950108948,0.875141954,0.779704094,0.72539802
1204,1204,1264,7.6,they can traverse in both directions,3,4,3.5,0.044459641,0.955540359,0.943268516,0.165866628,0.267925948,0.98096569,0.782370549,0.999976468,0.972253182,0.832772008,0.553655207,0.97950566,0.948710577,0.586578906,0.484664856
1205,1205,1265,7.6,In a doubly linked list you can delete a node without having to traverse the list.,5,4,4.5,0.021779597,0.978220403,0.972208753,0.393837541,0.468003772,0.9908931,0.895875941,0.999967147,0.961262294,0.947919464,0.860992913,0.970157556,0.925315881,0.735376835,0.670143491
1206,1206,1266,7.6,A doubly-linked list allows you to delete a node without traversing the list to establish a trailing pointer.,5,4,4.5,0.027139068,0.972860932,0.96536995,0.326725632,0.409103254,0.991797503,0.906216464,0.999957702,0.950125959,0.947334873,0.859432593,0.986279364,0.965662544,0.735279381,0.670022014
1207,1207,1267,7.6,A doubly linked list allows you to traverse the list in either direction. Each node points to its successor as well as to its predecessor.,3,4,3.5,0.025153339,0.974846661,0.967903784,0.25669387,0.347640138,0.992066362,0.909290479,0.999977522,0.973495503,0.959884704,0.892929089,0.981386264,0.953417003,0.789097011,0.737106418
1208,1208,1268,7.6,"Doubly-linked lists can traverse backwards, though they still cannot access data at any point in the list, it can be shorter to traverse backwards.",3,4,3.5,0.018017232,0.981982768,0.977009613,0.299384743,0.385107625,0.994854859,0.941172851,0.999981527,0.978218243,0.950805142,0.868695016,0.983530136,0.958782287,0.767585039,0.710291454
1209,1209,1269,7.6,you can traverse the list from front to back and back to front,3,4,3.5,0.036287427,0.963712573,0.953696442,0.156127185,0.259378161,0.985928161,0.839109141,0.999955026,0.946970113,0.908300988,0.755248053,0.96593084,0.914738043,0.619877994,0.526172621
1210,1210,1270,7.6,You can traverse the list in reverse.,3,4,3.5,0.030232847,0.969767153,0.96142222,0.333753705,0.415271416,0.986402815,0.844536111,0.999969926,0.964539294,0.896262335,0.723115932,0.979305779,0.948210352,0.661382556,0.57790862
1211,1211,1271,7.6,Doubly linked lists can be traversed in both directions,3,4,3.5,0.03123951,0.96876049,0.960137696,0.254032642,0.345304521,0.988131839,0.864304963,0.99997172,0.966654999,0.886130713,0.696073828,0.979505672,0.948710607,0.717789233,0.648220307
1212,1212,1272,7.6,"Double-linked lists require more space per node, and their elementary operations are more expensive; but they are often easier to manipulate because they allow sequential access to the list in both directions.",4,3,3.5,0.017030418,0.982969582,0.978268811,0.33420071,0.415663729,0.988831907,0.87230922,0.999979658,0.97601415,0.969112374,0.917558473,0.976149307,0.940310921,0.802651167,0.754001857
1213,1213,1273,7.6,You can traverse forwards and backwards through nodes.,3,4,3.5,0.043958247,0.956041753,0.943908306,0.129757702,0.236235083,0.988042425,0.863282652,0.999947499,0.938095686,0.870040742,0.653128418,0.975364565,0.938347015,0.605152428,0.507817004
1214,1214,1274,7.6,You can point both forwards and backwards,3,4,3.5,0.060002685,0.939997315,0.923435249,-0.008430859,0.114954406,0.985670334,0.83616127,0.999963957,0.957501758,0.88093685,0.682210996,0.962488021,0.906121996,0.642974019,0.554962129
1215,1215,1275,7.6,You can go backwards in the linked list and access previous data easier without having to keep track of the previous item,4,4,4,0.019422054,0.980577946,0.97521703,0.263554156,0.353661043,0.992471183,0.913919006,0.999986059,0.983561724,0.954946886,0.87974966,0.982338715,0.955800621,0.774239182,0.718585934
1216,1216,1276,7.6,Doubly linked lists allow backward movement through the nodes.,3,4,3.5,0.038564384,0.961435616,0.950790994,0.235794246,0.329297661,0.990497587,0.89135383,0.999950476,0.941605211,0.893216489,0.714986327,0.975626179,0.939001734,0.71989125,0.6508405
1217,1217,1277,7.6,"they have double pointers, so each node can point forwards or backwards. Making it a little easer to get to where you need. ",3,4,3.5,0.030910015,0.969089985,0.960558138,0.118337438,0.22621213,0.990955475,0.896589109,0.999976724,0.972555112,0.948821938,0.863401687,0.976586849,0.94140592,0.749189198,0.687360789
1218,1218,1278,7.6,ability to backtrack through a list.,3,3,3,0.053075433,0.946924567,0.932274575,0.322361499,0.405273089,0.983273815,0.808760579,0.99997218,0.967196466,0.832696099,0.553452599,0.955155464,0.887771436,0.541132689,0.428015531
1219,1219,1279,7.6,You can move forwards and backwards in the double-linked list. Basic only moves forwards.,3,4,3.5,0.033015072,0.966984928,0.957872038,0.189809784,0.288939569,0.992201209,0.910832249,0.999974286,0.969680456,0.909117371,0.757427044,0.974939471,0.937283169,0.649118066,0.562620767
1220,1220,1280,7.6,The advantage is that each node points to bothe its predecessor and its successor. There are no special cases for insertion and deletion.,4,5,4.5,0.02947551,0.97052449,0.962388598,0.309845984,0.394288894,0.992258088,0.911482578,0.999986081,0.983587626,0.966205132,0.909798813,0.984358953,0.960856497,0.796264291,0.74604053
1221,1221,1281,7.6,each node points to both its predecessor and its successor.,4,3,3.5,0.048944771,0.951055229,0.937545391,0.067981049,0.182017033,0.989480295,0.879722592,0.999971814,0.966765926,0.891849168,0.711336839,0.979505672,0.948710607,0.546780169,0.435055192
1222,1222,1282,7.6,a doubly linked list has pointers in both directions. this allows for access from back to front as well as front to back,3,5,4,0.021942437,0.978057563,0.972000966,0.190749928,0.289764683,0.992953172,0.91942985,0.999960035,0.952876918,0.949000333,0.863877838,0.972822816,0.931985998,0.759669006,0.700424011
1223,1223,1283,7.6,"A doubly linked list can be traversed either direction, while a normal linked list can only be traversed from start to finish",3,4,3.5,0.022908032,0.977091968,0.970768845,0.283264846,0.370960057,0.991786924,0.906095507,0.999968518,0.962879508,0.956379582,0.88357364,0.984394023,0.960944263,0.77068013,0.714149526
1224,1224,1284,7.6,"Double Linked list are often easier to manipulate, because they allow sequential access to the list in both direction",4,4,4,0.019457221,0.980542779,0.975172156,0.288958848,0.375957376,0.993337332,0.923822159,0.999990083,0.988306839,0.952478571,0.873161531,0.978207636,0.945462124,0.749737322,0.688044033
1225,1225,1285,7.6,"given a node in the list, one can navigate easily in either direction",4,4,4,0.023102582,0.976897419,0.970520596,0.311737239,0.395948747,0.992909927,0.918935401,0.999964189,0.957775044,0.94737298,0.859534304,0.963387243,0.908372401,0.762034893,0.703373122
1226,1226,1286,7.6,You can traverse the list both forward and backwards.,3,4,3.5,0.027028859,0.972971141,0.965510579,0.234974429,0.328578152,0.989807752,0.883466579,0.999983448,0.980482843,0.891423563,0.710200866,0.965503788,0.913669296,0.635308444,0.545406887
1227,1227,1287,7.6,a doubly linked list allows you to back up from a node rather than having to go through the entire list again,4,4,4,0.021895111,0.978104889,0.972061355,0.247821271,0.339853135,0.991807381,0.906329404,0.999940298,0.929604761,0.931201416,0.816371115,0.973852997,0.934564144,0.77188468,0.715651014
1228,1228,1288,7.6,Gives faster times for some operations such as insertion and deletion,5,5,5,0.029897988,0.970102012,0.961849507,0.362652481,0.440634319,0.990352905,0.889699604,0.999950351,0.941457783,0.892826082,0.7139443,0.979505659,0.948710575,0.802198827,0.75343801
1229,1229,1289,7.6,"The primary disadvantage of doubly linked lists are that (1) each node requires an extra pointer, requiring more space, and (2) the insertion or deletion of a node takes a bit longer (more pointer operations).",0,4,2,0.020539045,0.979460955,0.973791724,0.275911421,0.36450635,0.987951357,0.862241423,0.999981276,0.977922425,0.954003553,0.87723183,0.977392203,0.94342141,0.817811012,0.77289881
1230,1230,1290,7.7,they take up twice as much memory for each node,5,5,5,0.071763277,0.928236723,0.908428473,0.046298984,0.16298785,0.986247466,0.842759922,0.999941074,0.930519134,0.954740313,0.8791983,0.935514665,0.838618097,0.722393036,0.65395901
1231,1231,1291,7.7,"In a doubly linked list, there are more pointers to set and the mechanics of inserting and deleting are more difficult. Also, the special cases at the beginning or end of the list are more complicated.",4,3,3.5,0.039626181,0.960373819,0.949436117,0.233166158,0.32699113,0.976288968,0.728899095,0.999921186,0.907069052,0.963054258,0.90138888,0.943982749,0.859810442,0.79388541,0.743075222
1232,1232,1292,7.7,"There are more pointers to set, the mechanics of inserting into and deleting from a doubly linked list are a bit more involved than for a singly linked list.",4,4,4,0.037394285,0.962605715,0.952284066,0.182646453,0.282652699,0.980940273,0.782079949,0.999929809,0.917236911,0.961179051,0.896383804,0.935887796,0.8395519,0.780010879,0.725780432
1233,1233,1293,7.7,Insertion and deletion with a doubly linked list are more involved than with a singly linked list leaving more room for error and complex algorithms.,3,3,3,0.052668512,0.947331488,0.932793815,0.122299798,0.229689681,0.980721217,0.779575361,0.999888707,0.868773246,0.962300642,0.899377419,0.940826879,0.851912518,0.747224391,0.68491163
1234,1234,1294,7.7,"Need more memory to store ""previous"" pointers.",5,5,5,0.058935821,0.941064179,0.92479659,0.4107638,0.48285904,0.991846234,0.906773636,0.999957825,0.950270587,0.962482215,0.899862052,0.962822593,0.9069593,0.845723152,0.80769167
1235,1235,1295,7.7,a node in a doubly linked list takes up more memory than a node in a singly linked list.,5,5,5,0.062577665,0.937422335,0.920149517,0.088014439,0.199599263,0.983088177,0.806638083,0.999934135,0.922337265,0.953374316,0.875552346,0.93432444,0.835639423,0.632834077,0.542322554
1236,1236,1296,7.7,You have to keep up with where you are and you have to consider the predecessor and successor connections when inserting/deleting.,3,3,3,0.053361535,0.946638465,0.931909502,0.106842861,0.216123957,0.988233458,0.865466834,0.999888214,0.86819188,0.93260846,0.820126627,0.939757571,0.849236453,0.662689865,0.579538198
1237,1237,1297,7.7,"Each node requires an extra node, requires more memory, and is more difficult to insert and remove individual nodes",5,5,5,0.048779488,0.951220512,0.937756296,0.312450945,0.396575129,0.970568662,0.663495775,0.999937629,0.926457225,0.948867391,0.863523005,0.93768963,0.844061195,0.750340402,0.68879578
1238,1238,1298,7.7,"Double-linked lists require more space per node, and their elementary operations are more expensive",5,5,5,0.06848675,0.93151325,0.912609394,0.285022736,0.372502862,0.975391264,0.718635164,0.999945189,0.93537146,0.96021081,0.893799491,0.946377577,0.865803773,0.770226777,0.713584415
1239,1239,1299,7.7,More difficult to delete and create nodes.,3,3,3,0.054553807,0.945446193,0.930388137,0.221235022,0.316519812,0.989684783,0.882060605,0.999929622,0.917016338,0.9518114,0.871380799,0.921206024,0.802809091,0.69077599,0.614547934
1240,1240,1300,7.7,They use more memory and you have to make 2 pointers and update 2 pointers each time you change the list.,5,5,5,0.036891997,0.963108003,0.952924997,0.251377493,0.34297424,0.989257185,0.877171655,0.999921207,0.907094453,0.953554083,0.876032158,0.934522109,0.836134112,0.738962889,0.674613556
1241,1241,1301,7.7,nodes take up more memory,5,5,5,0.114810109,0.885189891,0.853499764,0.100065291,0.210175649,0.98625,0.842788892,0.999912386,0.896692656,0.92763004,0.806838828,0.93551101,0.83860895,0.671672821,0.590735575
1242,1242,1302,7.7,"Each node requires an extra pointer (space requirements increased), Insertion or deletion of a node takes a longer (more pointer operations).",5,5,5,0.050676346,0.949323654,0.935335863,0.445515275,0.513358543,0.973709691,0.699408833,0.99993143,0.91914828,0.892677694,0.713548241,0.952814658,0.881913302,0.832728922,0.791494187
1243,1243,1303,7.7,its a little more confusing. The special cases at the end and beginning become more difficult to do.,3,3,3,0.044493437,0.955506563,0.943225392,0.224198192,0.319120428,0.990093158,0.886729781,0.999917634,0.902881104,0.959617522,0.892215959,0.93888512,0.847053045,0.735670567,0.670509632
1244,1244,1304,7.7,increased actions to add and remove elements to the linked list.,3,3,3,0.03858906,0.96141094,0.950759507,0.192037657,0.290894854,0.989698348,0.882215704,0.999941189,0.930654629,0.950841526,0.868792128,0.928409465,0.820836524,0.676168025,0.596338907
1245,1245,1305,7.7,"Inserting and deleting in a double-linked list is more involved, and has special cases at the beginning and end.",3,3,3,0.058105707,0.941894293,0.925855834,0.16181156,0.264367032,0.974649698,0.710156441,0.999914941,0.899705248,0.961014566,0.89594478,0.940359083,0.850741805,0.724565029,0.656666429
1246,1246,1306,7.7,The main disadvanate is that if hard to remove all items in the list.,1,3,2,0.042023301,0.957976699,0.946377339,0.122347631,0.229731661,0.988207942,0.865175092,0.999951539,0.942859032,0.950198232,0.867075126,0.937856567,0.844478973,0.745161951,0.68234077
1247,1247,1307,7.7,"each node requires an extra pointer, taking up more storage.  insertions and deletions require more pointer operations.",5,5,5,0.039596617,0.960403383,0.949473842,0.54044205,0.596670673,0.977825071,0.74646218,0.999954695,0.946579934,0.960858124,0.895527224,0.947699918,0.869113082,0.813324511,0.767306325
1248,1248,1308,7.7,"in a doubly linked list there are twice as many pointers for each element , therefore more memory is used",5,5,5,0.056131244,0.943868756,0.928375293,0.082912281,0.195121373,0.981054749,0.783388818,0.999932605,0.920533633,0.962503646,0.899919253,0.943540348,0.858703283,0.755190969,0.694842077
1249,1249,1309,7.7,The process of adding and removing Nodes in a Doubly linked list is more complex than in a basic linked list,3,4,3.5,0.062454879,0.937545121,0.920306194,0.09474609,0.205507272,0.983665743,0.8132417,0.999924328,0.910774109,0.954973034,0.879819451,0.936885922,0.842049824,0.715119898,0.644892945
1250,1250,1310,7.7,"Double linked lists require more space per node, and their elementary operation are more expensive",5,5,5,0.05787158,0.94212842,0.926154585,0.273397148,0.362299708,0.976299118,0.729015145,0.999963914,0.95745002,0.958558118,0.889388325,0.947921331,0.869667193,0.795823991,0.74549169
1251,1251,1311,7.7,"1- each node requires an extra pointer, requiring more space 2- the insertion or deletion of a node takes a bit longer, more pointer operations",5,5,5,0.049943864,0.950056136,0.936270526,0.416375101,0.487783777,0.976429792,0.730509203,0.999930073,0.917548282,0.93873563,0.83648053,0.945786577,0.864324728,0.815697372,0.770264129
1252,1252,1312,7.7,It takes up twice the storage needed.,5,5,5,0.05407846,0.94592154,0.930994691,0.322072417,0.405019377,0.989062898,0.874950261,0.999906027,0.889194647,0.945775132,0.85526952,0.90459556,0.761239511,0.754217148,0.693628196
1253,1253,1313,7.7,"using more pointers to enable the backward movement takes up more memory, having more pointers make it slightly more work to add or remove a node from the list",5,5,5,0.040068865,0.959931135,0.948871243,0.260045588,0.350581761,0.979422304,0.764724195,0.999933138,0.921162685,0.954973147,0.879819753,0.943117548,0.857645178,0.778210819,0.723536632
1254,1254,1314,7.7,"increased memory requirements, slightly more complicated when modifying elements in the list",5,5,5,0.066501796,0.933498204,0.915142239,0.175536841,0.276412974,0.978756505,0.757111758,0.999856772,0.831118534,0.919319135,0.784656363,0.934324457,0.835639465,0.694617391,0.619336292
1255,1255,1315,7.7,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
1256,1256,1316,8.1,A data structure for storing items which are to be accessed in last-in first-out order that can be implemented in three ways.,5,5,5,0.015799761,0.984200239,0.979839156,0.510236919,0.570161253,0.995034027,0.943221379,0.999982118,0.978914965,0.974243695,0.931254376,0.988510361,0.971245868,0.882720828,0.853809775
1257,1257,1317,8.1,A stack is an abstract data type that is based on the principle that the last element inserted into the stack will be the first element removed from the stack.,5,5,5,0.011546433,0.988453567,0.985266496,0.480143756,0.5437501,0.992475341,0.913966546,0.999980009,0.976427803,0.972891369,0.927644911,0.988794864,0.97195787,0.910622239,0.888589262
1258,1258,1318,8.1,Stores a set of elements in a particular order.,0,4,2,0.032365143,0.967634857,0.958701362,0.176926225,0.277632362,0.981896631,0.793014501,0.999965541,0.959368332,0.946311445,0.856700982,0.977124716,0.942751994,0.817335784,0.772306432
1259,1259,1319,8.1,"An ADT whose most recently inserted item is the first item removed or retrieved. This property is called last in, first out (LIFO). Items enter and leave a stack at its top.",5,5,5,0.01555866,0.98444134,0.980146806,0.479745001,0.543400134,0.99359732,0.926794733,0.999987742,0.985545917,0.952308543,0.872707713,0.98069246,0.95168068,0.916554332,0.895983695
1260,1260,1320,8.1,A list in which only the top (or last item added) can be modified.,4,5,4.5,0.017986,0.982014,0.977049467,0.575042009,0.6270372,0.989886421,0.884366045,0.999962208,0.955439446,0.974560499,0.932099951,0.983071983,0.957635707,0.877946556,0.847858579
1261,1261,1321,8.1,a stack is a data structure that uses push to insert an item and pop to remove ad item. The stack use a last in first out structure for inserting and removing items.,5,5,5,0.015282214,0.984717786,0.980499558,0.427201867,0.497285848,0.990691311,0.893568776,0.999976496,0.97228655,0.971632457,0.924284775,0.98327582,0.958145833,0.897989988,0.87284299
1262,1262,1322,8.1,A data structure that stores data using LIFO.,5,5,5,0.040452898,0.959547103,0.948381209,0.351642609,0.430971546,0.991104302,0.898290721,0.999974851,0.970346825,0.970089135,0.920165526,0.976705568,0.941703028,0.8448506,0.806604022
1263,1263,1323,8.1,"A stack is similar to an array, but does not allow for random access. Stacks only allow a user to retrieve the last item put into the stack. Last in, fist out.",5,5,5,0.021682024,0.978317976,0.972333258,0.23654221,0.329954109,0.993935434,0.930660569,0.999977938,0.973986899,0.957557454,0.886717474,0.984158297,0.960354332,0.879913867,0.850310859
1264,1264,1324,8.1,Stores a set of elements in a particular order. Stack principle: LAST  IN  FIRST  OUT. It means: the last element inserted is the first one to be removed.,5,5,5,0.017265201,0.982734799,0.977969223,0.317230642,0.400770011,0.991469972,0.902471622,0.99996,0.952835816,0.976027929,0.936016638,0.976869218,0.942112581,0.912591457,0.891043919
1265,1265,1325,8.1,A stack is an ADT that stores a set of elements in a particular order.,1,4,2.5,0.02253288,0.97746712,0.971247547,0.267535389,0.357155157,0.990999914,0.897097198,0.99997331,0.968528909,0.952064585,0.87205657,0.982594586,0.956440967,0.84065032,0.801368316
1266,1266,1326,8.1,"a data type that stores a set of elements in a certain order, last in, first out.",5,5,5,0.018740058,0.981259942,0.976087272,0.380057007,0.455909337,0.991333209,0.900907946,0.999959844,0.9526518,0.972848479,0.927530434,0.965976927,0.914853381,0.892308533,0.865760979
1267,1267,1327,8.1,a data structure that moves elements in last in first out,5,5,5,0.031716347,0.968283653,0.959529241,0.437439382,0.506270765,0.991658957,0.904632393,0.999972868,0.968008073,0.954378438,0.878232427,0.982116135,0.955243589,0.897537649,0.872279142
1268,1268,1328,8.1,Stores a set of elements in a last in first out order.,5,5,5,0.027081907,0.972918093,0.965442889,0.246463805,0.33866176,0.984652218,0.824520601,0.999945009,0.935159581,0.959739824,0.892542392,0.966339096,0.91575975,0.865103066,0.831848996
1269,1269,1329,8.1,A list that can be added to or removed from only from the top.,5,5,5,0.01889205,0.98110795,0.975893327,0.424683124,0.495075283,0.990525491,0.891672867,0.999971421,0.966302602,0.95202238,0.871943921,0.963367334,0.908322577,0.820625842,0.776407533
1270,1270,1330,8.1,"a stack is an Abstract data type which operates on a last in first out basis for storing a list of objects, and does not support ( at least in the pure stack) peeking at a element without removing the rest of the stack first.",5,5,5,0.012910187,0.987089813,0.983526316,0.352137715,0.431406074,0.992777582,0.917422238,0.999974954,0.970468072,0.960057953,0.893391504,0.985751132,0.964340583,0.895586371,0.869846849
1271,1271,1331,8.1,Stores a set of elements in a particular order based on the principle of Last In First Out (LIFO).,5,5,5,0.024297118,0.975702882,0.96899634,0.231470376,0.325502833,0.991019725,0.897323708,0.999967093,0.961199375,0.971620815,0.924253701,0.984956971,0.962353105,0.882939577,0.854082448
1272,1272,1332,8.1,"an object list that stores elements in a particular order, the first object inserted is at the bottom with the last object at the top so the first object in is the last object out.",5,5,5,0.021231771,0.97876823,0.972907792,0.312345892,0.396482929,0.992060135,0.909219273,0.99995804,0.950524791,0.93685938,0.83147267,0.977059198,0.942588027,0.890043437,0.862937507
1273,1273,1333,8.1,An ADT that stores a set of elements in a particular order. The stack principles are LIFO. The last item inserted in the list is the first out.,5,5,5,0.016938806,0.983061194,0.97838571,0.381859481,0.457491272,0.993785699,0.928948571,0.999980036,0.976459647,0.977335562,0.939506815,0.983552038,0.9588371,0.917175055,0.896757435
1274,1274,1334,8.1,An abstract data type that stores a set of elements in a particular order.,1,4,2.5,0.020497561,0.97950244,0.97384466,0.303400129,0.388631713,0.990234541,0.888346286,0.999965518,0.959341911,0.972609984,0.926893872,0.978737813,0.946788953,0.878249049,0.848235642
1275,1275,1335,8.1,a collection of data to be executed in the order of last in first out,5,5,5,0.025980532,0.974019468,0.966848267,0.191036999,0.29001663,0.988531106,0.868869997,0.999969559,0.964106359,0.971339113,0.923501816,0.97768309,0.944149388,0.815395355,0.769887661
1276,1276,1336,8.1,"A stack is a data structure that allows data members to be added or removed one at a time, and in order. They are a ""Last in First Out"" structure.",5,5,5,0.012321651,0.987678349,0.984277301,0.478691965,0.542475942,0.994196552,0.93364607,0.999967628,0.961830259,0.979920561,0.946406382,0.985821751,0.964517315,0.921182394,0.901752638
1277,1277,1337,8.1,Stores a set of element in a particular order,0,4,2,0.037247896,0.962752104,0.952470862,0.102219537,0.212066315,0.980294129,0.774692241,0.999959667,0.952442701,0.961068751,0.896089404,0.977124716,0.942751994,0.822725832,0.7790252
1278,1278,1338,8.1,is a list of element where the first one to be removed is the last one inserted,5,5,5,0.019491315,0.980508685,0.975128652,0.431541503,0.501094513,0.98590717,0.838869143,0.999975709,0.97135799,0.966890749,0.911628779,0.980665375,0.951612896,0.869353354,0.837147037
1279,1279,1339,8.1,A data structure that puts elements in a list and only allows the user  access to the last element.,4,5,4.5,0.017218649,0.982781351,0.978028623,0.452323139,0.519333439,0.993948953,0.930815145,0.999979682,0.976043156,0.97959845,0.945546643,0.986593763,0.966449363,0.898155212,0.873048944
1280,1280,1340,8.1,a finite ordered list with zero or more elements,0,4,2,0.038697958,0.961302042,0.950620551,0.138580442,0.243978327,0.985236507,0.831201086,0.999974501,0.969933931,0.957136194,0.885593097,0.963655524,0.909043805,0.749797583,0.688119148
1281,1281,1341,8.1,"A storage container that holds objects in a certain order, which has a LIFO priority",5,5,5,0.026368558,0.973631442,0.966353137,0.253053069,0.344444803,0.995272295,0.945945625,0.999966448,0.960438697,0.973461763,0.929167338,0.987239931,0.968066472,0.816483021,0.771243451
1282,1282,1342,8.1,"Stacks are a type of container adaptors, specifically designed to operate in a LIFO context (last-in first-out), where elements are inserted and extracted only from the end of the container.",5,5,5,0.015920281,0.984079719,0.979685369,0.366680861,0.444169812,0.987689502,0.859247497,0.999973128,0.968315137,0.941726521,0.844463456,0.98046651,0.951115214,0.832487881,0.791193726
1283,1283,1343,8.2,Push and pop are two main functions defined in a stack,5,5,5,0.055016279,0.944983721,0.929798012,0.403257608,0.476271259,0.987481303,0.856867038,0.999945832,0.936129654,0.999626023,0.999001826,1,1,1,0.999999851
1284,1284,1344,8.2,Push which inserts an element on the top of the stack and pop which removes the last inserted element from the stack.,5,5,5,0.071277797,0.928722203,0.909047956,0.293622971,0.380050826,0.977479537,0.7425115,0.999875632,0.853356228,0.877115377,0.672011181,0.961828403,0.904471226,0.752508104,0.69149785
1285,1285,1345,8.2,Push and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.704518795,0.740672019,0.99207813,0.909425027,0.999929796,0.917221863,0.999626023,0.999001826,1,1,1,0.999999851
1286,1286,1346,8.2,Pop function and Push function,5,5,5,0.077195525,0.922804475,0.901496804,0.37565428,0.4520453,0.979757326,0.76855468,0.999902369,0.884881695,0.91394522,0.770312957,0.921257056,0.802936805,0.759031355,0.699629171
1287,1287,1347,8.2,push and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.806218505,0.829928391,0.99785766,0.97550548,0.999981123,0.977741284,1,1,1,1,1,0.999999851
1288,1288,1348,8.2,push (insert an item) pop (remove an item),5,5,5,0.098883569,0.901116431,0.873822381,0.344581336,0.424774246,0.976896324,0.735843322,0.999875734,0.853476036,0.844678918,0.585435695,0.952579766,0.881325458,0.754972756,0.694570072
1289,1289,1349,8.2,Adding a new item and removing the item,5,5,5,0.112106502,0.887893498,0.856949627,0.034022931,0.152213817,0.986072164,0.840755607,0.999916921,0.902040768,0.94532567,0.85406987,0.947213987,0.867896984,0.451015234,0.315682903
1290,1290,1350,8.2,Push (insert) and pop (retrieve).,5,5,5,0.084063888,0.915936112,0.892732622,0.388111889,0.462978675,0.966696029,0.619217893,0.999884774,0.864136029,0.95591251,0.882326987,0.961348581,0.903270417,0.867147088,0.834396897
1291,1291,1351,8.2,push and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.806218505,0.829928391,0.99785766,0.97550548,0.999981123,0.977741284,1,1,1,1,1,0.999999851
1292,1292,1352,8.2,Push and Pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.55587095,0.610211791,0.986553114,0.846254563,0.999920271,0.905990728,0.998229208,0.995273615,0.961384429,0.903360131,1,0.999999851
1293,1293,1353,8.2,pop and push,5,5,5,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
1294,1294,1354,8.2,push (add an element) pop (remove an element),5,5,5,0.099684656,0.900315344,0.872800177,0.375348061,0.451776548,0.976896324,0.735843322,0.999874011,0.85144519,0.85093908,0.602144565,0.949897626,0.874613096,0.773777604,0.71801057
1295,1295,1355,8.2,Push and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.704518795,0.740672019,0.99207813,0.909425027,0.999929796,0.917221863,0.999626023,0.999001826,1,1,1,0.999999851
1296,1296,1356,8.2,pop and push,5,5,5,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
1297,1297,1357,8.2,push ( to add to a item the Stack) Pop  ( to pull the last item added from an array. ),5,5,5,0.079353094,0.920646906,0.898743699,0.245146275,0.337505434,0.969452329,0.650732141,0.999814644,0.781444686,0.874330718,0.664578705,0.953022073,0.882432381,0.722547293,0.654151293
1298,1298,1358,8.2,pop and push,5,5,5,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
1299,1299,1359,8.2,"push and pop, push puts an object into the list, and pop takes the last object off.",5,5,5,0.042960525,0.957039475,0.945181422,0.648952663,0.69190461,0.978127155,0.74991607,0.999943744,0.933667685,0.872460559,0.659587102,0.959591264,0.898872531,0.832797229,0.791579332
1300,1300,1360,8.2,Push and Pop are the two main functions of a stack,5,5,5,0.05182153,0.94817847,0.933874583,0.367271483,0.44468817,0.983882928,0.815724899,0.999927292,0.914269192,0.998229208,0.995273615,0.961384429,0.903360131,1,0.999999851
1301,1301,1361,8.2,Push and Pop,5,5,5,0,1,1,0.67974478,0.718929197,0.986679455,0.847699082,0.999918139,0.903476908,0.998229208,0.995273615,0.961384429,0.903360131,1,0.999999851
1302,1302,1362,8.2,"push, which adds an element to the stack... and pop which takes an element off the stack",5,5,5,0.070958376,0.929041624,0.909455545,0.339086115,0.419951386,0.982061564,0.794900268,0.999934541,0.9228168,0.944831133,0.852749912,0.952579766,0.881325458,0.775767505,0.720491009
1303,1303,1363,8.2,"Push and Pop, which add and remove data from the stack, respectively.",5,5,5,0.054058373,0.945941627,0.931020322,0.309940994,0.394372279,0.969210009,0.647961567,0.999931749,0.919523852,0.911754651,0.764466154,0.953111893,0.882657166,0.748837888,0.686922876
1304,1304,1364,8.2,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1305,1305,1365,8.2,pop - to remove item push - to insert an element,5,5,5,0.090485811,0.909514189,0.884538106,0.442895383,0.511059204,0.983920435,0.816153732,0.99991136,0.895483085,0.859906686,0.626079817,0.956330061,0.890710998,0.787867785,0.735574171
1306,1306,1366,8.2,Pop and push,5,5,5,0,1,1,0.852522016,0.870566495,0.988992342,0.874143554,0.999935595,0.924059742,0.998171164,0.995118691,0.950716511,0.87666245,1,0.999999851
1307,1307,1367,8.2,pop and push,5,5,5,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
1308,1308,1368,8.2,push - adds an item to the top of the stack pop - removes the top item from the stack,5,5,5,0.090757012,0.909242988,0.884192047,0.327764839,0.41001531,0.977321778,0.740707755,0.999847353,0.820011674,0.870704367,0.654899686,0.964006874,0.909923098,0.735533118,0.6703383
1309,1309,1369,8.2,push and pop. Push adds a given node to the top of the stack leaving previous nodes below. Pop removes and returns the current top node of the stack,5,5,5,0.060029089,0.939970911,0.923401556,0.386900157,0.461915202,0.975258633,0.717118722,0.999887607,0.867476157,0.755477417,0.347349804,0.960778643,0.901844082,0.763908148,0.705708159
1310,1310,1370,8.3,An array has a fixed size.  You can add and delete elements to the end of the array and you use a pointer to keep track of the last element added.  Each time you add or delete an element you update the pointer and check if it is equal to the max size of the array.,5,5,5,0.011213899,0.988786101,0.985690818,0.58976084,0.639955126,0.989086931,0.875225043,0.999914224,0.898859987,0.936734212,0.831138587,0.978717597,0.94673836,0.896890938,0.871473009
1311,1311,1371,8.3,By implementing an array of a pre-defined size with the bottom stack element stored at element 0 and the last element stored in the array is the top. You increment top when an element is pushed and you decrement it when an item is popped.,5,5,5,0.019326866,0.980673134,0.975338492,0.493814617,0.555748281,0.990281758,0.888886138,0.999979277,0.975565447,0.949176414,0.864347812,0.97941247,0.948477359,0.853217959,0.817034049
1312,1312,1372,8.3,"If you use a dynamically allocated array, you must provide a destructor and copy constructor.",2,4,3,0.044152021,0.955847979,0.943661045,0.226313502,0.320976921,0.987596118,0.858179778,0.99995252,0.944015936,0.96441863,0.905030497,0.981680953,0.954154496,0.65982008,0.575960972
1313,1313,1373,8.3,"Create a int value that stores the ""head"" of the stack. Increment the top when one element is pushed and decrement after it is popped.",5,5,5,0.018179893,0.981820107,0.976802054,0.446188003,0.51394896,0.992503246,0.914285608,0.999961999,0.955192701,0.972191377,0.925776576,0.979120056,0.947745559,0.841907203,0.802935038
1314,1314,1374,8.3,Use a pointer that always points to the end of the array list for push/pop modifications.,5,4,4.5,0.026487291,0.973512709,0.966201632,0.399047554,0.47257632,0.991271801,0.900205838,0.999945178,0.935358484,0.972261568,0.925963922,0.984159346,0.960356957,0.824675202,0.781455116
1315,1315,1375,8.3,if you used an array to implement a stack when you add an element just add it to the end of an array and remove items from end of array also.,5,4,4.5,0.01617378,0.98382622,0.979361899,0.587134838,0.637650426,0.989657772,0.881751775,0.999949882,0.940905112,0.9593433,0.891484038,0.96606407,0.915071466,0.869243205,0.837009734
1316,1316,1376,8.3,You predetermine the size of the stack as you would an array.  This type can not grow.,1,4,2.5,0.019165277,0.980834723,0.975544683,0.419825405,0.490811924,0.990726393,0.893969891,0.999967917,0.962170893,0.943267615,0.848576758,0.976798196,0.94193484,0.726532459,0.659118857
1317,1317,1377,8.3,"Declare a variable that points the last item in the array, which increases (++) when items are pushed onto the stack, and decreases (--) when an item is popped off the top.",5,5,5,0.019080698,0.980919302,0.975652607,0.386816472,0.461841756,0.984978164,0.828247319,0.999976296,0.972049736,0.962527989,0.899984226,0.979483644,0.94865548,0.828572273,0.786312868
1318,1318,1378,8.3,"Allocate an array of some size. The bottom stack element is stored at some element. Last index in the array is the top. Increment top when one element is pushed, decrement after pop. ",5,4,4.5,0.023414195,0.976585805,0.97012297,0.539727211,0.596043298,0.989810841,0.883501897,0.999969206,0.9636908,0.966917898,0.911701242,0.980868797,0.952121983,0.869853199,0.8377701
1319,1319,1379,8.3,"You allocate an pre-defined array, the bottom element is stored at element 0, and the last index is the head.",5,3,4,0.026372492,0.973627508,0.966348117,0.407592744,0.480075974,0.983535767,0.811755613,0.999946015,0.936345719,0.972299587,0.926065397,0.9842379,0.960553548,0.799401104,0.74995061
1320,1320,1380,8.3,"Make an array, make the bottom at spot 0, make the last spot in the array the top, and increment top when you ad",5,4,4.5,0.017950296,0.982049704,0.977095025,0.441497475,0.509832335,0.990507193,0.891463665,0.999935074,0.92344463,0.966088491,0.909487489,0.973636796,0.934023076,0.845486641,0.807396856
1321,1321,1381,8.3,treat the beginning of the array as the beginning of the stack,4,4,4,0.015599906,0.984400094,0.980094175,0.45771867,0.524068807,0.992304793,0.912016584,0.999958967,0.951617911,0.915897642,0.775524126,0.981856347,0.95459344,0.695890307,0.620923
1322,1322,1382,8.3,Use an index value called top to keep track of the last element in the array.,5,4,4.5,0.0181849,0.9818151,0.976795666,0.50842166,0.568568097,0.990860056,0.895498127,0.999916721,0.901804853,0.966600859,0.91085504,0.978885649,0.947158929,0.866804898,0.833970352
1323,1323,1383,8.3,create an array and implement pointers that point to the next list item down and stack them up.,1,3,2,0.03288126,0.96711874,0.958042786,0.401852608,0.475038165,0.988779233,0.871706972,0.999957262,0.949606801,0.966687377,0.911085963,0.969831859,0.924500787,0.753459871,0.69268424
1324,1324,1384,8.3,"for efficiency it is easiest to implement the left to right method, with the right most item being the one that is retrieved when a pop is performed, and a push places an object on the furthest element.",3,4,3.5,0.015956044,0.984043956,0.979639735,0.31608665,0.399765991,0.989092213,0.875285436,0.999966168,0.960108577,0.974617484,0.932252049,0.984491185,0.961187422,0.881884098,0.852766779
1325,1325,1385,8.3,"Create an array based on a pre-defined size N There can't be more elements than N.  Bottom stack element stored at element 0 last index in the array is the top  Increment top when one element is pushed, decrement after pop",5,4,4.5,0.028182089,0.971817911,0.964039031,0.420554221,0.491451566,0.985315437,0.832103536,0.999963372,0.956811092,0.960487967,0.894539246,0.945189501,0.862830477,0.854101777,0.81813574
1326,1326,1386,8.3,"with the element added to the array, so that the last element added is at the end, and when the element is popped it takes the last element off the array",4,4,4,0.01512748,0.98487252,0.980697001,0.548030794,0.603330907,0.994757279,0.940057162,0.999900443,0.88261062,0.958283944,0.888656533,0.970396775,0.925914554,0.770470083,0.7138877
1327,1327,1387,8.3,Allocate an array of some pre-defined size. Bottom stack element stored at element 0. The last index in the array is the top. Increment top when one element is pushed.,5,4,4.5,0.025283515,0.974716485,0.967737676,0.508785427,0.568887356,0.98750599,0.857149303,0.999962336,0.955589645,0.962450333,0.899776956,0.980360556,0.950850052,0.840710819,0.801443729
1328,1328,1388,8.3,"Create an array, size N.  N++ when one element is pushed.  N-- when one element is popped.",4,4,4,0.043734431,0.956265569,0.944193899,0.318823814,0.402168253,0.985020384,0.828730044,0.999955087,0.947043052,0.939361846,0.838151951,0.976962615,0.942346317,0.753721893,0.693010854
1329,1329,1389,8.3,define an array and keep track of a pointer to the last element as items are added,5,3,4,0.021925449,0.978074551,0.972022642,0.448838711,0.516275344,0.98883452,0.87233909,0.999881066,0.859762861,0.96424318,0.904562207,0.977739325,0.944290123,0.851259947,0.81459336
1330,1330,1390,8.3,"By allocating an array of predetermined size, and an integer to track the top element of the stack. The bottom member of the stack will go in element 0 of the array, and for each element pushed the ""top"" tracking integer is incremented.",5,4,4.5,0.015461087,0.984538913,0.980271311,0.588828981,0.639137284,0.988418798,0.867585919,0.999907151,0.89052043,0.943417015,0.848975519,0.984597238,0.961452832,0.876604855,0.846186131
1331,1331,1391,8.3,"Allocate an array of some size, bottom stack element stored at element 0",4,4,4,0.049405158,0.950594842,0.936957927,0.39025563,0.464860121,0.987834374,0.860903894,0.999916732,0.901818038,0.961314803,0.896746136,0.979833629,0.949531357,0.776731372,0.721692482
1332,1332,1392,8.3,you store the stack in the array but you have to keep in mind the first element,3,3,3,0.023337722,0.976662278,0.970220551,0.414536715,0.486170324,0.990625567,0.892817094,0.999934418,0.922671671,0.954611972,0.878855748,0.978723567,0.946753301,0.859026134,0.824274018
1333,1333,1393,8.3,You keep track of the last item entered into the array and do not  allow the user access to the other parts of the array.,5,3,4,0.010208666,0.989791334,0.986973516,0.514868677,0.574226298,0.992110601,0.909796285,0.999967956,0.96221701,0.963273835,0.901974948,0.974373147,0.935865878,0.844823599,0.806570365
1334,1334,1394,8.3,"using arrays, you are pushing one int at a time into the stack until you get to the end of your array",4,4,4,0.014773786,0.985226214,0.981148323,0.400517196,0.473866145,0.986879935,0.849991277,0.999967899,0.96214917,0.955075282,0.880092359,0.974889264,0.93715752,0.84198904,0.80303705
1335,1335,1395,8.3,"by having a max number of elements, allocating an array with that number of elements, storing the elements starting at 0, and keeping track of how many elements are currently in the list",5,3,4,0.015470386,0.984529614,0.980259446,0.433275819,0.502616629,0.983116225,0.806958773,0.999962061,0.955265471,0.958988953,0.890538258,0.969933043,0.924754012,0.799204588,0.74970565
1336,1336,1396,8.3,"Stack usually holds a bunch of items with the same type, therefore u can use an array, to hold the content of the stack and an integer top that holds the index of the element at the top of the stack. u Choose an array size. Then the sequence of operations used. u have to decide what data types are needed for this stack data structure. ",2,4,3,0.010955989,0.989044011,0.986019916,0.534288228,0.591269794,0.989387179,0.878657945,0.999969991,0.964615539,0.924256137,0.797833613,0.931092641,0.827551477,0.872390032,0.840932297
1337,1337,1397,8.4,You can add an element to the end of the linked list and update a pointer called top each time you modify the list.,2,4,3,0.012823224,0.987176776,0.983637283,0.574019611,0.626139895,0.992027486,0.908845988,0.999960362,0.953262555,0.976512466,0.937309906,0.972681813,0.931633122,0.881327391,0.852072836
1338,1338,1398,8.4,You implement a list in which the head pointer points to the element most recently pushed onto the list and the pop function changes the head pointer to point to the next to last element in the list and removes the element head pointer previously pointed to.,5,5,5,0.013771892,0.986228108,0.982426762,0.594988167,0.644542871,0.99309876,0.92109443,0.999962642,0.955950731,0.935370893,0.82749978,0.973614203,0.933966535,0.894913971,0.869008693
1339,1339,1399,8.4,This is the implementation of the stack using single linked list.   The operations performed on a stack are    1)push(): This is the function which is for insertion(pushing)of an element into stack                      It is similar to the insertion of an element at the end of a single linked list                   see  the function insert_end() in the program for operations of single linked list    2)pop(): This is the function which is for deletion(popping up) of an element from the stack             It is similar to the deletion of an element at the end of a single linked list       see  the function delete_end() in the program for operations of single linked list    3)stack_display():This is the function which is for displaying the elements of a stack,3,5,4,0.018136084,0.981863916,0.976857956,0.500707388,0.561797695,0.972937789,0.690583264,0.999878149,0.856324042,0.899518714,0.731807467,0.975402412,0.938441731,0.830330372,0.788504361
1340,1340,1400,8.4,Using nodes to keep track of the head of the stack. Then using Push( ) and Pop ( ) to create the stack as needed.,4,4,4,0.014955342,0.985044658,0.980916654,0.510932565,0.570771784,0.993679423,0.927733464,0.999938662,0.927675446,0.970716891,0.921841056,0.972707758,0.931698053,0.862875462,0.829072257
1341,1341,1401,8.4,"Use the head as the top of the stack, only modify the head when you push/pop... push would add a new item to the head, pop would remove the item from the head.",5,4,4.5,0.008774817,0.991225183,0.98880314,0.548906446,0.604099419,0.997574506,0.972268027,0.999977044,0.972931962,0.945630864,0.854884458,0.969877682,0.924615465,0.929120958,0.911648165
1342,1342,1402,8.4,you implement a stack with a list by changing the pointer to the first element of the list to the new item and move the pointer from the top of the stack to the next item when removing an item.,5,4,4.5,0.009286523,0.990713477,0.988150192,0.556976259,0.611181861,0.994067765,0.932173581,0.999879622,0.8580608,0.926535978,0.80391869,0.977271718,0.943119883,0.866340578,0.833391571
1343,1343,1403,8.4,You dynamicly create space as the stack grows.  The stack can be as long as you need.,1,4,2.5,0.029888451,0.970111549,0.961861676,0.261612773,0.351957196,0.986827279,0.849389239,0.999975398,0.970991202,0.973502987,0.929277368,0.980433749,0.951033226,0.764567018,0.706529449
1344,1344,1404,8.4,"Declare a pointer that points to the head of the linked list, only add and remove nodes from the beginning of the list.",5,5,5,0.009185016,0.990814984,0.988279716,0.701550901,0.738067258,0.995564763,0.949289558,0.999983125,0.980102672,0.982646139,0.953681167,0.983233893,0.958040906,0.884845078,0.856457681
1345,1345,1405,8.4,Creating a linked list. Add an element to the top of the stack when pushing and deleting an element when popping.,4,4,4,0.013810337,0.986189663,0.982377705,0.622506321,0.668694076,0.99111453,0.89840767,0.999940162,0.929444015,0.972566406,0.926777559,0.983511915,0.958736687,0.905467212,0.882163451
1346,1346,1406,8.4,"A singly-linked list is already a lot like a stack, it just depends on the way you address moving the head.",4,3,3.5,0.017483354,0.982516646,0.977690855,0.338913769,0.419800127,0.989815165,0.883551338,0.999974583,0.970030466,0.97238192,0.926285151,0.973053525,0.932563374,0.773520112,0.717689603
1347,1347,1407,8.4,"make a list, make the bottom the head, add on the end and make the end top",3,4,3.5,0.01967591,0.98032409,0.974893104,0.49660635,0.558198435,0.985680642,0.836279126,0.999894215,0.875267663,0.944221189,0.851121923,0.94228639,0.855565111,0.858716905,0.82388856
1348,1348,1408,8.4,use the add function with a list as the beginning of the stack and remove for pop,5,4,4.5,0.013121843,0.986878157,0.983256238,0.628275156,0.673757073,0.992768083,0.917313623,0.999960196,0.953066227,0.965383898,0.907606874,0.981440899,0.953553734,0.85774529,0.822677428
1349,1349,1409,8.4,Use head as the top and push and pop nodes from the head.,5,4,4.5,0.014627516,0.985372484,0.981334966,0.513547838,0.573067068,0.988316117,0.86641192,0.999978774,0.974972092,0.982301902,0.952762371,0.974125953,0.935247247,0.906163871,0.883031846
1350,1350,1410,8.4,create a node based list that points to the next list item down.,0,3,1.5,0.036920547,0.963079453,0.952888566,0.453662276,0.520508728,0.988854318,0.872565457,0.999897346,0.878959863,0.959166806,0.891012962,0.958924344,0.897203488,0.785390019,0.732485603
1351,1351,1411,8.4,"have the head of the list be the last item added, and a push just adds a new head.",5,4,4.5,0.010518968,0.989481032,0.986577564,0.556923688,0.611135722,0.996500683,0.959990441,0.999966022,0.959935701,0.969354331,0.918204275,0.979052975,0.947577682,0.858184278,0.823224633
1352,1352,1412,8.4,"Create a new list.  Pop elements in the stack as needed.  Push the stack to remove items, unless the stack is empty.  The top item is at the head of the list. The last item is at the end.",5,4,4.5,0.010707736,0.989292264,0.986336692,0.605684221,0.653930222,0.98879076,0.871838766,0.999906432,0.889672737,0.944194831,0.851051571,0.982643828,0.956564201,0.902763963,0.878793814
1353,1353,1413,8.4,adding the element to the end of the list so that it links to the element before it. when popping the element it takes the last element in the list and sets the previous one as the end of the list.,3,4,3.5,0.010425985,0.989574015,0.986696213,0.627450407,0.673033234,0.994140565,0.933005949,0.999925187,0.911786651,0.930517341,0.814545264,0.975867296,0.939605157,0.828006923,0.785608151
1354,1354,1414,8.4,"You can implement a stack using arrays or and linked list. By the use of pointers, that point element(node) to the next element in the stack. By the use of pointers, the stack becomes a linked list.",1,4,2.5,0.018214643,0.981785357,0.976757713,0.561923623,0.615523897,0.986636494,0.847207885,0.999917312,0.902501212,0.943674461,0.849662663,0.970518476,0.926219125,0.827471316,0.784940509
1355,1355,1415,8.4,Elements are only inserted and removed from the head of the list.  There is no header node or current pointer.,5,4,4.5,0.017949045,0.982050955,0.977096622,0.476775229,0.540793725,0.991868878,0.907032538,0.999961731,0.954876658,0.976560383,0.9374378,0.978238572,0.945539545,0.857521296,0.822398216
1356,1356,1416,8.4,use a linked list and keep track of a pointer that points to the first item,4,4,4,0.022544861,0.977455139,0.97123226,0.495037615,0.556821641,0.99117481,0.899096888,0.99991875,0.904196989,0.975908895,0.935698927,0.976649781,0.941563415,0.875558138,0.844881384
1357,1357,1417,8.4,"A singly linked list can already be easily used for LIFO data storage. Members of a stack can simply be pushed and popped from a list, the first item in will be the last out.",5,4,4.5,0.015316546,0.984683454,0.980455749,0.396971464,0.470754248,0.985144436,0.830148391,0.999973212,0.968413603,0.972774266,0.927332353,0.982506428,0.956220341,0.829024851,0.786877012
1358,1358,1418,8.4,using pointer,0,3,1.5,0.16731292,0.83268708,0.786505018,0.141201019,0.246278268,0.974546778,0.708979698,0.999613997,0.544859081,0.914996158,0.773117994,0.923020914,0.80735106,0.683220088,0.6051294
1359,1359,1419,8.4,the top is the first pointer.,3,3,3,0.036581576,0.963418424,0.953321101,0.398708344,0.472278613,0.984362482,0.821207891,0.999932484,0.920390453,0.946857403,0.858158188,0.902381418,0.755698368,0.756539702,0.696523292
1360,1360,1420,8.4,"Keep a pointer pointing to the last element entered at the front of  the array and move the pointer ""back"" when you delete an element.",2,3,2.5,0.01550132,0.98449868,0.980219973,0.440282732,0.508766221,0.989419372,0.879026024,0.999970078,0.964718193,0.924177361,0.797623354,0.982465352,0.956117544,0.90359515,0.879829899
1361,1361,1421,8.4,"using linked list, you are pushing the node that contains each int to the stack until you get to the end of your linked list",1,4,2.5,0.013769984,0.986230016,0.982429196,0.505703449,0.56618247,0.988848376,0.872497516,0.999971226,0.966071735,0.970329733,0.920807701,0.974251945,0.935562557,0.830457568,0.788662913
1362,1362,1422,8.4,"have a linked list, and for each push, add an item onto beginning of the list, and for each pop remove the first element in the list.",5,5,5,0.012075484,0.987924516,0.984591416,0.658435524,0.700227207,0.97822386,0.751021745,0.999907208,0.890587909,0.968358029,0.915545066,0.981133257,0.952783824,0.933647692,0.917290801
1363,1363,1423,8.4,"Using a linked list is one way to implement a stack so that it can handle essentially any number of elements. It is usually convenient to put a data structure in its own module, thus, you'll want to create files stack.h and a stack.c",0,4,2,0.020207047,0.979792953,0.974215361,0.375220209,0.45166434,0.991579102,0.903719364,0.999961453,0.954548375,0.963581264,0.902795501,0.980756668,0.951841368,0.822750688,0.779056182
1364,1364,1451,8.6,They are converted to post fix expressions.  It still follow the order of precedence for the operators.,5,5,5,0.02233839,0.97766161,0.97149572,0.548555136,0.603791093,0.984979866,0.828266778,0.999982219,0.979034184,0.970252188,0.920600727,0.972482646,0.931134684,0.742885768,0.679503478
1365,1365,1452,8.6,They are first converted to postfix expressions and then evaluated.,5,5,5,0.024349749,0.975650251,0.968929182,0.721693277,0.75574514,0.987179357,0.853414733,0.999977104,0.97300314,0.960139782,0.893609912,0.97180861,0.929447832,0.803000271,0.754437021
1366,1366,1453,8.6,"Computers cannot evaulate infix expressions, it must first convert infix to postfix expression then it can evaluate.",5,5,5,0.030078948,0.969921053,0.961618598,0.512072265,0.571772038,0.994091292,0.93244258,0.999960531,0.953462139,0.978123055,0.941608696,0.980064699,0.950109636,0.828954756,0.786789638
1367,1367,1454,8.6,By using parentheses to have order in the expression.,2,3,2.5,0.032438993,0.967561007,0.958607128,0.400465101,0.473820425,0.989625309,0.88138061,0.999975665,0.97130623,0.961314945,0.896746515,0.955297441,0.888126749,0.72920078,0.662444955
1368,1368,1455,8.6,In postfix notation.,3,5,4,0.098652661,0.901347339,0.874117025,0.519611538,0.578388852,0.98583879,0.838087311,0.999681746,0.624742672,0.962762828,0.90061103,0.964654207,0.911543123,0.747902513,0.685756918
1369,1369,1456,8.6,computers usually convert infix expressions to post fix expression and evaluate them using a stack.,5,5,5,0.032073438,0.967926562,0.959073584,0.460345089,0.526373874,0.989045714,0.874753788,0.999968263,0.962577993,0.954096072,0.87747877,0.959926285,0.899710959,0.762926519,0.704484545
1370,1370,1457,8.6,they are converted to postfix,5,5,5,0.039699912,0.960300088,0.949342035,0.586008787,0.636662151,0.982872281,0.804169627,0.99994717,0.93770748,0.933908745,0.823597191,0.972780438,0.931879943,0.761184812,0.702313484
1371,1371,1458,8.6,Infix expressions are interpreted as postfix expressions by implementing stacks.,5,5,5,0.03386271,0.96613729,0.956790434,0.570033312,0.622641335,0.99088237,0.895753256,0.999790236,0.752664836,0.956960701,0.885124692,0.972780441,0.93187995,0.793159068,0.742169827
1372,1372,1459,8.6,They are first converted into an equivalent postfix expression so it can be read by the computer.,5,5,5,0.015637159,0.984362841,0.980046639,0.616636038,0.663542044,0.989660768,0.881786027,0.999967997,0.962264258,0.974710322,0.932499841,0.978734207,0.946779928,0.828223646,0.785878299
1373,1373,1460,8.6,"The computer translates the infix expression to a postfix expression, then solves.",5,5,5,0.025480509,0.974519491,0.967486308,0.539713979,0.596031685,0.991189098,0.899260249,0.999961357,0.954435881,0.980556016,0.948102462,0.979740995,0.94929953,0.746147215,0.683568916
1374,1374,1461,8.6,in postfix format,3,5,4,0.217113018,0.782886982,0.722958992,0.399881661,0.473308371,0.982530523,0.800262127,0.99991846,0.90385513,0.936950076,0.831714745,0.972780438,0.931879943,0.687630892,0.610627526
1375,1375,1462,8.6,they use parenthisis and a stack to determine which evaluations need to be made first,3,3,3,0.034636974,0.965363026,0.955802456,0.173115253,0.274287677,0.983122121,0.807026181,0.999971135,0.965964891,0.970091144,0.920170888,0.977107627,0.942709226,0.700299263,0.626418822
1376,1376,1463,8.6,By throwing variables into a postfix expression and operands onto a parentheses regulated stack until end parentheses and enough variables to operate on are encountered.,4,5,4.5,0.031071961,0.968928039,0.960351491,0.400189161,0.473578248,0.98796122,0.862354187,0.999962119,0.955334036,0.97659239,0.93752323,0.979201296,0.947948872,0.793321788,0.74237266
1377,1377,1464,8.6,by being passed to the function by a leading term,0,3,1.5,0.033195138,0.966804862,0.957642271,0.149209514,0.253306893,0.987629425,0.858560603,0.999971806,0.966756299,0.956560735,0.884057151,0.904135989,0.760089382,0.656325459,0.571604881
1378,1378,1465,8.6,"i have an hard time explaining this so i'll show how infix is evaluated instead. Start with an infix expression, like,  (((5+2)*5)+(400/(2+3))), and  push items until you get a "")"" and once that happens, perform the operations until you reach an ""(""... with that complete, you will now have  ((7*5)+(400/(2+3))) as now the expression that will be evaluated... perform last step again... (35+(400/(2+3))) is now the stack.... repeat agian... (35+(400/5)) is now the stack after that.... repeat... (35+80) is now the stack, repeat again... 115 is now the stack, and is returned.",1,4,2.5,0.042042196,0.957957804,0.946353229,0.266803145,0.356512507,0.972802813,0.689040014,0.999967478,0.96165319,0.85818061,0.621472784,0.982634157,0.956539998,0.734084606,0.66853271
1379,1379,1466,8.6,The infix expression is converted to postfix form,5,5,5,0.038225591,0.961774409,0.951223301,0.655192018,0.697380556,0.988043856,0.863299011,0.999966458,0.960449935,0.9800106,0.946646704,0.964950395,0.912284367,0.896134853,0.870530539
1380,1380,1467,8.6,by converting them to postfix expressions and putting the operations in a stack,5,5,5,0.024818897,0.975181103,0.968330539,0.490546852,0.552880339,0.987882083,0.861449376,0.999960224,0.953100019,0.973141086,0.928311425,0.972780441,0.93187995,0.75107187,0.689707565
1381,1381,1468,8.6,The computer converts the infix expression to postfix form. Then evaluates the postfix expression.,5,5,5,0.026608229,0.973391771,0.966047312,0.699608445,0.736362469,0.987168027,0.853285189,0.999938397,0.927362842,0.974250339,0.93127211,0.981322335,0.953257014,0.883972645,0.855370181
1382,1382,1469,8.6,infix expressions are converted to postfix expressions before they can be evaluated by a computer.  Operands stay in the same order.  Operators always follow the operands.,5,5,5,0.014957309,0.985042691,0.980914144,0.621697485,0.667984205,0.990423173,0.890503013,0.999941288,0.930771928,0.960283199,0.893992703,0.979684606,0.94915841,0.772313178,0.716185143
1383,1383,1470,8.6,infix expressions are pointers evaluated by reference to the memory location,0,3,1.5,0.055578172,0.944421828,0.929081024,0.356609762,0.43533095,0.991357636,0.901187226,0.999966687,0.960719932,0.956274337,0.883292732,0.916447329,0.790899914,0.505383313,0.38345345
1384,1384,1471,8.6,computers convert infix expressions to postfix form before evaluation,5,5,5,0.067583144,0.932416856,0.913762416,0.618083894,0.66481275,0.989236383,0.876933814,0.999809402,0.775263095,0.977803299,0.940755242,0.968086804,0.920133588,0.888438165,0.860936513
1385,1385,1472,8.6,convert infix expressions to postfix expression and evaluate the postfix expression,5,5,5,0.057066441,0.942933559,0.927181961,0.611030877,0.658622695,0.988487655,0.868373207,0.999933435,0.921511923,0.981671286,0.951079207,0.982332296,0.955784556,0.842031777,0.803090321
1386,1386,1473,8.6,"When an operand is entered, the computer Pushes it onto a stack When an operator is entered, the computer Applies it to the top two operands of the stack Pops the operands from the stack Pushes the result of the operation onto the stack",4,4,4,0.032528698,0.967471302,0.958492662,0.121129751,0.228662794,0.993052961,0.920570792,0.999956545,0.948761648,0.862712638,0.633569126,0.978528843,0.946265982,0.728439212,0.66149565
1387,1387,1474,8.6,Computers convert an infix expression into a postfix expression. They then push the numbers onto a stack and pop them out as they are needed.,5,5,5,0.019208491,0.980791509,0.975489541,0.577581167,0.629265682,0.989212317,0.876658647,0.999962294,0.955540864,0.969622292,0.918919484,0.976021579,0.939991267,0.806744993,0.759104867
1388,1388,1475,8.6,"infix expressions are converted to postfix, (i.e. 3+2 is changed to 32+)",5,5,5,0.043963432,0.956036568,0.943901689,0.549851418,0.60492877,0.994434083,0.936361897,0.999959998,0.952832642,0.955619941,0.881546097,0.949728673,0.874190272,0.67576921,0.595841779
1389,1389,1476,8.6,"they are transformed into post-fix expressions, then evaluated with a stack.",5,5,5,0.019700944,0.980299056,0.97486116,0.582361877,0.633461454,0.993395184,0.924483611,0.999986838,0.984481005,0.959048849,0.890698125,0.972780438,0.931879943,0.749998093,0.688369087
1390,1390,1477,8.6,"Writing arithmetic expressions is called infix notation.  This is because a binary operator (like '+') is written in between its two operands (as in ""a + b"").  There are two alternative forms of notation used in certain situations.  One is prefix notation, in which an operator is written before its operands.  In prefix notation, the sum of a and b is written ""+ a b"".  This is the notation used to write function calls in mathematics and computer science.  It is also used in the Lisp and Scheme programming languages.  In postfix notation, an operator is written after its operands.  The sum of a and b is written ""a b +"".  (You may have seen this as ""reverse Polish notation"".)  Postfix notation forms the conceptual basis for the way that arithmetic expressions are evaluated by a computer.  One important characteristic of both postfix and prefix notations is that they are unambiguous; no parentheses are needed to indicate the order of operations. ",5,5,5,0.018726408,0.981273592,0.976104689,0.42643249,0.496610608,0.982421984,0.799021148,0.999960242,0.953120624,0.814475993,0.504821689,0.976783658,0.941898457,0.782193124,0.72850063
1391,1391,1478,8.7,isEmptry()//determines if the stack is full or not pop()//to remove the top element if it is not the on you are looking for search()//you compare each element of the stack to the data you are looking for.,2,4,3,0.021970153,0.978029847,0.9719656,0.42827487,0.498227565,0.986344436,0.843868629,0.999942245,0.931900189,0.958179239,0.888377067,0.977511082,0.943718919,0.776120305,0.720930779
1392,1392,1479,8.7,You would have to keep using peek or getTop to see what the top element is then popping the top element until peek or getTop provides the element you are looking for.,2,4,3,0.020250559,0.979749441,0.974159839,0.430392861,0.500086413,0.992903437,0.918861203,0.999979366,0.975670178,0.958499802,0.889232675,0.972056494,0.93006819,0.773590147,0.717776903
1393,1393,1480,8.7,Push adds a given node to the top of the stack leaving previous nodes below. Pop removes and returns the current top node of the stack.,2,4,3,0.020852625,0.979147375,0.973391589,0.362207592,0.440243864,0.991873623,0.907086782,0.999958306,0.950837704,0.926432575,0.803642699,0.968821441,0.921972101,0.791593015,0.740217721
1394,1394,1481,8.7,"Using linked lists and stacks, you would need a temp stack to retain the values. Then you would use the Pop( ) function to pop off each element and then compare it. If its not the element your looking for, Push ( ) it to the temp stack. Repeat until the element is found. When you find it,  Pop ( ) off the temp stack back onto the regular stack to have a complete stack again.",5,5,5,0.010518372,0.989481628,0.986578325,0.584810197,0.635610213,0.988284015,0.866044876,0.999932873,0.920849935,0.917992407,0.78111522,0.976306706,0.94070483,0.866266489,0.833299218
1395,1395,1482,8.7,"Pop each item off the top until you find what you are looking for. If the stack ends up empty and you never found the item, then it does not exist in the stack. It may also be necessary to save the popped values in case you want to recreate the stack.",5,5,5,0.015148103,0.984851897,0.980670686,0.448420614,0.515908403,0.993316791,0.9235873,0.99995279,0.944334242,0.939051885,0.83732464,0.978889713,0.9471691,0.853647053,0.81756892
1396,1396,1483,8.7,"if the stack is implemented using an array you could simply search the array for the item. If the stack is implemented using a linked list you would have to pop the values off of the stack until either the value is found or the stack is empty, you would then have to have the items put back into the list.",4,5,4.5,0.012938738,0.987061262,0.983489885,0.449356288,0.516729593,0.994973485,0.942529166,0.999948179,0.938897548,0.9213189,0.789993895,0.943265184,0.858014654,0.837904274,0.797945333
1397,1397,1484,8.7,"You need to pop each item on the stack and compare the item.  Once the item is found, no more items need to be removed.",3,4,3.5,0.016447783,0.983552218,0.979012266,0.357960045,0.436516021,0.995076972,0.943712392,0.999948901,0.939748524,0.940018062,0.839903443,0.98631871,0.965761012,0.830649853,0.788902599
1398,1398,1485,8.7,"Pop an element from one stack, check to see if it is the desired element, if not push it onto another stack. When finished, pop the items from the second stack and push them back onto the first stack (this will ensure the order of the elements is maintained).",5,5,5,0.007637024,0.992362976,0.990254989,0.698747635,0.735606982,0.989241398,0.876991149,0.999953145,0.9447521,0.953282665,0.875307722,0.982624445,0.956515692,0.906764209,0.883780175
1399,1399,1486,8.7,Basically pop the stack until you find the given element.,3,4,3.5,0.015469611,0.984530389,0.980260435,0.606182516,0.654367549,0.989062681,0.874947784,0.999975662,0.971302745,0.912229827,0.765734437,0.879673937,0.698870308,0.549102664,0.437950213
1400,1400,1487,8.7,"Iterate through the stack, checking the number against the current element.",0,3,1.5,0.022233725,0.977766275,0.971629276,0.522463501,0.580891867,0.992596668,0.915353741,0.99990529,0.8883264,0.962272392,0.899302018,0.9367865,0.841801009,0.560883343,0.45263499
1401,1401,1488,8.7,pop and push,2,4,3,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
1402,1402,1489,8.7,pop all elements off stack until you find that element and then push the popped elements back on the stack,5,5,5,0.008778512,0.991221488,0.988798424,0.823363781,0.844975879,0.993165253,0.921854686,0.999986962,0.984627096,0.962352457,0.899515717,0.974105161,0.935195213,0.913695633,0.892420289
1403,1403,1490,8.7,"Keep popping nodes and storing them in an alternate stack until the given element is found, then pop the given element and push the previously popped nodes back onto the stack.",5,5,5,0.007878304,0.992121697,0.989947111,0.623413742,0.66949047,0.993389854,0.924422662,0.999973433,0.96867468,0.978870309,0.943603176,0.974114385,0.935218297,0.843490541,0.80490869
1404,1404,1491,8.7,either traverse the entire list and pop the given part or create a pointer system that automatically points to it.,2,4,3,0.027641237,0.972358763,0.964729171,0.297350615,0.38332238,0.994033439,0.931781113,0.999983342,0.980358832,0.967714225,0.913826702,0.955679657,0.889083288,0.828413606,0.786115086
1405,1405,1492,8.7,"Depends on the type of stack, on a true stack you will haft to pop all of the elements of the stack until you find the element you want, and then after that you will need to push all the elements that where removed back in to the stack in the order that they where removed.  With a Java style stack, where there is a peek function, it will return the element you wanted instead of requiring you to perform all the excessive actions that are required from a true stack.",5,5,5,0.009871542,0.990128458,0.987403694,0.587703288,0.638149323,0.993041709,0.920442138,0.999983346,0.980363573,0.944060224,0.850692295,0.972379817,0.930877343,0.86673367,0.833881566
1406,1406,1493,8.7,if top item != given element pop the stack. Repeat until item is found or stack is empty,3,4,3.5,0.02522099,0.97477901,0.967817459,0.514901519,0.574255122,0.989084791,0.875200581,0.999873157,0.850438265,0.956777125,0.884634713,0.969732994,0.924253367,0.862601101,0.828730263
1407,1407,1494,8.7,could traverse through the list/array to find the element.,1,3,2,0.034577489,0.965422511,0.95587836,0.405180126,0.47795855,0.987804608,0.860563559,0.999969823,0.964417376,0.921618506,0.790793567,0.954807061,0.886899517,0.571846485,0.466300695
1408,1408,1495,8.7,you need the pop opertation to go throught the stack and find the element.,3,4,3.5,0.017336369,0.982663631,0.977878411,0.51285547,0.572459415,0.988859875,0.872628997,0.999978159,0.97424683,0.938217418,0.835097381,0.951356667,0.878264513,0.740077138,0.676002482
1409,1409,1496,8.7,"createStack, push, isEmpty, pop, and a boolean return value.",2,4,3,0.046622753,0.953377247,0.940508337,0.137007445,0.242597793,0.97804242,0.748947248,0.999916213,0.901205425,0.96022857,0.893846894,0.966941948,0.917268456,0.792904615,0.741852649
1410,1410,1497,8.7,you would have to traverse the stack popping each element to search it,3,4,3.5,0.022231877,0.977768123,0.971631634,0.370738238,0.447730754,0.98930431,0.877710459,0.999978093,0.974169382,0.937245725,0.832503856,0.96583552,0.914499493,0.643718004,0.555889517
1411,1411,1498,8.7,Pop each element off the stack (and into another stack for storage) until the desired element is found.,4,4,4,0.012378573,0.987621427,0.984204667,0.692629337,0.730237281,0.988180397,0.864860152,0.999928402,0.915577886,0.963927762,0.903720332,0.970917331,0.927217305,0.833918393,0.792976878
1412,1412,1499,8.7,pop operation,1,4,2.5,0.105251014,0.894748986,0.865697381,0.055888303,0.171403879,0.966026175,0.611559089,0.999729836,0.681446432,0.90244688,0.739622974,0.895305105,0.737989088,0.620696962,0.527193476
1413,1413,1500,8.7,to pop elements then push them back,4,5,4.5,0.029769242,0.970230758,0.96201379,0.560602188,0.614364144,0.985327158,0.832237554,0.999975899,0.971582138,0.961816998,0.898086535,0.951068766,0.877544008,0.916312099,0.895681748
1414,1414,1501,8.7,A function to keep track of the elements popped and a function to put  the popped elements backinto the function.,4,5,4.5,0.023416519,0.976583481,0.970120004,0.374157816,0.450731934,0.993372823,0.924227942,0.999939416,0.928564464,0.946665655,0.857646397,0.966349215,0.915785074,0.852244496,0.815820614
1415,1415,1502,8.7,you would pop each element and compare it to what you are looking for and then push it back on the stack so that it is not lost,4,5,4.5,0.019244611,0.980755389,0.975443451,0.404589981,0.47744061,0.993080419,0.920884727,0.999977273,0.97320277,0.983222858,0.955220475,0.974356451,0.935824095,0.857545555,0.822428455
1416,1416,1503,8.7,you would need to perform a search through the list of elements (i dont really understand what this question is asking....its not very clear?),0,3,1.5,0.025341928,0.974658072,0.96766314,0.29069075,0.377477374,0.990744834,0.894180734,0.999975033,0.970561,0.966817228,0.911432546,0.967991254,0.919894464,0.805812418,0.7579424
1417,1417,1504,8.7,StackPush() StackPop() StackIsEmpty(),2,4,3,0.228319168,0.771680832,0.708659697,0.038206879,0.155885843,0.981318,0.786398708,0.999616787,0.54814906,0.915277034,0.773867674,0.971381778,0.928379636,0.569266796,0.463085077
1418,1418,1505,9.1,A data structure in c++ which is a collection of data that is kept in order.  First in first out.,5,5,5,0.023866832,0.976133168,0.969545395,0.456703007,0.523177414,0.993347967,0.923943752,0.999976948,0.97281893,0.969685819,0.919089043,0.978392384,0.945924477,0.853650391,0.817573081
1419,1419,1506,9.1,a queue is a list of objects in a particular order that is read one at a time starting at the first followed by the second and so on.,4,4,4,0.020598352,0.979401648,0.973716048,0.167127401,0.26903246,0.989164227,0.87610881,0.999965577,0.959411207,0.970856742,0.92221433,0.977479231,0.943639208,0.818354845,0.773576705
1420,1420,1507,9.1,A queue is an abstract data structure in which operations are performed at both ends giving the queue first in first out behavior.,5,5,5,0.022257447,0.977742553,0.971599006,0.298904717,0.384686332,0.992218882,0.911034312,0.999965603,0.959442279,0.968423293,0.915719261,0.980333733,0.950782925,0.835821688,0.795349361
1421,1421,1508,9.1,"A queue stores a set of elements in a particular order.  Its principle of operation is FIFO(first in first out), which means the first element inserted is the first one to be removed.",5,5,5,0.016123116,0.983876884,0.979426548,0.463778079,0.529386824,0.994489855,0.936999567,0.999975934,0.971623067,0.960845218,0.895492777,0.969535669,0.923759538,0.867029309,0.834250084
1422,1422,1509,9.1,An ADT whose first inserted item is the first item removed. This uses the FIFO idea where items enter a queue at its back and leave at its front.,5,5,5,0.019423962,0.980576038,0.975214596,0.419375897,0.490417414,0.991858761,0.906916862,0.999983675,0.980750931,0.973015963,0.927977462,0.980073696,0.950132152,0.836575925,0.796289528
1423,1423,1510,9.1,"Last in, last out architecture. It works the same way a line at the bank would work, the person that's been waiting the longest gets served first.",5,5,5,0.017099679,0.982900322,0.978180432,0.354377776,0.433372056,0.992568182,0.915028052,0.999977848,0.973880489,0.960633396,0.894927407,0.981803005,0.954459945,0.807949364,0.760606132
1424,1424,1511,9.1,a queue is a data structure that stores elements in a First in First out order.,5,5,5,0.022052646,0.977947354,0.971860337,0.351654112,0.430981642,0.989649807,0.881660708,0.999957707,0.9501312,0.947954616,0.861086736,0.978726838,0.946761487,0.835758388,0.795270457
1425,1425,1512,9.1,A waiting list of items that operation in a FIFO (first in first out) order.,5,5,5,0.028952837,0.971047163,0.96305554,0.323825926,0.406558338,0.99351656,0.925871365,0.999977916,0.973959943,0.972716161,0.927177267,0.97744063,0.943542604,0.779060602,0.724595899
1426,1426,1513,9.1,"A queue is similar to an array, except that the data can only be accessed sequentially rather than at random. Unlike a stack, a queue follows FIFO. First in, First out.",5,5,5,0.01615715,0.98384285,0.979383119,0.329319686,0.411379916,0.993945424,0.93077479,0.999972201,0.967221935,0.952531789,0.873303574,0.981075756,0.952639922,0.76968199,0.712905332
1427,1427,1514,9.1,is a particular kind of collection in which the entities in the collection are kept in order and the principal (or only) operations on the collection are the addition of entities to the rear terminal position and removal of entities from the front terminal position. First in First Out (FIFO Method).,5,5,5,0.018768013,0.981231988,0.976051601,0.35016802,0.429677378,0.990380198,0.890011658,0.999979548,0.975884727,0.949926165,0.866348957,0.978284628,0.945654806,0.831240654,0.78963904
1428,1428,1515,9.1,Like a linked list but first in first out,4,5,4.5,0.049263597,0.950736404,0.937138563,0.067118548,0.181260062,0.983139926,0.807229759,0.99990894,0.892630124,0.952792981,0.874000717,0.927445287,0.818423558,0.683193207,0.605095892
1429,1429,1516,9.1,A queue is a FIFO data structure.,5,5,5,0.039283812,0.960716188,0.949872988,0.314620942,0.398479618,0.985456537,0.833716806,0.999933268,0.921315785,0.938709083,0.836409674,0.902683076,0.756453302,0.810363412,0.763615275
1430,1430,1517,9.1,A queue is a first in first out data structure.,5,5,5,0.029692769,0.970307231,0.962111371,0.297185183,0.383177189,0.98898537,0.874063848,0.999944731,0.934831969,0.9522268,0.872489535,0.943211604,0.857880564,0.79376334,0.74292306
1431,1431,1518,9.1,"Its like a stack, but uses the linked list to stack a little differently. It's FIFO so the first thing enqueued is the first thing dequeued",5,5,5,0.023005486,0.976994515,0.970644492,0.239436522,0.332494291,0.993081703,0.920899414,0.9999637,0.957198215,0.958087564,0.888132379,0.97064745,0.926541897,0.791441023,0.740028261
1432,1432,1519,9.1,"A first in, first out Abstract Data type that can be used to store values.",5,5,5,0.015285134,0.984714866,0.980495831,0.388170362,0.463029993,0.991344941,0.901042086,0.999920618,0.906400151,0.962540878,0.900018628,0.978332078,0.945773555,0.851529658,0.814929558
1433,1433,1520,9.1,"Stores a set of elements in a particular order with a First In, First Out principle",5,5,5,0.030147254,0.969852746,0.961531437,0.091794677,0.202916975,0.98874167,0.871277497,0.999962982,0.956351781,0.955484307,0.88118408,0.977636129,0.944031863,0.831303358,0.789717202
1434,1434,1521,9.1,object that stores elements in order that follows first in first out.  the first element added is the first one to come off.,5,5,5,0.021790028,0.978209972,0.972195443,0.367552251,0.444934584,0.991999472,0.908525684,0.999971895,0.966860776,0.956842485,0.884809165,0.972307555,0.930696499,0.799143791,0.749629866
1435,1435,1522,9.1,"A quese is an list that stores a set of elements in a particular order. It has Stack principle, but in this case, its ""First In, First Out"". The first element inserted is the first element to be removed.",5,5,5,0.016809046,0.983190954,0.978551286,0.449498862,0.516854723,0.990592829,0.892442778,0.999977356,0.973299977,0.954398644,0.878286359,0.975292465,0.938166577,0.874874175,0.844028815
1436,1436,1523,9.1,"a finite ordered list with zero or more elements, based upon First In First Out",5,5,5,0.027709126,0.972290874,0.964642542,0.079008013,0.191694807,0.989435064,0.879205432,0.999957969,0.950440792,0.956042677,0.882674413,0.97341259,0.933461975,0.798747718,0.749136156
1437,1437,1524,9.1,a data structure that performs operations in the order of first in first out FIFO,5,5,5,0.033360362,0.966639638,0.957431441,0.196468785,0.294783817,0.992447042,0.91364299,0.999975475,0.971082119,0.961264077,0.896610745,0.982495907,0.956194011,0.758276522,0.698688261
1438,1438,1525,9.1,"A Queue is a ""first in first out"" data structure, such that the first element added is also the first removed.",5,5,5,0.020157516,0.979842484,0.974278564,0.463541955,0.529179591,0.993577178,0.926564439,0.999953816,0.945544082,0.955334239,0.880783536,0.964583629,0.911366493,0.811139643,0.764582858
1439,1439,1526,9.1,"Queue is a buffer, which store element in a particular order",2,5,3.5,0.029501557,0.970498443,0.962355361,0.204952911,0.302229878,0.985992549,0.839845318,0.999904196,0.887036702,0.955969967,0.882480345,0.976542595,0.941295169,0.800389588,0.751182768
1440,1440,1527,9.1,"stores a set of elements where the first element in, is the first element to be removed",5,5,5,0.02337122,0.97662878,0.970177807,0.395911276,0.469823778,0.991516858,0.903007704,0.999975185,0.970740484,0.952035795,0.871979727,0.968793083,0.921901132,0.840644777,0.801361407
1441,1441,1528,9.1,A data structure that removes nodes from the head and adds nodes at the tail.,5,5,5,0.024199486,0.975800514,0.969120922,0.369522691,0.446663934,0.993224964,0.922537389,0.999958127,0.950626937,0.961540027,0.897347277,0.981222327,0.953006732,0.743682444,0.680496545
1442,1442,1529,9.1,a queue is a list of things that follows the first in first out behavior,5,5,5,0.025997877,0.974002123,0.966826134,0.161680996,0.264252443,0.988556388,0.869159061,0.999952622,0.944136173,0.954285853,0.877985311,0.96734591,0.918279417,0.69432056,0.618966288
1443,1443,1530,9.1,"a queue is a storage container that holds its objects in a first in, first out priority",5,5,5,0.025109828,0.974890173,0.967959305,0.147807375,0.252076311,0.992133989,0.910063689,0.999942017,0.931631892,0.964427792,0.905054951,0.975668148,0.939106766,0.723796368,0.655708282
1444,1444,1531,9.1,"The queue is another data structure. A physical analogy for a queue is a line at a bank. When you go to the bank, customers go to the rear (end) of the line and customers come off of the line (i.e., are serviced) from the front of the line.",5,5,5,0.015797138,0.984202862,0.979842503,0.290705711,0.377490504,0.990722984,0.893930918,0.999971467,0.966356772,0.943489378,0.849168661,0.977982234,0.94489803,0.845807672,0.807797025
1445,1445,1532,9.2,enqueue which adds data to the queue and dequeue which deletes data from the queue,5,5,5,0.181569576,0.818430424,0.768313209,0.624561429,0.670497734,0.983872098,0.815601074,0.99992399,0.910375999,0.947400816,0.8596086,0.974513467,0.936217045,0.728521287,0.661597958
1446,1446,1533,9.2,"enqueue , which inserts a specified element at the head of the specified queue, and dequeue , which removes the specified element from the queue.",5,5,5,0.21420598,0.78579402,0.726668437,0.43638283,0.505343486,0.974349344,0.706722335,0.999876323,0.854171001,0.804637582,0.478562189,0.991659773,0.979127631,0.694581509,0.619291564
1447,1447,1534,9.2,The two main functions are enqueue which inserts an item at the back of the queue and dequeue which removes an item from the front of the queue.,5,5,5,0.215403259,0.784596741,0.725140683,0.443951994,0.511986535,0.978337211,0.752317753,0.999915108,0.899902693,0.91847458,0.782402179,0.983091013,0.957683332,0.746316075,0.683779402
1448,1448,1535,9.2,The two main functions are enqueue and dequeue.,5,5,5,0.152285039,0.847714961,0.805680925,0.654105187,0.696426703,0.986550106,0.846220166,0.999977958,0.974009444,0.958531807,0.889318099,0.96953577,0.923759791,0.901305258,0.876975519
1449,1449,1536,9.2,Enqueue and Dequeue,5,5,5,0,1,1,0.791285157,0.816822194,1,1,1,1,1,1,1,1,1,0.999999851
1450,1450,1537,9.2,Enqueue and Dequeue,5,5,5,0,1,1,0.791285157,0.816822194,1,1,1,1,1,1,1,1,1,0.999999851
1451,1451,1538,9.2,enqueue - insert into queue dequeue - remove element,5,5,5,0.178976238,0.821023762,0.771622366,0.624149978,0.670136626,0.978512516,0.754322106,0.999857533,0.83201593,0.850075894,0.599840653,1,1,0.830330312,0.788504287
1452,1452,1539,9.2,"Remove the item added first, add items to the back.",5,5,5,0.252503753,0.747496247,0.677799633,-0.031791557,0.094451976,0.983223911,0.808190002,0.999731157,0.683003285,0.8468951,0.591350861,0.967202042,0.917919371,0.491249889,0.365835946
1453,1453,1540,9.2,The two main functions of a queue are enqueue and dequeue.,5,5,5,0.171051204,0.828948796,0.781734884,0.694855809,0.732191336,0.986801208,0.849091155,0.999951463,0.942769106,0.958531807,0.889318099,0.96953577,0.923759791,0.901305258,0.876975519
1454,1454,1541,9.2,enqueue and dequeue.,5,5,5,0.055481553,0.944518447,0.929204313,0.861480951,0.878429272,0.998638349,0.98443152,0.999984876,0.982166564,1,1,1,1,1,0.999999851
1455,1455,1542,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1456,1456,1543,9.2,Enqueue and Dequeue,5,5,5,0,1,1,0.791285157,0.816822194,1,1,1,1,1,1,1,1,1,0.999999851
1457,1457,1544,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1458,1458,1545,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1459,1459,1546,9.2,"enque ( Data ),  Deque ( )",5,5,5,0.220198751,0.77980125,0.71902153,0.19461897,0.293160334,0.978626058,0.755620292,0.99986897,0.845500723,0.957774417,0.887296565,0.975080337,0.937635702,0.605608225,0.508385161
1460,1460,1547,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1461,1461,1548,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1462,1462,1549,9.2,"The two functions are, Enqueue and Dequeue",5,5,5,0.127262771,0.872737229,0.837609892,0.635673344,0.680250065,0.989086904,0.875224732,0.99995972,0.952505644,0.958531807,0.889318099,0.96953577,0.923759791,0.901305258,0.876975519
1463,1463,1550,9.2,"enqueue, dequeue",5,5,5,0.046208024,0.953791976,0.941037541,0.952721655,0.958506337,0.990693772,0.893596923,0.999979787,0.97616713,1,1,1,1,1,0.999999851
1464,1464,1551,9.2,"enqueue, that adds an item to the queue dequeue, that takes the first item out of the queue",5,5,5,0.206406891,0.793593109,0.736620247,0.554314077,0.608845407,0.977727184,0.745342983,0.999914864,0.899614803,0.933188221,0.821674055,0.989516102,0.97376285,0.755409539,0.695114528
1465,1465,1552,9.2,"Enqueue and dequeue, which add and remove elements from the queue",5,5,5,0.150485456,0.849514544,0.807977233,0.706270278,0.742209201,0.985846325,0.838173462,0.999908267,0.891836855,0.923340799,0.795390504,0.974780508,0.936885346,0.816952109,0.771828176
1466,1466,1553,9.2,Enqueue and Dequeue,5,5,5,0,1,1,0.791285157,0.816822194,1,1,1,1,1,1,1,1,1,0.999999851
1467,1467,1554,9.2,dequeue and enqueue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1.000000119,1
1468,1468,1555,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1469,1469,1556,9.2,enqueue and dequeue,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1470,1470,1557,9.2,enqueue dequeue,5,5,5,0.076930463,0.923069537,0.901835029,0.95816648,0.963284967,0.99455103,0.937699009,0.999773197,0.732574291,1,1,1,1,1,0.999999851
1471,1471,1558,9.2,rear and front,2,3,2.5,0.245510757,0.754489243,0.68672285,0.020799778,0.140608566,0.985636919,0.835779212,0.99987335,0.850665011,0.977775623,0.940681373,0.911028683,0.777339135,0.47461319,0.345098074
1472,1472,1559,9.3,Make use of a front pointer and a tail pointer.  When the tail pointer reaches the end of an array it gets reset to the front of the array.  If the two pointers are equal then the queue is either full or just has one element.,5,4,4.5,0.010630846,0.989369154,0.986434806,0.568076789,0.6209242,0.994111269,0.932670989,0.999950428,0.941549545,0.950571632,0.86807176,0.966325003,0.91572448,0.887174308,0.859361098
1473,1473,1560,9.3,you create an array with the max size of your queue and adjust the items to make them follow FIFO procedure.,2,4,3,0.014576972,0.985423029,0.981399462,0.399920225,0.473342217,0.989828641,0.883705416,0.999922813,0.908988302,0.96232573,0.899444381,0.967230343,0.917990197,0.766854286,0.709380561
1474,1474,1561,9.3,By implementing an array and only adding items to the end of the array and only removing items from the beginning of the array.,2,4,3,0.015579641,0.984420359,0.980120034,0.516616941,0.575760655,0.991465181,0.902416854,0.999969253,0.963745967,0.963803472,0.903388592,0.957168376,0.892808977,0.791540802,0.740152636
1475,1475,1562,9.3,"For applications in which a fixed-sized queue does not present a problem, you can use an array to represent a queue. ",1,4,2.5,0.026994348,0.973005652,0.965554616,0.315107167,0.398906351,0.992418959,0.9133219,0.999932576,0.920499621,0.961192147,0.896418758,0.9530768,0.882569342,0.626827896,0.534835768
1476,1476,1563,9.3,Keep track of the front and the back of the array as you increase and decrease the elements inside the array.,4,4,4,0.009597182,0.990402818,0.987753783,0.587620974,0.638077081,0.990867257,0.89558047,0.999975731,0.971384329,0.947573874,0.860070506,0.965111929,0.912688624,0.891242087,0.864431639
1477,1477,1564,9.3,"Declare the size of an array, and have special conditional statements (pointers) to make sure you re-use ALL of the array. Say, you have an array of 20 elements, you load up 18, then dequeue 3, when you enqueue 4 more elements, you want to loop back to index 0 and continue from there... this process saves resources.",5,4,4.5,0.020869613,0.979130387,0.973369913,0.355422348,0.43428882,0.988922008,0.873339394,0.999974953,0.970466322,0.975997409,0.935935178,0.970438138,0.92601807,0.794930637,0.744378112
1478,1478,1565,9.3,you could use the first element of the list as the remove point and insert at the end f you do this you would have to shift the elements down each time you remove an item unless you make the array circular.,3,5,4,0.017419875,0.982580125,0.977771855,0.248714969,0.340637485,0.989008771,0.874331406,0.999901223,0.883530662,0.963459406,0.902470252,0.966205125,0.915424472,0.831123769,0.789493342
1479,1479,1566,9.3,Utilizing indexes for the front and the back.  Front is 0 and as you add items the back index is incremented.,4,4,4,0.019691706,0.980308294,0.974872949,0.418061823,0.489264122,0.993115644,0.921287479,0.999958366,0.950908534,0.96917438,0.917723972,0.964539918,0.911257102,0.83845818,0.798635785
1480,1480,1567,9.3,"Declare two variables, â€œfrontâ€ and â€œrearâ€, to be used to denote which elements in the array can be accessed. Increment â€œrearâ€ whenever data is enqueued to the end and increment â€œfrontâ€ whenever data is dequeued.",5,4,4.5,0.036191344,0.963808656,0.953819045,0.218277559,0.313924206,0.990879829,0.895724206,0.999977115,0.973016301,0.907864525,0.754083099,0.963010537,0.907429651,0.783443689,0.730059476
1481,1481,1568,9.3,It is an array of fixed size. A queue of maximum N elements.,1,4,2.5,0.026027918,0.973972082,0.966787802,0.406414777,0.479042136,0.989669242,0.881882914,0.999947025,0.937536681,0.949554651,0.865357357,0.953938795,0.884726583,0.710424721,0.639040343
1482,1482,1569,9.3,"make an array of a size, and add on to the front and delete from the back, keep track of the two so that you know when it is full and where to add or subtract from",4,4,4,0.014073372,0.985926628,0.982042067,0.340513498,0.421204123,0.993284106,0.92321359,0.999895117,0.876331301,0.969063793,0.917428806,0.954935768,0.887221621,0.853003919,0.816767245
1483,1483,1570,9.3,By using the beginning of the array as the removal point of the queue (or beginning of the queue) and the ith element as the end of the queue.,3,4,3.5,0.013216317,0.986783683,0.983135688,0.542044818,0.598077338,0.9960321,0.954632882,0.999968964,0.963404703,0.962660352,0.900337514,0.966700251,0.916663581,0.867825925,0.835243077
1484,1484,1571,9.3,"add in data from the first element to the last, take out data from the first element to the last.",2,4,3,0.027908027,0.972091973,0.964388741,0.192056552,0.290911436,0.994919668,0.941913848,0.999813237,0.779785758,0.927026185,0.805227092,0.958818757,0.896939244,0.73701036,0.672179702
1485,1485,1572,9.3,you can take the array and put it in a queue stack or you can just traverse the list and keep track of top and bottom,3,4,3.5,0.023137987,0.976862013,0.970475418,0.301680952,0.387122884,0.988127414,0.864254374,0.999920757,0.906563005,0.963801773,0.903384057,0.961964384,0.904811534,0.870762706,0.838903813
1486,1486,1573,9.3,"create a fixed array size, with with 2 integers to point to the beginning and the end of the que, and special cases to know when the que is empty or full.",4,4,4,0.012591541,0.987408459,0.983932916,0.41865918,0.489788391,0.993229642,0.922590878,0.999959469,0.952209003,0.969179143,0.917736685,0.971169306,0.927847901,0.768266976,0.711141497
1487,1487,1574,9.3,Keep track of the front and rear indexes. Either: 1)Dequeue items by shifting the array left 2)Use wrapped configuration,4,4,4,0.02814585,0.97185415,0.964085274,0.541240752,0.597371651,0.996022667,0.954525028,0.999973717,0.96900896,0.968333295,0.915479049,0.968414155,0.920952822,0.880229354,0.850704118
1488,1488,1575,9.3,"add items into a fixed size array, pull the items out by calling on them with the starting index, increase starting index so when it calls again its now the next index element in the array.",3,4,3.5,0.018758476,0.981241524,0.97606377,0.354646146,0.43360759,0.990067946,0.886441518,0.999934679,0.922978967,0.948913523,0.863646135,0.965176018,0.912849014,0.801579118,0.752665534
1489,1489,1576,9.3,"To use and array to implement a Queue, element or item 0, should be the top element in the array. Every time an element is inserted, all the items in the array are pushed back one space. The top element is always removed first.",2,4,3,0.018515706,0.981484294,0.97637355,0.441617638,0.509937796,0.991750122,0.905674735,0.999971116,0.965942821,0.947918347,0.860989931,0.968314631,0.920703751,0.830202699,0.788345215
1490,1490,1577,9.3,fixed size array with max N elements.  Need to keep track of front and rear of array.,4,4,4,0.013247013,0.986752987,0.983096519,0.572593153,0.624887969,0.990908594,0.896053098,0.999975087,0.970624586,0.961896618,0.898299047,0.947079336,0.867560004,0.878058136,0.847997665
1491,1491,1578,9.3,"by keeping track of a front item and a rear item, or with a circular array that uses the modulo function",5,5,5,0.018550575,0.981449425,0.976329057,0.447915316,0.515464929,0.993776801,0.92884684,0.999966964,0.961046904,0.964934873,0.906408391,0.965071479,0.912587394,0.838608086,0.798822644
1492,1492,1579,9.3,"Using an array for a queue, the size of the array allocated limits the size of the queue. An array based queue class must keep track of both the front and back of the queue, which may need to wrap around the array.",5,5,5,0.007000625,0.992999375,0.991067048,0.620883584,0.667269887,0.99596293,0.953842021,0.999889463,0.869664863,0.968603276,0.91619965,0.969865187,0.924584195,0.884510517,0.856040646
1493,1493,1580,9.3,"A pointer based implementation of a queue could use a linear linked list with two external pointers, one to the front and one to the back",0,4,2,0.017071307,0.982928693,0.978216636,0.290751457,0.377530653,0.994290559,0.934720907,0.999944097,0.934084493,0.962835587,0.90080523,0.964159115,0.910304099,0.812261403,0.765981146
1494,1494,1581,9.3,remove the element then shift the elements one space back,2,4,3,0.039657235,0.960342765,0.949396492,0.109236233,0.218224492,0.991437348,0.902098617,0.999941011,0.930445599,0.962028377,0.898650722,0.963173881,0.907838438,0.784482419,0.731354267
1495,1495,1582,9.3,By having the head pointer point to the first or least current data entered and having the tail point to the most current data entered. A method must be created so that the tail pointer doesn't leave the array.,5,5,5,0.020670176,0.979329824,0.973624399,0.345398217,0.425491179,0.992820631,0.91791443,0.999976008,0.971710942,0.947081611,0.858756617,0.954079573,0.885078896,0.84505403,0.806857601
1496,1496,1583,9.3,an array is a type of queue with a fixed length,0,3,1.5,0.031413436,0.968586564,0.959915762,0.289977461,0.376851359,0.985881335,0.838573756,0.999870058,0.846783951,0.918574764,0.782669578,0.904468545,0.760921642,0.607843101,0.511170964
1497,1497,1584,9.3,"your storage class has an array, and you keep track of the index of the first and last item in the array, and wrap around when end of the array is full",5,5,5,0.013162613,0.986837387,0.983204215,0.503214002,0.563997616,0.992851668,0.918269301,0.999844521,0.816672231,0.97068542,0.921757058,0.968783491,0.921877127,0.866010129,0.832979662
1498,1498,1585,9.3,Boolean isFullQ(queue) ::= rear == MAX_QUEUE_SIZE-1,5,5,5,0.186266959,0.813733041,0.762319246,0.187506288,0.286917915,0.982959969,0.805172216,0.999900606,0.882803389,0.881000077,0.682379753,0.961687719,0.904119149,0.565817833,0.458785898
1499,1499,1586,9.4,A list can have unlimited elements in it.  You can push a node onto the end of the list and pop the one in the front.,5,5,5,0.011930048,0.988069952,0.984776995,0.475130349,0.539350103,0.981495398,0.788426994,0.999807236,0.772708958,0.946729537,0.857816903,0.971202177,0.927930164,0.812286079,0.766011906
1500,1500,1587,9.4,theoretically you could do it two ways one of which uses more processing power and memory no larger than the queue is ever at when full and the other which uses almost infinite memory. The more practical method would be two place the items in an array and remove the item in position one of the array after which you can shift the array and add another element if required. The other option which can use infinite memory when used for long term queues such as job scheduling that goes nonstop for extended periods. that is to implement an array and add the items read item one raise your counter value to two ecetera and continue adding more elements to the array. the downside to this method is after you use element one it is still in memory. or im crazy who knows,0,4,2,0.019869328,0.980130673,0.974646299,0.20294179,0.300464826,0.987292383,0.85470702,0.999858425,0.833067408,0.934144408,0.824226194,0.979754868,0.949334249,0.847502768,0.809909986
1501,1501,1588,9.4,"By implementing a list in which a tail pointer points to the item most recently inserted onto the back of the list and a head pointer which points to the item least recently inserted onto the list. Also, items can only be removed from the front of the list and can only be added to the back of the list.",5,5,5,0.010495186,0.989504814,0.986607911,0.495486528,0.557215627,0.991672398,0.904786076,0.999936062,0.924609612,0.960104936,0.893516905,0.976150849,0.94031478,0.882916331,0.854053472
1502,1502,1589,9.4,You can use list to represent the items in a queue.,0,3,1.5,0.024586797,0.975413203,0.968626704,0.423335522,0.493892565,0.978533868,0.754566237,0.999780662,0.741376117,0.910367997,0.760765065,0.969664347,0.92408157,0.633339047,0.542952007
1503,1503,1590,9.4,Have a pointer to the last element in the list and then use enqueue to insert items there. Link the first and last elements together to dequeue the list.,3,4,3.5,0.018339038,0.981660962,0.976598983,0.493991941,0.555903909,0.987057746,0.852024289,0.999824314,0.792846386,0.944311756,0.851363653,0.976446723,0.941055239,0.866981208,0.834190125
1504,1504,1591,9.4,Enqueue to the end of the linked list... dequeue items from the beginning (head) of the list.,5,5,5,0.015909076,0.984090924,0.979699668,0.665550828,0.706471928,0.991142981,0.898732961,0.999840642,0.812098392,0.920053109,0.786615398,0.970568239,0.926343662,0.906191587,0.883066394
1505,1505,1592,9.4,you use the first element in the list as the remove point for the queue and insert items at the end of the list.,5,5,5,0.012454212,0.987545788,0.984108151,0.607838571,0.65582098,0.985435401,0.833475152,0.999872758,0.84996763,0.937617689,0.833496657,0.973002956,0.932436819,0.825971663,0.783071172
1506,1506,1593,9.4,"Utilizing a front pointer and a back pointer.  The front poiner and back pointer points to the first item into the queue.  As you add items, the front remains the same but the back poiner 'next' points to the new item and the new item is assigned to become the 'new' back pointer.",5,4,4.5,0.016940296,0.983059704,0.978383808,0.298329413,0.384181418,0.987409155,0.856042131,0.99990851,0.892122604,0.928911563,0.810259315,0.973193066,0.932912591,0.883745849,0.855087477
1507,1507,1594,9.4,Implement a linked list that only allows nodes to be added to the tail and can only be retrieved from the head.,5,4,4.5,0.023812056,0.976187944,0.969615291,0.430956274,0.50058089,0.984208484,0.819447149,0.999819829,0.787558539,0.925735009,0.80178084,0.965316351,0.913200214,0.836685419,0.796426014
1508,1508,1595,9.4,Check if list is empty and add elements to the list.,1,4,2.5,0.02851218,0.97148782,0.963617829,0.400372326,0.473739002,0.982483679,0.79972653,0.999738081,0.691167519,0.903481853,0.742385399,0.955394211,0.888368927,0.687485278,0.610446016
1509,1509,1596,9.4,"make a linked list and add on to the front and delete from the back, keep track of both to do so.",5,4,4.5,0.016201079,0.983798921,0.979327065,0.503147602,0.56393934,0.988439567,0.867823385,0.999841927,0.813614506,0.945498184,0.854530324,0.967190412,0.917890265,0.892123044,0.865529764
1510,1510,1597,9.4,by making the head of the list the beginning of the queue and the last listed item the insertion point of the queue,5,4,4.5,0.010429859,0.989570141,0.986691269,0.73819077,0.770224103,0.987269255,0.854442579,0.99989989,0.881958572,0.927712755,0.807059601,0.973544121,0.933791146,0.841025054,0.801835428
1511,1511,1598,9.4,throw in data at the head and take it out at the tail,4,5,4.5,0.024236619,0.975763381,0.969073538,0.328531712,0.410688354,0.979480288,0.765387158,0.999814798,0.781625656,0.921989867,0.791784759,0.966098614,0.915157916,0.858267009,0.823327758
1512,1512,1599,9.4,"You create a list of nodes that had a head and a top pointer, and the functions are basically the same substituting pop and push with enqueue and dequeue",2,4,3,0.020140469,0.979859531,0.974300317,0.332874119,0.414499451,0.99026515,0.888696248,0.999798367,0.762251806,0.959874527,0.892901925,0.975444945,0.938548175,0.864736021,0.831391468
1513,1513,1600,9.4,"fairly easy... singly linked list with a pointer to the head and tail of hte list.  deque first item in que, create temp pointer to next element, delete head, and then make head the temporary pointer.  enque new item, use pointer to end of list, add a new item to the next item of the tail, and make the tail the next item of the current tail.",5,4,4.5,0.014442921,0.985557079,0.981570514,0.436837703,0.505742704,0.991121512,0.898487495,0.999898275,0.880055009,0.927504772,0.806504478,0.941457101,0.85348972,0.901757836,0.877539663
1514,1514,1601,9.4,"Use a linked list with 2 pointers, one to the front and one to the back. As long as back != front, the queue is not empty.",5,4,4.5,0.020838916,0.979161084,0.973409082,0.451539785,0.518645931,0.988763182,0.87152345,0.999817231,0.784494263,0.948308525,0.862031347,0.966727505,0.916731788,0.852360785,0.81596557
1515,1515,1602,9.4,"create a node with the input data, continue to add to the list.  when dequeueing - get the first elements data and set the next element in the list as the new first element",4,4,4,0.020685971,0.979314029,0.973604244,0.395050347,0.469068186,0.988627712,0.869974555,0.999829801,0.799316601,0.933090045,0.821412016,0.96781359,0.919449839,0.832141519,0.79076198
1516,1516,1603,9.4,"A linked list with Stack principles. The Queue's top element is the element that is always being removed first. Must use nodes to contain each element, with a pointer to the top element, which also could  be called the head pointer.",2,4,3,0.020738482,0.979261518,0.973537238,0.36404261,0.441854361,0.988675391,0.870519686,0.999749802,0.704988123,0.950718694,0.86846428,0.97570339,0.939194963,0.866854668,0.834032391
1517,1517,1604,9.4,linked list checking for front and rear.  Keep enqueueing elements until front equal to rear -1.,3,4,3.5,0.035065055,0.964934945,0.955256215,0.323355466,0.406145441,0.982239245,0.796931791,0.999829888,0.799419095,0.937565904,0.833358439,0.978938931,0.947292273,0.883014917,0.854176361
1518,1518,1605,9.4,"a queue can be implemented in a list by keeping track of two pointers, a head and a tail",5,4,4.5,0.023171067,0.976828933,0.970433206,0.47115466,0.535860854,0.98137111,0.787005942,0.999782193,0.743180761,0.939005932,0.837201988,0.966861699,0.917067623,0.882280946,0.853261455
1519,1519,1606,9.4,"each element of a queue can be allocated in the nodes of an linked list. New elements should be added to the head of the list, with each dequeued element coming off the tail.",5,5,5,0.015012681,0.984987319,0.980843487,0.561345458,0.615016472,0.98740374,0.855980222,0.999824461,0.793019649,0.951601869,0.870821544,0.977985587,0.944906421,0.851959825,0.815465767
1520,1520,1607,9.4,"Implement the operation dequeue() as the list operation remove(1) and the operation getFront(queueFront) as the list operation retrieve(1, queueFront)",3,5,4,0.034861088,0.965138912,0.955516482,0.252584696,0.344033737,0.980186721,0.773464189,0.999873061,0.850325146,0.953044264,0.874671411,0.977858019,0.944587168,0.724437296,0.656507208
1521,1521,1608,9.4,remove the first element and reference the second element as the new head of the list.,3,4,3.5,0.023112297,0.976887703,0.970508198,0.362454295,0.440460383,0.986747988,0.848482662,0.999768975,0.727595865,0.933018143,0.821220103,0.966853597,0.917047347,0.813838661,0.76794722
1522,1522,1609,9.4,By creating and adding nodes at the end of the list and removing the nodes from the beginning of the list.,5,5,5,0.011523664,0.988476336,0.98529555,0.527887046,0.585651822,0.985582256,0.835154225,0.999855103,0.829150572,0.914778751,0.772537717,0.971572937,0.928858034,0.769391596,0.712543352
1523,1523,1610,9.4,you would have your list and add a back pointer so that your program knows where the end is,4,4,4,0.033708155,0.966291845,0.956987649,0.298115879,0.383994011,0.984300818,0.820502855,0.999768027,0.726477506,0.929978915,0.813108162,0.915516254,0.788569793,0.803899348,0.755557732
1524,1524,1611,9.4,"your queue storage class has a list, and for enqueue, you add the item to the end of the list, and for dequeue you return the first item in the list",4,5,4.5,0.013689578,0.986310422,0.982531797,0.552159429,0.606954388,0.990940041,0.896412644,0.999829293,0.798717733,0.949734847,0.865838314,0.973381763,0.933384827,0.867007256,0.834222594
1525,1525,1612,9.4,temp-&gt;next= NULL;       if (front)  { (rear) -&gt; next= temp;}       else front = temp;       rear = temp;   },3,4,3.5,0.114057422,0.885942578,0.85446021,0.085201256,0.197130284,0.958639227,0.527100158,0.99972927,0.680778775,0.947219539,0.859124757,0.966319983,0.915711917,0.81316489,0.767107355
1526,1526,1640,9.6,Push.,5,5,5,0.125480771,0.874519229,0.839883764,0.438823938,0.507485916,0.949310408,0.420438789,0.999734633,0.687102695,0.999988869,0.99997029,1,1,1,0.999999851
1527,1527,1641,9.6,"push, which inserts something at the top of the stack.",5,5,5,0.165891409,0.834108591,0.788318897,0.337653756,0.418694282,0.946080326,0.383507537,0.999747147,0.701857577,0.922302782,0.792619954,0.948534387,0.871201435,0.704440773,0.63158127
1528,1528,1642,9.6,The stack operation corresponding to enqueue in queues is the push operation.,5,5,5,0.153224111,0.846775889,0.80448265,0.291209072,0.377932277,0.941369359,0.32964453,0.999749375,0.704484771,0.983749076,0.956624993,0.951068015,0.877542128,0.814183891,0.768377554
1529,1529,1643,9.6,"Push in a stack operation corresponds to the enqueue operation in queues.  These operations insert a new item into one end(the top and back, respectively) of the ADT.",5,5,5,0.185813785,0.814186215,0.762897506,0.122254513,0.229649937,0.931346971,0.215053201,0.999762139,0.719535562,0.910110809,0.760078609,0.982713408,0.956738333,0.562861502,0.455100792
1530,1530,1644,9.6,The stack operation is almost the opposite of the enqueue operation.,0,5,2.5,0.188974083,0.811025918,0.758864896,0.033965752,0.152163634,0.934532388,0.251473782,0.9997085,0.656288855,0.963508339,0.902600858,0.945018116,0.862401566,0.311717421,0.142046292
1531,1531,1645,9.6,push = enqueue pop = dequeue,5,4,4.5,0.18592453,0.81407547,0.762756192,0.342970252,0.423360285,0.948655684,0.412952972,0.999513002,0.425774717,0.957699437,0.887096437,0.973463009,0.933588154,0.777970612,0.723237211
1532,1532,1646,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1533,1533,1647,9.6,Not sure what this question means.  You can use the stack 'push' operation and the enqueue operation to detect palindromes.,5,5,5,0.159510732,0.840489268,0.796460782,0.073715433,0.187049794,0.924982952,0.142289977,0.99969676,0.64244586,0.895930055,0.722229051,0.977658468,0.944087769,0.53348279,0.418479829
1534,1534,1648,9.6,"Enqueue is the queue equivalent of push, and dequeue is the queue equivalent to pop.",5,5,5,0.170221448,0.829778552,0.782793672,0.167798176,0.269621164,0.935270146,0.259908967,0.999753382,0.709209135,0.852685836,0.606806795,0.979020992,0.94749764,0.594823956,0.494942424
1535,1535,1649,9.6,Push operation.,5,5,5,0.11877358,0.88122642,0.848442288,0.414637953,0.486259176,0.945237329,0.373869092,0.999745789,0.700256243,0.999988869,0.99997029,1,1,1,0.999999851
1536,1536,1650,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1537,1537,1651,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1538,1538,1652,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1539,1539,1653,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1540,1540,1654,9.6,"that would be the push operation, if it put the item at the end of the list.",5,5,5,0.168987393,0.831012607,0.784368353,0.304187775,0.389322987,0.938749207,0.299686932,0.999731904,0.683884283,0.846803376,0.591106042,0.967290118,0.918139791,0.647752583,0.560918674
1541,1541,1655,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1542,1542,1656,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1543,1543,1657,9.6,the Push method in the stack operations.,5,5,5,0.144722045,0.855277956,0.815331474,0.304894358,0.389943118,0.943333412,0.352100596,0.999671589,0.612765932,0.962338912,0.899479565,1,1,0.668986797,0.58738741
1544,1544,1658,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1545,1545,1659,9.6,enqueue corresponds with push dequeue corresponds with pop,5,4,4.5,0.159090579,0.840909421,0.796996907,0.359996378,0.438303201,0.948215544,0.407920618,0.999559666,0.480796182,0.923278108,0.795223176,0.975333618,0.938269567,0.606030524,0.508911562
1546,1546,1660,9.6,"Push corresponds with enqueue, both very similarly place new elements into their stack or queue",5,5,5,0.161053419,0.838946581,0.794492279,0.192397863,0.291210987,0.935802891,0.266000125,0.999749462,0.704587372,0.938099987,0.834783949,0.986434558,0.966050935,0.645885348,0.558591141
1547,1547,1661,9.6,FIFO: First in First out,0,3,1.5,0.256735385,0.743264616,0.672399977,0.013736907,0.134409864,0.940404738,0.318615499,0.999581764,0.506852879,0.928808509,0.809984256,0.947415602,0.868401548,0.36745736,0.211526881
1548,1548,1662,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1549,1549,1663,9.6,Push,5,5,5,0,1,1,0.654492259,0.696766416,0.964322203,0.592076668,0.999948829,0.939664117,0.999988869,0.99997029,1,1,1,0.999999851
1550,1550,1664,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1551,1551,1665,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1552,1552,1666,9.6,push,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
1553,1553,1694,10.1,A hierarchy of nodes that are sorted in a particular order.  Each node has a ancestor (except for the root) and children (except for the leaves).,3,5,4,0.017102897,0.982897103,0.978176325,0.451646328,0.518739439,0.993275064,0.923110214,0.999984251,0.981430065,0.965363468,0.907552345,0.986180845,0.965415989,0.851706326,0.815149778
1554,1554,1695,10.1,A tree is a finite set of one or more nodes with a specially designated node called the root and the remaining nodes are partitioned into disjoint sets where each of these sets is a tree.,5,5,5,0.004675806,0.995324194,0.994033569,0.838155329,0.857957626,0.980885625,0.781455133,0.999979207,0.975482387,0.952093027,0.872132484,0.984715244,0.961748155,0.971221507,0.964127069
1555,1555,1696,10.1,A tree is a finite set of one or more nodes such that: there is a specially designated node called the root.,4,5,4.5,0.010408759,0.989591241,0.986718193,0.701260328,0.737812238,0.979084329,0.760859948,0.999985323,0.982694617,0.978183751,0.941770699,0.9842839,0.960668668,0.917295933,0.896908111
1556,1556,1697,10.1,"A connected, undirected graph without cycles.",4,5,4.5,0.027517438,0.972482562,0.964887141,0.202404872,0.299993601,0.987339224,0.855242576,0.999958223,0.95074055,0.966280071,0.909998831,0.980216423,0.950489343,0.756507337,0.696482948
1557,1557,1698,10.1,"A data structure that contains a root, internal nodes and external nodes. Each node references another node by means of pointers (pass-by-reference). The root is the ""base"" of the tree, it has no parents. A ""leaf"" is a node at the end of the tree which points to NULL.",5,5,5,0.012914538,0.987085462,0.983520764,0.585660338,0.636356337,0.992929995,0.919164856,0.999973915,0.969242485,0.93374788,0.823167829,0.983431464,0.95853535,0.894784391,0.868847169
1558,1558,1699,10.1,a tree is a series of nodes where each node has links to other nodes.,1,5,3,0.012606561,0.987393439,0.983913749,0.629551351,0.674877121,0.981637593,0.790052779,0.999983168,0.980152915,0.959171278,0.891024898,0.980959431,0.952348805,0.769523263,0.712707476
1559,1559,1700,10.1,"an infinite set of nodes that have a root and descendants, and each addition is a leaf.",2,5,3.5,0.010337591,0.989662409,0.986809005,0.580034614,0.63141894,0.988138256,0.864378333,0.999985204,0.98255354,0.962788262,0.900678916,0.980801027,0.951952381,0.825940311,0.783032091
1560,1560,1701,10.1,"A set of one or more nodes that are hierarchically organized, with one special â€œrootâ€ node.",3,5,4,0.009452701,0.990547299,0.987938145,0.66821146,0.708807022,0.986194734,0.842157016,0.999987366,0.985103109,0.987880927,0.967653232,0.987794584,0.969454555,0.886959374,0.85909318
1561,1561,1702,10.1,A tree is a finite set of one or more nodes such that there is a specially designated node called the root.,2,5,3.5,0.011865199,0.988134801,0.984859744,0.701139867,0.737706516,0.979179549,0.761948651,0.999981288,0.977936837,0.978183751,0.941770699,0.9842839,0.960668668,0.917295933,0.896908111
1562,1562,1703,10.1,one or more nodes in a hierarchy starting with the root and branching off like a tree to subtrees,5,5,5,0.01536119,0.98463881,0.980398782,0.428450167,0.498381414,0.979213625,0.762338257,0.999970721,0.965476461,0.974389347,0.931643133,0.977429351,0.943514377,0.80013901,0.75087042
1563,1563,1704,10.1,A tree is a data structure where nodes are linked to each other in a hierarchical manner.,2,5,3.5,0.016595304,0.983404696,0.978824026,0.467168301,0.532362241,0.981633346,0.79000422,0.999975003,0.9705259,0.955284484,0.880650736,0.973090403,0.932655665,0.809360266,0.76236484
1564,1564,1705,10.1,a grouping of data in a parent to child structure,2,4,3,0.030454934,0.969545066,0.961138832,0.060317043,0.175290747,0.980975978,0.782488187,0.999976302,0.972056876,0.953341617,0.87546507,0.905575625,0.763692235,0.698243439,0.62385621
1565,1565,1706,10.1,It is a list of numbers in a list made by comparing values of nodes already in the tree and adding to the appropriate spot. Its a list made up of nodes with left and right pointers.,1,5,3,0.011022687,0.988977313,0.985934808,0.377525687,0.453687734,0.981399178,0.78732685,0.999953692,0.945397679,0.960864122,0.895543233,0.982741747,0.956809254,0.770596266,0.714044989
1566,1566,1707,10.1,"A tree is a branched data structure with nodes, and leaves... a special node called root has no parent node, but however like all other nodes can and does have 2 nodes that it links to, namely one on the right, and one on the left.",4,5,4.5,0.008680463,0.991319537,0.988923538,0.655079603,0.697281896,0.992753424,0.917146022,0.999986855,0.984500426,0.965923526,0.909047184,0.989544027,0.973832735,0.897170782,0.871821838
1567,1567,1708,10.1,"It organizes data in a nonlinear, hierarchical form, where items can have more than one successor.  Partitioned into a root node and subsets are general subtrees of the root. ",5,5,5,0.010657728,0.989342272,0.986400504,0.496387243,0.558006137,0.99454519,0.937632238,0.999985335,0.982708008,0.969296071,0.918048775,0.976527025,0.941256204,0.864330649,0.830886168
1568,1568,1709,10.1,"A tree is a finite set of one or more nodes such that there is a specially designated node called the root. The remaining nodes are partitioned into n&gt;=0 disjoint sets T the n plus 1, where each element set is a tree.",5,5,5,0.008366585,0.991633415,0.989324053,0.752719879,0.782975521,0.986951263,0.850806808,0.999979824,0.97621041,0.984245846,0.957950912,0.985791753,0.964442242,0.937520623,0.922118462
1569,1569,1710,10.1,A finite set of nodes that starts with the root and terminates with leaves.,3,5,4,0.015536249,0.984463751,0.980175403,0.480138511,0.543745497,0.983542932,0.81183754,0.999915011,0.899788111,0.966548355,0.910714902,0.983430916,0.958533978,0.851967871,0.815475797
1570,1570,1711,10.1,"a set of data arranged with pointers. each element can have many pointers, but no two pointers point to the same element",1,4,2.5,0.034609258,0.965390742,0.955837822,0.277154267,0.36559713,0.987558513,0.857749822,0.999960979,0.95398992,0.944510213,0.851893351,0.954284787,0.885592467,0.776810527,0.721791149
1571,1571,1712,10.1,"A Tree is a data structure with one or more data nodes, each of which contains some data. Each node itself can have a number of attached child nodes, creating the branched structure Trees are named for.",4,5,4.5,0.00832206,0.99167794,0.989380868,0.570284128,0.622861463,0.99428718,0.934682272,0.999978173,0.974263654,0.941956477,0.845077227,0.966836137,0.917003652,0.849133968,0.811943299
1572,1572,1713,10.1,"a finite collection of nodes, where it starts with an element called the root, which has children, and its children have children until you get to the leaves which are the last elements and have to children",4,5,4.5,0.011078835,0.988921166,0.985863162,0.365428418,0.44307061,0.996688733,0.96214051,0.999987287,0.985009357,0.970991531,0.922574092,0.960589459,0.901370628,0.797194123,0.747199578
1573,1573,1714,10.1,"A nonlinear, two-dimensional data structure.",0,4,2,0.075030506,0.924969494,0.904259417,0.23737134,0.330681792,0.986761801,0.848640594,0.999885596,0.865104875,0.954302621,0.878030066,0.94947843,0.873564011,0.684600055,0.606849547
1574,1574,1715,10.1,a finite set of one or more nodes such that there is a root node and all other nodes are split into trees of lesser value than the root,3,5,4,0.010652721,0.989347279,0.986406893,0.607205689,0.655265533,0.983018075,0.805836567,0.999980913,0.977494147,0.965271756,0.907307558,0.981557097,0.953844532,0.887226939,0.859426703
1575,1575,1716,10.1,"A finite number of nodes such that there is one root node, each node has a certain number of children nodes, and each child is also a tree",5,5,5,0.012326181,0.987673819,0.984271521,0.601706624,0.650439299,0.995190101,0.945005847,0.999956478,0.948682763,0.97405393,0.930747878,0.984238955,0.960556188,0.871214211,0.839466621
1576,1576,1717,10.1,A type of data structure in which each element is attached to one or more elements directly beneath it.,3,5,4,0.014564335,0.985435665,0.981415586,0.299907088,0.385566059,0.979708615,0.767997741,0.999979445,0.975763254,0.978730809,0.94323084,0.986227004,0.965531507,0.751808941,0.690626334
1577,1577,1718,10.2,"Each level of a generation in the tree, some people do not count the root as a generation",4,4,4,0.024381816,0.975618184,0.968888264,0.196815491,0.295088102,0.99449747,0.937086636,0.999943281,0.933121878,0.94357221,0.849389746,0.958892062,0.897122698,0.708743811,0.636945065
1578,1578,1719,10.2,"The height of a tree is in terms of the levels of its nodes such that, if  the tree is empty its height is 0 otherwise its height is equal to the maximum level of its nodes.",4,5,4.5,0.024418533,0.975581467,0.968841413,0.32415545,0.406847543,0.990726813,0.893974694,0.999960648,0.953599835,0.930476847,0.814437182,0.962808333,0.906923613,0.707746565,0.635701986
1579,1579,1720,10.2,The height of a tree is the number of nodes on the longest path from the root to a leaf.,5,5,5,0.008114517,0.991885483,0.989645697,0.687649787,0.725866996,0.997294815,0.969070177,0.999987865,0.985690912,0.982065121,0.952130383,0.970385446,0.925886202,0.930827439,0.913775317
1580,1580,1721,10.2,The number of nodes on the longest path from the root of the tree to a leaf.,5,5,5,0.007454574,0.992545426,0.990487799,0.696962476,0.734040244,0.998994713,0.988506017,0.999989685,0.987837358,0.982065121,0.952130383,0.970385446,0.925886202,0.930827439,0.913775317
1581,1581,1722,10.2,Height = the number of times you must progress down the levels of a tree to reach a leaf of the greatest distance from the root.,5,5,5,0.012619793,0.987380207,0.983896865,0.515061557,0.574395579,0.994060374,0.932089081,0.999960104,0.952957919,0.959228317,0.89117714,0.970959943,0.927323946,0.826054335,0.783174223
1582,1582,1723,10.2,the height of a tree is the length from the root to the furthest leaf,5,5,5,0.013115168,0.986884832,0.983264756,0.611270487,0.658832989,0.995261417,0.945821246,0.999919452,0.905024523,0.961368769,0.896890176,0.841654962,0.603723488,0.893496633,0.867241961
1583,1583,1724,10.2,The height is the number of generations (levels) from the root.,4,5,4.5,0.020185411,0.979814589,0.97424297,0.404103935,0.477014034,0.994477461,0.936857863,0.999953862,0.945597813,0.958636858,0.889598489,0.976709241,0.94171222,0.773245633,0.71734746
1584,1584,1725,10.2,The height of a tree is the number of levels between the root and the leaf farthest away from it.,5,5,5,0.014647841,0.985352159,0.981309031,0.55508697,0.609523734,0.997446791,0.97080779,0.999960489,0.953412454,0.974291395,0.931381691,0.971824344,0.929487208,0.874455392,0.843506797
1585,1585,1726,10.2,is the depth of its furthest leaf,4,5,4.5,0.028204083,0.971795917,0.964010967,0.408635765,0.480991378,0.994541636,0.937591609,0.999970837,0.965613384,0.940904362,0.842269048,0.740137654,0.34966485,0.715950787,0.645928659
1586,1586,1727,10.2,the number of nodes from root to leaf,3,4,3.5,0.017170548,0.982829452,0.978090001,0.378507793,0.454549675,0.994800459,0.940550865,0.999939573,0.928749351,0.978189537,0.941786142,0.94945746,0.873511531,0.748187602,0.686112285
1587,1587,1728,10.2,the distance from the deepest leaf to the root,5,5,5,0.020778596,0.979221404,0.973486052,0.522793949,0.581181883,0.996010686,0.954388037,0.999970928,0.965720268,0.962191494,0.899086094,0.968941712,0.922273093,0.818068087,0.773219257
1588,1588,1729,10.2,the number of generations or levels of a tree,4,5,4.5,0.026987374,0.973012626,0.965563515,0.150738865,0.254649123,0.992518809,0.914463543,0.999960196,0.953066657,0.944390261,0.85157319,0.95605629,0.890025855,0.584845424,0.482504048
1589,1589,1730,10.2,"The intensity of the children. Say you begin with one node, Thats one height. Then you add two children to that node and then two children to each of those nodes and two children to each of THOSE nodes. Youre current height would be 4.",2,4,3,0.037624717,0.962375283,0.95199003,0.205346718,0.302575502,0.990290419,0.888985164,0.999964192,0.957778366,0.919447862,0.784999945,0.950552839,0.876252842,0.704232216,0.631321301
1590,1590,1731,10.2,"the number of levels of a tree, like a tree can have at minimum a depth of 3 and at most a height of 8 for 8 nodes.",3,4,3.5,0.025484204,0.974515796,0.967481592,0.291169941,0.377897935,0.990250591,0.888529795,0.999887537,0.867393194,0.940946533,0.842381606,0.974034036,0.935017215,0.653439403,0.568007372
1591,1591,1732,10.2,The number of nodes on the longest path from the root to the leaf.,5,5,5,0.007931948,0.992068052,0.98987866,0.732083142,0.764863766,0.998936959,0.987845682,0.999990041,0.988256894,0.982065121,0.952130383,0.970385446,0.925886202,0.930827439,0.913775317
1592,1592,1733,10.2,The height of a tree is the number of nodes on the longes path from the root to a leaf.,5,5,5,0.009218693,0.990781307,0.988236744,0.638237596,0.682500571,0.997294815,0.969070177,0.999987865,0.985690912,0.982065121,0.952130383,0.970385446,0.925886202,0.867432714,0.834752933
1593,1593,1734,10.2,is equal to the number of levels.  levels between the root node and the terminal nodes.,4,5,4.5,0.022847533,0.977152467,0.970846043,0.313311756,0.397330615,0.996859439,0.964092288,0.999928137,0.915264838,0.966684135,0.91107731,0.972616379,0.931469366,0.731076598,0.664783188
1594,1594,1735,10.2,the number of generations or levels the tree has,4,5,4.5,0.029368162,0.970631838,0.962525576,0.135643929,0.241401108,0.993571275,0.926496952,0.999961342,0.954417527,0.944390261,0.85157319,0.95605629,0.890025855,0.584845424,0.482504048
1595,1595,1736,10.2,"The height of a tree is the depth of its subtrees, that is, how many layers deep it is.",4,5,4.5,0.024419069,0.975580931,0.968840728,0.329317272,0.411377797,0.993857677,0.92977154,0.999971049,0.965863886,0.970869864,0.922249353,0.974068566,0.93510363,0.63849324,0.549376777
1596,1596,1737,10.2,is the number of generations in the tree,4,5,4.5,0.025647223,0.974352777,0.967273577,0.149418384,0.253490207,0.994341154,0.93529939,0.999968923,0.963356232,0.917310262,0.779294521,0.940374499,0.850780385,0.529871047,0.413977742
1597,1597,1738,10.2,The number of nodes on the longest path from the root to a leaf.,5,5,5,0.007534206,0.992465794,0.990386187,0.724135995,0.757888982,0.998791394,0.986181365,0.999987685,0.985479388,0.982065121,0.952130383,0.970385446,0.925886202,0.930827439,0.913775317
1598,1598,1739,10.2,the number of distinct levels of separation,3,5,4,0.034543037,0.965456963,0.955922321,0.218498647,0.314118243,0.994066001,0.932153411,0.999955207,0.947183707,0.96008583,0.89346591,0.960246219,0.90051163,0.646745741,0.559663632
1599,1599,1740,10.2,the height of a tree is how many levels of nodes that it has,4,5,4.5,0.033892274,0.966107726,0.95675271,0.23148948,0.325519599,0.993527365,0.925994899,0.999951256,0.942525762,0.936347107,0.830105373,0.967434854,0.918502009,0.568519056,0.462153009
1600,1600,1741,10.2,The connections between elements are called branches. Trees are often called inverted trees because they are normally drawn with the root at the top.,0,3,1.5,0.030138433,0.969861567,0.961542694,0.260163844,0.350685548,0.994741323,0.939874729,0.99994882,0.939653413,0.959503945,0.891912813,0.949208381,0.872888182,0.771800578,0.71554618
1601,1601,1742,10.3,A leaf is a child of a parent node that has no children nodes of its own.,5,5,5,0.021800101,0.978199899,0.97218259,0.717536032,0.752096549,0.992794792,0.917619006,0.999953019,0.944603505,0.924854513,0.799430726,0.962171537,0.905329958,0.923507333,0.904650705
1602,1602,1743,10.3,A leaf is a node with no children.,5,5,5,0.021639228,0.978360772,0.972387867,0.771717727,0.799648912,0.992364258,0.912696483,0.999946653,0.937097267,1,1,1,1,1,0.999999851
1603,1603,1744,10.3,A node with no children.,5,5,5,0.017220378,0.982779622,0.978026417,0.895027041,0.907870873,0.996068453,0.955048521,0.999982786,0.97970307,1,1,1,1,1,0.999999851
1604,1604,1745,10.3,A tree node with no children.,5,5,5,0.021015227,0.978984773,0.973184106,0.800654054,0.825044771,0.993986983,0.931249963,0.999982935,0.979878371,0.973493168,0.92925116,0.975802591,0.939443225,0.952893734,0.941281253
1605,1605,1746,10.3,And end point of the tree... a node that does not have any children.,5,5,5,0.03520292,0.96479708,0.955080296,0.674063861,0.71394336,0.994044382,0.931906235,0.999960452,0.953367903,0.955016018,0.879934179,0.960811492,0.901926291,0.83826834,0.798399146
1606,1606,1747,10.3,a node with no children.,5,5,5,0.017220378,0.982779622,0.978026417,0.853474021,0.871402019,0.994214533,0.93385166,0.999975429,0.971028066,0.977759175,0.940637472,0.961487006,0.903616841,0.867257953,0.834535091
1607,1607,1748,10.3,A new item to the tree--a child,2,4,3,0.064876139,0.935123861,0.917216613,0.238131553,0.33134899,0.991803727,0.906287622,0.999952773,0.944314112,0.962994256,0.90122873,0.95674764,0.891756038,0.719059169,0.6498033
1608,1608,1749,10.3,"A leaf is a node with children, it is a terminating node.",0,4,2,0.037107408,0.962892592,0.952650128,0.663677454,0.704827768,0.992536628,0.914667273,0.999970596,0.965328827,0.970885088,0.922289987,0.976654159,0.941574371,0.923091829,0.904132774
1609,1609,1750,10.3,The node with degree 0.,3,5,4,0.060635805,0.939364195,0.922627373,0.537806332,0.594357446,0.995341869,0.946741094,0.999965858,0.959742169,0.954121315,0.877546146,0.921975823,0.804735601,0.704387724,0.631515145
1610,1610,1751,10.3,the node with degree 0,3,5,4,0.085527539,0.914472461,0.89086497,0.324948311,0.407543395,0.993286581,0.923241887,0.99994372,0.933639394,0.986178948,0.963110514,0.925346068,0.813170023,0.614349902,0.519281779
1611,1611,1752,10.3,a leaf is a node with no children,5,5,5,0.034334123,0.965665877,0.9561889,0.562754035,0.616252705,0.9920366,0.908950193,0.999914059,0.89866586,0.977759175,0.940637472,0.961487006,0.903616841,0.867257953,0.834535091
1612,1612,1753,10.3,the last child on any branch,4,5,4.5,0.098406494,0.901593506,0.87443114,0.150464788,0.25440858,0.993250151,0.922825364,0.999933222,0.921261605,0.995182128,0.987140717,0.908370865,0.770687642,0.676775932,0.597096672
1613,1613,1754,10.3,The last value in the tree. A value with no children attatched.,5,5,5,0.03163892,0.96836108,0.959628039,0.470660031,0.535426744,0.995390368,0.947295617,0.999950547,0.941689611,0.933776189,0.823243388,0.957840477,0.894490987,0.785775959,0.732966683
1614,1614,1755,10.3,a node with no children.,5,5,5,0.017220378,0.982779622,0.978026417,0.853474021,0.871402019,0.994214533,0.93385166,0.999975429,0.971028066,0.977759175,0.940637472,0.961487006,0.903616841,0.867257953,0.834535091
1615,1615,1756,10.3,A node with no children.,5,5,5,0.017220378,0.982779622,0.978026417,0.895027041,0.907870873,0.996068453,0.955048521,0.999982786,0.97970307,1,1,1,1,1,0.999999851
1616,1616,1757,10.3,A leaf is a node with no children,5,5,5,0.034334123,0.965665877,0.9561889,0.621994197,0.668244613,0.991443466,0.902168567,0.99993286,0.920833845,1,1,1,1,1,0.999999851
1617,1617,1758,10.3,a node with degree 0.  last node in the tree and furtherest away from the root.,3,5,4,0.056050181,0.943949819,0.92847873,0.415823907,0.487300024,0.993624712,0.927107919,0.999940122,0.929397074,0.935592802,0.828092073,0.955574699,0.888820619,0.730465233,0.664021113
1618,1618,1759,10.3,an endpoint on a tree that contains no pointers or pointers that are set to null,4,5,4.5,0.045881033,0.954118967,0.941454788,0.217432439,0.31318249,0.995377921,0.947153298,0.999937615,0.926441249,0.946913225,0.858307181,0.927373686,0.818244369,0.613809586,0.518608268
1619,1619,1760,10.3,A leaf is a node with no children.,5,5,5,0.021639228,0.978360772,0.972387867,0.771717727,0.799648912,0.992364258,0.912696483,0.999946653,0.937097267,1,1,1,1,1,0.999999851
1620,1620,1761,10.3,an element in a tree that has no children,5,5,5,0.029482722,0.970517278,0.962379395,0.472274512,0.536843688,0.995224295,0.945396812,0.999932607,0.920536441,0.994774381,0.986052408,0.957611495,0.893917933,0.760324717,0.701241364
1621,1621,1762,10.3,A node with no children.,5,5,5,0.017220378,0.982779622,0.978026417,0.895027041,0.907870873,0.996068453,0.955048521,0.999982786,0.97970307,1,1,1,1,1,0.999999851
1622,1622,1763,10.3,a leaf is a node that has no children nodes,5,5,5,0.020429909,0.979570091,0.973930985,0.686633766,0.72497529,0.996115009,0.95558082,0.999951099,0.942339952,0.989642431,0.972354826,0.950617656,0.876415054,0.796256721,0.746031094
1623,1623,1764,10.3,a leaf is a node with no children,5,5,5,0.034334123,0.965665877,0.9561889,0.562754035,0.616252705,0.9920366,0.908950193,0.999914059,0.89866586,0.977759175,0.940637472,0.961487006,0.903616841,0.867257953,0.834535091
1624,1624,1765,10.3,"The elements at the very bottom of an inverted tree (that is, those that have no elements below them) are called leaves.",5,5,5,0.036580801,0.963419199,0.95332209,0.341202021,0.421808403,0.989012415,0.874373059,0.999915505,0.900371353,0.956060818,0.882722833,0.960549985,0.901271839,0.651774883,0.565932526
1625,1625,1766,10.4,"A tree data structure in which each done has at most two children, typical called left and right nodes.  The right node is usually greater than the left node and the parent node.",4,5,4.5,0.027702272,0.972297728,0.964651289,0.495114505,0.556889123,0.985406277,0.833142165,0.999957197,0.94952999,0.925960149,0.802381757,0.972060084,0.930077175,0.873262942,0.842020391
1626,1626,1767,10.4,"A binary tree is a set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root. Each node can have no more than two children, a right and a left child.",5,5,5,0.023628056,0.976371944,0.969850079,0.48581928,0.548731203,0.988986725,0.874079341,0.999964621,0.958284085,0.937504961,0.833195777,0.970511786,0.926202382,0.888472736,0.860979606
1627,1627,1768,10.4,"A set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root.  Each node has at most two children, the left child and the right child.",5,5,5,0.024576664,0.975423336,0.968639634,0.460507751,0.526516633,0.987891129,0.8615528,0.999965134,0.958889276,0.936698011,0.831041963,0.968499507,0.921166425,0.893381894,0.867098937
1628,1628,1769,10.4,"A set of zero or more nodes, partitioned into a root node and two possibly empty sets that are binary trees. Thus, each node in a binary tree has at most two children, the left child and the right child.",5,5,5,0.021524251,0.97847575,0.972534581,0.467431903,0.53259359,0.976766384,0.734357647,0.999954391,0.946221853,0.941042638,0.842638118,0.974677132,0.936626636,0.900423586,0.875876503
1629,1629,1770,10.4,A tree in which each parent has a maximum of 2 children.,5,5,5,0.013707399,0.986292601,0.982509056,0.699704409,0.736446691,0.997321286,0.969372835,0.999949146,0.940037258,0.959510206,0.891929524,0.959071135,0.897570849,0.851901233,0.815392732
1630,1630,1771,10.4,a tree where each node has at most 2 children.,5,5,5,0.025559723,0.974440277,0.967385228,0.614605963,0.661760357,0.994132187,0.932910156,0.999937484,0.926286821,0.93192513,0.818302765,0.940799451,0.851843876,0.728376567,0.661417563
1631,1631,1772,10.4,a tree with up to two children or a right subtree and/or a left subtree,5,5,5,0.043322623,0.956677377,0.944719376,0.293088108,0.379581407,0.995734692,0.951232449,0.999958412,0.950962574,0.931904496,0.818247691,0.97328288,0.933137361,0.747263014,0.684959775
1632,1632,1773,10.4,"A binary tree is a tree in which all nodes have a maximum of two degrees, or can only have two children each.",5,5,5,0.014457762,0.985542238,0.981551576,0.686543167,0.724895776,0.993088192,0.920973602,0.999966911,0.960984861,0.962948434,0.901106427,0.981767953,0.954372224,0.914486289,0.893405852
1633,1633,1774,10.4,a binary tree is a tree data structure in which each node has at most two children.,5,5,5,0.021143079,0.978856921,0.973020964,0.622073352,0.668314083,0.993920336,0.930487947,0.999948849,0.93968699,0.963256115,0.901927652,0.954118955,0.885177454,0.815473258,0.769984768
1634,1634,1775,10.4,"a tree with only 2 joints, left and right",4,5,4.5,0.046963751,0.953036249,0.940073216,0.160286486,0.263028557,0.992751231,0.917120947,0.999948739,0.93955782,0.935750709,0.828513539,0.969346666,0.923286537,0.628851593,0.537358333
1635,1635,1776,10.4,A binary search tree is a tree that also has the condition that each node may have at maximum 2 children,4,5,4.5,0.02353102,0.97646898,0.969973899,0.532673955,0.589853034,0.990634666,0.892921133,0.999950722,0.941895897,0.967987091,0.914555003,0.972069055,0.930099626,0.88246721,0.853493637
1636,1636,1777,10.4,a tree where each parent can have at max two children.,5,5,5,0.027041733,0.972958267,0.965494151,0.500756264,0.561840591,0.996335344,0.958100023,0.99994336,0.933215536,0.959636778,0.892267354,0.934507038,0.836096395,0.801329434,0.752354299
1637,1637,1778,10.4,a list of numbers that are ordered compared to how they compare to the other numbers already added in the tree,1,3,2,0.033048213,0.966951788,0.957829751,0.205765128,0.302942718,0.995086738,0.943824049,0.999940932,0.930352302,0.953267029,0.875265988,0.973798402,0.934427514,0.689851344,0.613395349
1638,1638,1779,10.4,a tree where each node can have at most 2 children.,5,5,5,0.024760723,0.975239277,0.96840477,0.586305916,0.636922926,0.993854542,0.929735688,0.99994589,0.936198101,0.93192513,0.818302765,0.940799451,0.851843876,0.728376567,0.661417563
1639,1639,1780,10.4,"Starting at the root node, it branches off into one or two subsets that are binary subtrees of the root.  Each node has at most two children, the left child and the right child.",5,5,5,0.025122762,0.974877238,0.967942801,0.443392426,0.511495432,0.9827736,0.803041359,0.999969987,0.964611819,0.943524446,0.849262261,0.970403549,0.925931507,0.867596924,0.834957624
1640,1640,1781,10.4,"A binary tree is a set of nodes that is either empty or partitioned into a root node and one or two subsets that are binary subtrees of the root. Each node has at most two children, the left child and the right child.",5,5,5,0.023138762,0.976861239,0.970474429,0.49336791,0.55535623,0.988265419,0.865832255,0.999966477,0.960472738,0.936698011,0.831041963,0.968499507,0.921166425,0.893381894,0.867098937
1641,1641,1782,10.4,a tree that has a maximum of 2 children per node,5,5,5,0.01657337,0.983426631,0.978852014,0.772487283,0.80032431,0.99607557,0.955129888,0.999973443,0.968685911,0.969742095,0.919239248,0.976214258,0.940473469,0.909950137,0.887751477
1642,1642,1783,10.4,a tree with elements that can contain at most two pointers,5,5,5,0.037405312,0.962594688,0.952269995,0.217920825,0.31361112,0.996163917,0.956140014,0.999951325,0.942606695,0.942942039,0.84770777,0.944401585,0.860858627,0.716658771,0.646811171
1643,1643,1784,10.4,A binary tree can have only two children for each node.,5,5,5,0.019949794,0.980050206,0.974543622,0.607055545,0.65513376,0.993044116,0.920469652,0.999964764,0.958452283,0.958505547,0.889248009,0.969456847,0.923562277,0.900309682,0.875734519
1644,1644,1785,10.4,a tree where every parent has only two children,4,5,4.5,0.044601321,0.955398679,0.943087729,0.365731269,0.443336407,0.99535523,0.946893866,0.999958136,0.950637027,0.958892932,0.89028197,0.944087271,0.860072021,0.773042083,0.717093733
1645,1645,1786,10.4,A tree where every node has no more than two children,5,5,5,0.041928232,0.958071768,0.94649865,0.517606735,0.576629345,0.994821363,0.940789875,0.99997556,0.971182498,0.969392442,0.918305997,0.967156738,0.917805992,0.883218706,0.854430386
1646,1646,1787,10.4,"a binary tree is a special search tree where each node has either 2, 1, or 0 children",4,5,4.5,0.028680623,0.971319377,0.963402892,0.436696112,0.505618437,0.990425369,0.890528125,0.999915392,0.900238117,0.960103441,0.893512915,0.977385599,0.943404883,0.809623122,0.762692494
1647,1647,1788,10.4,a binary tree is a special type of tree where each node can only have at maximum 2 children,5,5,5,0.020277083,0.979722917,0.974125994,0.591922939,0.641852685,0.993033722,0.920350814,0.99993119,0.918865491,0.96623611,0.909881496,0.977341616,0.943294811,0.861555994,0.827427522
1648,1648,1789,10.4,A binary tree is a special type of inverted tree in which each element has only two branches below it.,4,5,4.5,0.020770669,0.979229331,0.973496168,0.493172735,0.555184935,0.993010686,0.920087439,0.999968639,0.963021807,0.956274219,0.883292417,0.981870024,0.954627668,0.809777856,0.762885372
1649,1649,1790,10.5,"A tree data structure where each node has a value, where the total order is defined on these values.  the left subtree contains only values less than the parent node, and vice versa for the right subtree.",5,5,5,0.015604377,0.984395623,0.980088471,0.379203498,0.455160258,0.990699771,0.893665511,0.999962792,0.956127136,0.95728409,0.885987843,0.969135906,0.922759086,0.803697109,0.755305639
1650,1650,1791,10.5,A binary search tree is a binary tree where the value in any node 'n' is greater than the value in every node in n's left subtree but less than every node in n's right subtree.,5,5,5,0.018665671,0.981334329,0.976182191,0.47664389,0.540678456,0.995967821,0.953897937,0.999981141,0.977763618,0.950789301,0.868652736,0.966493332,0.916145743,0.78142041,0.727537431
1651,1651,1792,10.5,"A binary tree where the value in any node n is greater than the value in every node in n's left subtree, but less than the value of every node in n's right subtree.",5,5,5,0.017817259,0.982182741,0.977264784,0.429952264,0.499699724,0.995006228,0.942903538,0.999982286,0.979113294,0.943142222,0.848242074,0.968872001,0.922098633,0.778554082,0.723964514
1652,1652,1793,10.5,"A binary tree where the search key in any node n is greater than the search key in any node in n's left subtree, but less than the search key in any node in n's right subtree.",5,5,5,0.025587857,0.974412143,0.967349329,0.455088735,0.521760654,0.994399703,0.935968805,0.999968896,0.963324778,0.953472322,0.875813932,0.965766921,0.914327817,0.784796655,0.731745967
1653,1653,1794,10.5,"A tree which is split based on values. This makes it very easy to search. One can compare the desired value to the root, and if the root is greater than, we search the left side of the tree, if it is less than, we search the right side... and do the same thing recursively. ",5,5,5,0.015611708,0.984388292,0.980079115,0.394077539,0.468214405,0.991263548,0.900111469,0.999979454,0.975774158,0.955219612,0.880477588,0.955039901,0.887482226,0.848568797,0.811238805
1654,1654,1795,10.5,a tree where each node has at most two nodes and the node on the left is less than the root and the node on the right is greater than the root.,4,5,4.5,0.01346606,0.98653394,0.98281701,0.511526406,0.571292966,0.99493633,0.942104358,0.999980921,0.977503346,0.964453501,0.905123571,0.963936935,0.909748068,0.769075036,0.712148755
1655,1655,1796,10.5,a special binary tree that has a rule that all the subtrees on the right are smaller than the node value and all the subtrees on the left are larger than the node value,5,3,4,0.009687901,0.9903121,0.987638025,0.558451533,0.61247663,0.995923998,0.953396892,0.999984811,0.982089855,0.956257104,0.883246736,0.968520213,0.921218244,0.816774309,0.771606545
1656,1656,1797,10.5,"Binary search trees are similar to binary trees, but have been implemented to organize data in a specific way for later searching.",3,4,3.5,0.022937059,0.977062941,0.970731806,0.237379611,0.330689051,0.984858681,0.826881197,0.999925844,0.91256155,0.927860775,0.807454679,0.957201316,0.892891413,0.739371777,0.67512324
1657,1657,1798,10.5,"it is a binary tree where each node has a value, a total order is defined on these values, the left subtree of a node contains only values less than the node's value, and the right subtree of a node contains only values greater than or equal to the node's value.",5,5,5,0.016923547,0.983076453,0.97840518,0.319799215,0.40302431,0.982884727,0.804311927,0.999969118,0.96358651,0.940132734,0.840209512,0.966428693,0.915983977,0.720420063,0.651499672
1658,1658,1799,10.5,A binary tree with the data organized in a specific arangment,2,3,2.5,0.033159852,0.966840148,0.957687296,0.252275258,0.34376216,0.991822913,0.906506988,0.999948729,0.939545946,0.893300751,0.715211229,0.896844294,0.741841084,0.61051476,0.514501223
1659,1659,1800,10.5,"A binary search tree is a tree that also has the condition that each node may have at maximum 2 children and where the input data is compared to the data in the tree starting with the root. If the value is smaller than the root it traverses left, if it is larger it traverses right until it becomes a leaf.",4,5,4.5,0.009622633,0.990377367,0.987721307,0.551800013,0.606638947,0.995066503,0.943592693,0.999989943,0.988141543,0.954291744,0.878001034,0.960982896,0.902355249,0.879622638,0.849947839
1660,1660,1801,10.5,a binary tree in which the data is in order from left to right.,4,4,4,0.020017087,0.979982913,0.974457754,0.425709337,0.495975935,0.991242529,0.899871151,0.999948103,0.938807446,0.910378667,0.760793544,0.944807286,0.86187394,0.747066855,0.68471526
1661,1661,1802,10.5,a tree that is set up so that it can be easily searched for numbers based on the location compared to the previous nodes.,3,4,3.5,0.016531885,0.983468115,0.97890495,0.269955039,0.359278754,0.994185997,0.933525391,0.999967744,0.961966134,0.919204521,0.784350449,0.9577348,0.894226518,0.735029995,0.669711151
1662,1662,1803,10.5,"a binary tree where the children are ordered such that the right side is greater than the current node, and the left is less than or equal the current node.",5,5,5,0.009318948,0.990681052,0.988108817,0.601495624,0.650254116,0.994959512,0.942369403,0.999975497,0.971107586,0.957075011,0.885429795,0.968617182,0.92146092,0.872174561,0.84066371
1663,1663,1804,10.5,"A binary tree where the value in any node n is greater than the value in every node n's left subtree, but less than every value in n's right subtree.",5,5,5,0.018783808,0.981216192,0.976031446,0.432608813,0.502031234,0.995458977,0.948080055,0.99998354,0.980591472,0.945972778,0.855797053,0.965128118,0.912729139,0.782763124,0.729211142
1664,1664,1805,10.5,A binary search tree is a finite set of nodes that is either empty or consits of a root and two disjoint binary trees call the left and right subtrees.,1,4,2.5,0.018833458,0.981166542,0.975968091,0.394392014,0.468490402,0.992701474,0.916552047,0.999961932,0.955113196,0.949636804,0.86557663,0.969709477,0.924194513,0.815014064,0.769412376
1665,1665,1806,10.5,it is similar to a binary tree.  The keys in a nonempty left subtree (right subtree) are smaller (larger) than the key in the root of subtree.  the values in all nodes in the left subtree of a node are less than             the node value  the values in all nodes in the right subtree of a node are greater    than the node values,5,5,5,0.017122328,0.982877672,0.978151531,0.509319902,0.569356436,0.983649405,0.813054905,0.999972857,0.967995794,0.936094833,0.829432033,0.964369807,0.91083138,0.794341445,0.743643676
1666,1666,1807,10.5,"a set of numbers arranged by links. each node can contain two pointers to other elements. each node to the left of the parent is smaller and each node to the right is larger. recursive implementation implies that if traversed in order, the output would be sorted",5,4,4.5,0.017413259,0.982586741,0.977780297,0.381453067,0.457134584,0.992509777,0.914360276,0.999963042,0.956422388,0.936040024,0.829285744,0.9650293,0.912481836,0.843948603,0.80547967
1667,1667,1808,10.5,"A binary search tree is a special binary tree arranged such that every left child node contains a value less than its parent, and every right child node contains a value greater its parent.",5,5,5,0.013115704,0.986884296,0.983264072,0.574317336,0.626401193,0.993982472,0.931198388,0.999977101,0.972999944,0.958794754,0.890019926,0.974631175,0.936511623,0.892046213,0.865433994
1668,1668,1809,10.5,"a binary tree with a special organization of data. where the left child of the element is less than it, and the right child is larger than it.",5,5,5,0.008967876,0.991032124,0.988556792,0.636916935,0.681341498,0.995188971,0.944992929,0.999986837,0.984479214,0.977814777,0.940785878,0.969500093,0.923670505,0.912003934,0.890311563
1669,1669,1810,10.5,A tree in which the smaller values are located on the left of a parent node and the larger values are located on the right of the parent node.,5,5,5,0.016963184,0.983036816,0.978354603,0.520282745,0.578977935,0.994177949,0.933433379,0.999954558,0.946418225,0.962593986,0.900160378,0.969495033,0.923657842,0.891414642,0.864646732
1670,1670,1811,10.5,"a binary search tree is a special tree in which each node has at most two children, labeled left child and right child",1,4,2.5,0.014594436,0.985405564,0.981377178,0.566244185,0.619315822,0.992164678,0.910414573,0.999962657,0.955968666,0.974911742,0.933037447,0.978067262,0.945110822,0.908024371,0.885350983
1671,1671,1812,10.5,"it is a binary tree where each node has a unique key, the left child of a node has only values less than that node, and the right child of each node has higher values than that node.",5,5,5,0.01055038,0.98944962,0.986537482,0.573275089,0.625486469,0.989782561,0.883178554,0.999906707,0.889997212,0.968345361,0.915511254,0.971861176,0.929579385,0.84650898,0.808671215
1672,1672,1813,10.5,"Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays.",2,3,2.5,0.042518377,0.957481623,0.945745611,0.084531963,0.196542881,0.984635437,0.824328737,0.999927515,0.914532034,0.930400891,0.81423445,0.951717872,0.87916847,0.621745944,0.528501046
1673,1673,1814,10.6,"For every node in the binary tree we first visit its left sub-tree (if its there) and then visit the parent node itself, and then the right sub-tree (if its there).",5,5,5,0.028651178,0.971348822,0.963440464,0.449874371,0.517184287,0.988185238,0.864915508,0.999979961,0.97637185,0.927591161,0.806735057,0.966541936,0.91626738,0.826405346,0.783611764
1674,1674,1815,10.6,The inorder traversal of a binary tree visits the node of a binary tree in order according to their data values.,2,3,2.5,0.037991703,0.962008297,0.951521748,0.151777431,0.255560616,0.988916151,0.87327243,0.999947634,0.938254936,0.92699733,0.805150075,0.945350371,0.863233072,0.56459558,0.457262343
1675,1675,1816,10.6,Traverses the binary tree in inorder.  It lets you visit the nodes in order according to their data values.,2,4,3,0.035523295,0.964476705,0.95467149,0.246698663,0.338867882,0.985924762,0.839070273,0.999967956,0.962216776,0.932021457,0.818559869,0.951045016,0.877484571,0.626757443,0.534747947
1676,1676,1817,10.6,Its used to visit nodes of a binary search tree in a search key order.,3,4,3.5,0.044803381,0.955196619,0.942829896,0.082755193,0.194983506,0.986631651,0.847152519,0.999918883,0.904353906,0.92827887,0.808570607,0.936961655,0.842239354,0.588811696,0.487448059
1677,1677,1818,10.6,(Left side of tree) (Root) (Right side of tree),5,5,5,0.094727516,0.905272484,0.879125597,0.241505832,0.334310413,0.985311576,0.832059388,0.999743734,0.697833728,0.935777101,0.828583981,0.924464342,0.810963403,0.769586563,0.712786381
1678,1678,1819,10.6,printing a tree in order from least to greatest. This done by going as far left down the tree as possible and printing the parent and then right tree. Then move up the tree.,5,5,5,0.022887111,0.977112889,0.970795541,0.468368053,0.533415199,0.984370512,0.821299706,0.999968235,0.962545978,0.946810386,0.858032695,0.925236053,0.812894698,0.646098793,0.558857202
1679,1679,1820,10.6,"The in order is to go from left,root,right",5,5,5,0.031212389,0.968787611,0.960172301,0.380412161,0.456221037,0.988375972,0.867096268,0.999894685,0.87582174,0.91647928,0.777076564,0.942651549,0.856478963,0.568234324,0.461798087
1680,1680,1821,10.6,"Inorder traversal of a binary tree will retrieve start at the furthest left hand leaf and checks it, itâ€™s parent, and itâ€™s right side sibling, then it goes up a level and repeats until it gets to the root.",4,5,4.5,0.022553921,0.977446079,0.971220699,0.368267149,0.445562012,0.989158919,0.876048125,0.999971625,0.966542213,0.912390533,0.766163374,0.963104056,0.907663693,0.769024432,0.712085676
1681,1681,1822,10.6,traverse the left subtree. visit the root. traverse the right subtree.,5,5,5,0.020373225,0.979626775,0.974003315,0.735080421,0.767494316,0.987559552,0.85776171,0.999944135,0.934128905,0.987305502,0.966117377,0.982220143,0.955503881,0.963330686,0.954291055
1682,1682,1823,10.6,postorder,0,3,1.5,0.466676951,0.53332305,0.404509901,0.088748075,0.200243136,0.958659519,0.527332173,0.999621982,0.554274237,0.865271263,0.6403983,0.953617503,0.883922513,0.505136013,0.383145187
1683,1683,1824,10.6,in order starts with the root then does right child then left child recursively,0,3,1.5,0.040690124,0.959309876,0.948078503,0.464344472,0.529883917,0.982039316,0.794645889,0.99996007,0.952917731,0.94467077,0.85232189,0.952419808,0.880925145,0.786307514,0.733629272
1684,1684,1825,10.6,Left Child -&gt; Parent -&gt; Right Child,5,5,5,0.124131024,0.875868976,0.841606071,0.216175899,0.312079692,0.988576276,0.869386451,0.99972938,0.68090886,0.886303519,0.696535061,0.96066511,0.901559953,0.631368577,0.540495789
1685,1685,1826,10.6,it goes from lowest to highest inside of the tree,1,3,2,0.048563182,0.951436818,0.938032306,0.055413343,0.170987032,0.987656749,0.858873005,0.999968425,0.962769169,0.925196185,0.800342676,0.949928664,0.874690773,0.534762084,0.420074487
1686,1686,1827,10.6,"starting by displaying the node furthest to the right, then  the node, then the node on the right, in recursive order.",3,5,4,0.016192496,0.983807504,0.979338018,0.483276993,0.546499974,0.996403121,0.958874963,0.999980628,0.977157755,0.918349573,0.782068525,0.967114447,0.917700154,0.769155562,0.712249132
1687,1687,1828,10.6,It travels left to right,3,4,3.5,0.057034016,0.942965984,0.927223336,0.204962239,0.302238065,0.985675324,0.836218313,0.999933693,0.921817107,0.94879615,0.863332857,0.947964605,0.869775491,0.666219175,0.583937531
1688,1688,1829,10.6,void inorder(ptNode ptr) { if (ptr) { inorder (ptr-&gt;left); cout&lt;&lt;ptr-&gt;data; inorder(ptr-&gt;right); } },5,5,5,0.132549286,0.867450714,0.830864183,0.171363086,0.272749893,0.981886232,0.792895598,0.999895945,0.87730785,0.931052567,0.815973825,0.953617503,0.883922513,0.529749155,0.413825802
1689,1689,1830,10.6,"the root is in the middle.  The left subtree is traversed first, then the root, and finally the right subtree.",5,5,5,0.009761512,0.990238488,0.987544095,0.795258105,0.820309037,0.988183469,0.864895278,0.999975447,0.971048897,0.956159942,0.882987403,0.969781517,0.924374801,0.905973315,0.882794315
1690,1690,1831,10.6,"a traversal that visits the left branch first, then the parent node, then the right branch, recursively.",5,5,5,0.014118135,0.985881865,0.981984948,0.559803426,0.613663114,0.993205796,0.92231823,0.99998117,0.977797427,0.969261363,0.917956136,0.952538283,0.881221642,0.794412017,0.743731645
1691,1691,1832,10.6,"Inorder traversal visits the left branch of a node (all the way to it's deepest left-most leaf) before visiting the node itself. After visiting the entire left branch and the node, it visits the node's right branch following the same pattern of left child, node, right child.",5,5,5,0.021379828,0.978620172,0.972718867,0.2975173,0.38346867,0.989708672,0.882333744,0.999980719,0.977265005,0.913785364,0.769886289,0.963195839,0.907893391,0.793513358,0.742611454
1692,1692,1833,10.6,left middle right,5,5,5,0.133121073,0.866878927,0.83013457,0.291264355,0.377980796,0.965305771,0.603322326,0.999781997,0.742950476,0.944155441,0.850946436,0.905318091,0.763047727,0.680296779,0.601485455
1693,1693,1834,10.6,"You traverse all the nodes to the left, then visit the root, then traverse all the nodes on the right.",5,5,5,0.01449573,0.98550427,0.981503128,0.640482128,0.684470476,0.9939288,0.93058472,0.999979489,0.975815751,0.967902153,0.914328297,0.964060822,0.910058109,0.83638829,0.796055638
1694,1694,1835,10.6,"you would go to the furthest down left most node, then to the root then to the right (if left and right exist) then you would return one node previous and do the same until you reached the root, then go to the furthest down left most node on the right side of the root and continue this process",5,5,5,0.020763576,0.979236424,0.973505218,0.467173547,0.532366844,0.986706452,0.848007751,0.999944627,0.934708429,0.899555846,0.731906575,0.969354386,0.923305857,0.802710593,0.754075932
1695,1695,1836,10.6,"it means that you traverse one subtree of a node, then look at the node itself before traversing the other subtree of the node",4,4,4,0.022736549,0.977263451,0.970987661,0.361465752,0.439592791,0.98959242,0.881004575,0.999966778,0.960827604,0.929146047,0.810885172,0.955919013,0.889682304,0.835927844,0.795481686
1696,1696,1837,10.6,"Level order traversal is a traversal method by which levels are visited successively starting with level 0 (the root node), and nodes are visited from left to right on each level, with Push and Pop methods. ",0,4,2,0.03249228,0.96750772,0.958539133,0.180069402,0.280390959,0.990321287,0.889338101,0.999958732,0.951340275,0.916939275,0.778304328,0.963961255,0.909808932,0.70513612,0.632448031
1697,1697,1838,10.7,This is on the runtime order of log(n) where n is the number of nodes in the binary tree.,5,5,5,0.015466154,0.984533846,0.980264846,0.624701321,0.67062051,0.992782483,0.917478273,0.999951494,0.942806443,0.974493239,0.931920429,0.976361307,0.940841476,0.745001972,0.682141354
1698,1698,1839,10.7,In a binary search tree of size 'n' it takes log(n) comparisons to find a specified element.,5,5,5,0.026843727,0.973156273,0.965746812,0.485417724,0.548378778,0.989940964,0.884989666,0.999939508,0.928673473,0.973650464,0.929670995,0.974051916,0.935061961,0.743087232,0.679754606
1699,1699,1840,10.7,n-1/2 is the algorithm to compare and find an element.,0,4,2,0.057723165,0.942276835,0.926343967,0.249893263,0.341671611,0.986502593,0.845676925,0.999938386,0.927350417,0.951196286,0.869739011,0.958888555,0.897113921,0.442822963,0.305471126
1700,1700,1841,10.7,At most its equivalent to the height of the tree.,5,5,5,0.027059913,0.972940087,0.965470954,0.508151293,0.568330811,0.987225027,0.853936896,0.999959757,0.952549364,0.960075044,0.893437121,0.952154999,0.88026243,0.694536448,0.619235395
1701,1701,1842,10.7,Log(n),5,5,5,0.117097914,0.882902086,0.850580474,0.391663462,0.466095699,0.981725154,0.791053914,0.999812433,0.778836818,0.926133428,0.802844252,0.969485984,0.923635196,0.393681526,0.244215659
1702,1702,1843,10.7,O(log n),5,5,5,0.153256238,0.846743763,0.804441655,0.101559386,0.211486935,0.983574952,0.812203637,0.999868965,0.845494788,0.946445588,0.857059021,0.924084863,0.810013714,0.505584061,0.383703685
1703,1703,1844,10.7,Depends on what half of the tree and the levels you have.,3,4,3.5,0.023054957,0.976945043,0.970581365,0.449853152,0.517165664,0.985143948,0.830142808,0.999927958,0.915053879,0.956858302,0.884851381,0.955364998,0.888295818,0.549464047,0.438400682
1704,1704,1845,10.7,O(log n) in balanced trees,5,5,5,0.05079788,0.94920212,0.935180783,0.457603514,0.523967741,0.983860463,0.81546804,0.999919681,0.905295279,0.961897798,0.898302196,0.956171299,0.890313678,0.613932729,0.518761767
1705,1705,1846,10.7,n-1,2,3,2.5,0.658367217,0.341632783,0.159908886,-0.058362663,0.071131944,0.95848009,0.52528066,0.999535393,0.452176469,0.909240949,0.757756884,0.982545872,0.956319055,0.364911556,0.208353502
1706,1706,1847,10.7,log(n),5,5,5,0.181707323,0.818292677,0.768137442,0.097049795,0.20752911,0.974396625,0.707262918,0.999813799,0.780448287,0.926133428,0.802844252,0.969485984,0.923635196,0.393681526,0.244215659
1707,1707,1848,10.7,O(nlog(n)),0,5,2.5,0.114221752,0.885778248,0.854250521,0.298514843,0.38434416,0.981970435,0.793858338,0.999803231,0.767987404,0.855275123,0.613717808,0.954996324,0.88737317,0.408017397,0.262085517
1708,1708,1849,10.7,nLog(n),0,4,2,0.131891251,0.868108749,0.83170385,0.271643668,0.360760774,0.981725154,0.791053914,0.999767776,0.726181715,0.926133428,0.802844252,0.969485984,0.923635196,0.488000423,0.361785442
1709,1709,1850,10.7,logn,5,5,5,0.344531655,0.655468345,0.560369996,0.177625939,0.278246463,0.95848009,0.52528066,0.999535393,0.452176469,0.926133428,0.802844252,0.969485984,0.923635196,0.393681526,0.244215659
1710,1710,1851,10.7,"at the minimum log(n)/log(2), at the maximum N searches, where N is the number of nodes.",4,5,4.5,0.028198421,0.971801579,0.964018192,0.463482857,0.529127724,0.990596079,0.892479943,0.999953314,0.944952162,0.976478562,0.937219414,0.975199383,0.937933628,0.696508527,0.621693618
1711,1711,1852,10.7,O(n),2,4,3,0.119796097,0.880203903,0.847137533,0.271219492,0.360388497,0.981725154,0.791053914,0.999882754,0.861753901,0.910753436,0.761793832,0.91695524,0.79217102,0.480024546,0.351843404
1712,1712,1853,10.7,It takes at most 3 comparisons to find and element in a binary search tree,0,3,1.5,0.041959345,0.958040655,0.946458948,0.182749659,0.282743277,0.984531644,0.823142012,0.999927445,0.914449891,0.958379951,0.888912783,0.920552838,0.801174419,0.591552675,0.490864727
1713,1713,1854,10.7,log (n)   where n equals the number of nodes.,5,5,5,0.032274842,0.967725158,0.958816588,0.494594663,0.556432885,0.984941327,0.827826133,0.999954845,0.946757081,0.975919296,0.935726688,0.974677846,0.936628422,0.759135842,0.699759416
1714,1714,1855,10.7,it takes as many comparisons as the number of levels of the binary search tree. it only compares one number at each level,5,5,5,0.023814321,0.976185679,0.969612401,0.3039051,0.389074899,0.987407086,0.856018483,0.9999626,0.955901306,0.965131325,0.906932737,0.961849668,0.904524444,0.809651554,0.762727934
1715,1715,1856,10.7,At most it takes one less comparisons than the tree's height. In big-O notation it takes O(log n) comparisons if the tree is balanced.,5,5,5,0.023026168,0.976973832,0.970618101,0.494624734,0.556459277,0.990999588,0.897093472,0.999952424,0.943902918,0.970844072,0.922180512,0.971678195,0.929121454,0.793248773,0.742281645
1716,1716,1857,10.7,O(log n),5,5,5,0.153256238,0.846743763,0.804441655,0.101559386,0.211486935,0.983574952,0.812203637,0.999868965,0.845494788,0.946445588,0.857059021,0.924084863,0.810013714,0.505584061,0.383703685
1717,1717,1858,10.7,log n comparisons,5,5,5,0.133488238,0.866511762,0.829666059,0.194862247,0.293373844,0.970171875,0.658959096,0.999888214,0.868191465,0.955612704,0.881526781,0.916968288,0.792203674,0.671427369,0.590429616
1718,1718,1859,10.7,(n^k)-1   where k is the height of the tree,0,3,1.5,0.032197535,0.967802465,0.958915234,0.543941796,0.599742213,0.988720429,0.871034634,0.999957115,0.949433644,0.953625603,0.876223051,0.948635693,0.871454965,0.687908888,0.610974052
1719,1719,1860,10.7,"it takes h comparisons, where h is the height of the tree",5,5,5,0.032074571,0.967925429,0.959072139,0.358440638,0.436937811,0.988263875,0.865814603,0.999954298,0.946111859,0.946367705,0.856851145,0.943188615,0.857823032,0.64975971,0.563420585
1720,1720,1861,10.7,2 way key comparison,0,2,1,0.18827492,0.81172508,0.759757043,-0.067635864,0.062993353,0.976749382,0.734163254,0.99991783,0.903112063,0.965907774,0.909005141,0.85270071,0.631366732,0.598632455,0.499689769
1721,1721,1862,11.1,"The name of the class file, the parameters it must take to perform its function.  Also a brief description of what the class does.",1.5,3.75,2.625,0.08230865,0.91769135,0.894972344,0.312934667,0.396999665,0.985514751,0.834382399,0.999857984,0.832547168,0.955236109,0.880521619,0.962764187,0.906813132,0.72514534,0.657389794
1722,1722,1863,11.1,"access specifiers and functions, oftentimes a constructor.",3,3,3,0.067249596,0.932750404,0.91418803,0.380342931,0.456160277,0.993007802,0.920054463,0.999775657,0.73547423,0.959378959,0.891579215,0.960420527,0.900947856,0.681498826,0.602983822
1723,1723,1864,11.1,"The elements typically included in a class definition are the function prototypes, usually declared public, and the data members used in the class, which are usually declared private.",5,5,5,0.066960633,0.933039367,0.914556753,0.435622782,0.504676433,0.987895962,0.861608063,0.999913599,0.898122911,0.94146463,0.843764448,0.945245953,0.862971754,0.803435624,0.754979693
1724,1724,1865,11.1,"Class is user defined.  It contains members, data and functions.  The keyword class is used and includes brackets ({})",2.5,5,3.75,0.049353004,0.950646997,0.937024477,0.542394221,0.598383989,0.992172993,0.910509645,0.999894859,0.876027266,0.960274459,0.893969376,0.963156286,0.907794405,0.832345188,0.791015856
1725,1725,1866,11.1,Member functions and data members.,5,5,5,0.009306312,0.990693688,0.988124941,0.947265506,0.953717767,1,1,0.999912934,0.897338979,0.960986605,0.89587015,0.952731333,0.881704771,0.971831381,0.964887287
1726,1726,1867,11.1,the functions and variables used when the object is defined for the class.,5,3,4,0.07392031,0.926079691,0.905676052,0.369098574,0.446291709,0.993825148,0.92939962,0.999896468,0.877923737,0.967251886,0.912592683,0.903219454,0.757795649,0.695821404,0.620837111
1727,1727,1868,11.1,"Data members, functions and function definitions, variables.",5,5,5,0.039098144,0.960901856,0.950109905,0.744115174,0.775423634,0.991737104,0.905525892,0.99988224,0.86114774,0.971931487,0.925082909,0.964703147,0.911665601,0.856663406,0.821328845
1728,1728,1869,11.1,return type and input parameters,1.5,2.5,2,0.092733741,0.907266259,0.881669698,0.186681971,0.286194456,0.987475411,0.856799681,0.999922833,0.909011178,0.979433964,0.945107616,0.974236849,0.935524777,0.592666507,0.492253134
1729,1729,1870,11.1,Constructor Data members Methods,5,4,4.5,0.106200576,0.893799424,0.864485719,0.544315875,0.600070522,0.997607354,0.972643594,0.999898404,0.88020666,0.974354195,0.931549309,0.970582248,0.926378721,0.830728173,0.789000226
1730,1730,1871,11.1,"Function members and member attributes, or in other words, the class variables and functions.",5,5,5,0.042074084,0.957925916,0.946312539,0.731483102,0.764337143,0.992192707,0.91073504,0.999923393,0.909671313,0.98055194,0.948091583,0.971825317,0.929489643,0.884430051,0.855940344
1731,1731,1872,11.1,"The elements that are included in a class definition is the access-modifier, data types, variables, and function signatures.",4,4,4,0.064828813,0.935171187,0.917277002,0.517000556,0.576097334,0.988283659,0.866040809,0.999876627,0.854529611,0.984055344,0.957442447,0.967555864,0.91880485,0.751989841,0.690851829
1732,1732,1873,11.1,The variables and function prototypes.,5,3,4,0.062747419,0.937252581,0.919932907,0.569228053,0.621934602,1,1,0.999846511,0.81901903,0.963147224,0.901637014,0.958680282,0.896592695,0.740331948,0.676320106
1733,1733,1874,11.1,public and private variables and initiations of functions included in the class.,4.5,2.5,3.5,0.055206001,0.944793999,0.929555923,0.398980558,0.472517521,0.994224257,0.933962841,0.999819613,0.787302847,0.951970785,0.87180621,0.957737744,0.894233886,0.687259853,0.610165021
1734,1734,1875,11.1,The return value and the accepted value.,1.5,1.25,1.375,0.08906579,0.91093421,0.886350084,0.156080157,0.259336887,0.99897538,0.988284967,0.999918473,0.903870167,0.970046408,0.920051484,0.937913028,0.844620274,0.589654982,0.488499227
1735,1735,1876,11.1,"A class definition typically includes the class name, the classes constructor(s), and any extra functions and class variables.",5,2.5,3.75,0.063172519,0.936827481,0.91939047,0.334066868,0.415546263,0.984925866,0.827649359,0.999908581,0.892206128,0.970460972,0.921157988,0.968830907,0.921995791,0.678022742,0.598650838
1736,1736,1877,11.1,"Parameters and their type, Class name, and return type, and the code to be executed in the class.",2,3.75,2.875,0.07761389,0.92238611,0.900962961,0.257242441,0.34812159,0.981210269,0.785166959,0.999936477,0.92509881,0.94019165,0.840366763,0.95262295,0.881433531,0.681103051,0.602490484
1737,1737,1878,11.1,"data members, class variables, and functions",5,5,5,0.04010576,0.95989424,0.948824164,0.688088656,0.726252168,0.992521451,0.91449375,0.999920556,0.906326724,0.97316453,0.928373999,0.953139916,0.882727297,0.888264596,0.860720157
1738,1738,1879,11.1,"Constructor, functions, and variables native to the class.",5,3,4,0.068660975,0.931339026,0.91238708,0.454173476,0.52095738,0.987601024,0.858235881,0.999862345,0.837688854,0.954978466,0.87983395,0.972521046,0.931230785,0.599333584,0.500563736
1739,1739,1880,11.1,functions and data members,5,5,5,0.045476437,0.954523563,0.941971062,0.827792823,0.848863012,0.997114233,0.967005487,0.99992056,0.906331402,0.981979112,0.951900819,0.991475334,0.978666051,0.953912854,0.9425516
1740,1740,1881,11.1,data members and function definitions,5,5,5,0.032889366,0.967110634,0.958032442,0.739955545,0.77177295,0.999664424,0.996163176,0.999914768,0.899501862,0.980900897,0.949022977,0.962960419,0.907304225,0.904127777,0.880493826
1741,1741,1882,11.1,member functions and data members,5,5,5,0.03643769,0.96356231,0.953504702,0.877470136,0.89246212,0.999664424,0.996163176,0.999907651,0.891110521,0.981718823,0.951206087,0.967719016,0.919213157,0.964253008,0.955440742
1742,1742,1883,11.1,"constructor, and function definitions.",3.5,2.5,3,0.077237487,0.922762513,0.90144326,0.513783276,0.5732737,0.990938142,0.896390926,0.999889907,0.870188048,0.95825717,0.888585071,0.962415258,0.905939898,0.588227093,0.486719344
1743,1743,1884,11.1,class name data of class definition of functions and methods,5,3.75,4.375,0.070311487,0.929688513,0.91028099,0.302371115,0.387728602,0.985558693,0.834884817,0.999914235,0.898873212,0.977143144,0.938993236,0.957809347,0.89441308,0.775422335,0.720060749
1744,1744,1885,11.1,"A class definition includes the definitions of the class' constructor(s) and any public or private functions. Of course, it also #includes the class header and any necessary C libraries",3,2.5,2.75,0.068454385,0.931545615,0.912650693,0.268547475,0.358043411,0.97993522,0.770588635,0.999891647,0.872239718,0.924147379,0.79754333,0.968074768,0.920103467,0.676751733,0.597066507
1745,1745,1886,11.1,"Class name, {}, semicoln at the end of the defination, private and bublic followed by "": """,2.5,2.5,2.5,0.091068983,0.908931017,0.883793966,0.116572425,0.224663073,0.978054869,0.749089581,0.999846271,0.818736587,0.970567699,0.921442851,0.960746986,0.901764857,0.605191529,0.507865743
1746,1746,1887,11.1,"a constructor, private and public variables, and function prototypes",5,2.5,3.75,0.068109214,0.931890786,0.913091138,0.374849021,0.451338568,0.985363056,0.832647988,0.999858618,0.833294917,0.967637634,0.913622275,0.959829204,0.899468003,0.674151957,0.593825851
1747,1747,1888,11.1,"Data variables and Functions, Data members",5,5,5,0.049742937,0.950257063,0.936526913,0.69291079,0.730484297,0.998025531,0.977424836,0.999872552,0.849724076,0.975439753,0.93444675,0.966493226,0.916145478,0.879312813,0.849561638
1748,1748,1889,11.1,class definitions include the name of the class and type of parameters,1.5,3.75,2.625,0.084222376,0.915777624,0.892530387,0.160397828,0.263126275,0.987993754,0.86272617,0.999858216,0.832820333,0.969659245,0.919018115,0.960511796,0.901176267,0.624672234,0.532148706
1749,1749,1890,11.1,"class variables, class function prototypes",5,3.75,4.375,0.093306065,0.906693935,0.8809394,0.315265864,0.399045632,0.98721899,0.853867873,0.999874649,0.852197564,0.95825717,0.888585071,0.962415258,0.905939898,0.663097918,0.580046842
1750,1750,1891,11.1,input  & return type elements,1.5,3,2.25,0.129021466,0.870978534,0.835365759,0.173692778,0.274794539,0.990937558,0.896384249,0.999860355,0.835343064,0.970774566,0.921994995,0.96082717,0.901965527,0.518625796,0.399960384
1751,1751,1892,11.2,Public and private specifiers.,5,5,5,0.013955534,0.986044467,0.982192431,0.840640366,0.86013861,0.991221798,0.899634123,0.999937016,0.925734552,0.994191497,0.984496644,0.941355417,0.853235245,0.910786152,0.888793581
1752,1752,1893,11.2,"Public, Private, Restricted",4.5,4.75,4.625,0.060945332,0.939054668,0.92223241,0.685988009,0.724408544,0.978815393,0.757785055,0.999900855,0.88309735,0.978312216,0.942113582,0.95831359,0.895675006,0.925339878,0.906934997
1753,1753,1894,11.2,The access specifiers are public and private.,5,5,5,0.033571899,0.966428101,0.957161515,0.739093065,0.771015999,0.989664339,0.881826858,0.999931276,0.918966388,0.939575122,0.838721201,0.903809787,0.759273025,0.826138139,0.783278686
1754,1754,1895,11.2,public private protected,5,4.75,4.875,0.103266358,0.896733642,0.868229845,0.630900085,0.676060832,0.985739091,0.836947398,0.999810618,0.776696832,0.964117295,0.90422621,0.95585552,0.889523406,0.924835265,0.906305991
1755,1755,1896,11.2,Public or Private.,5,5,5,0.023965061,0.976034939,0.969420053,0.932640553,0.940882231,0.991371324,0.901343733,0.999918441,0.903832762,0.997815045,0.994168182,0.947996215,0.869854599,1,0.999999851
1756,1756,1897,11.2,public: the function or variable can be used outside the class private: the function or variable can only be used with the class,5,5,5,0.103580773,0.896419227,0.867828645,0.226376325,0.321032058,0.977187152,0.739168507,0.999631423,0.565406,0.817328791,0.512436034,0.968887533,0.922137504,0.685002565,0.607351282
1757,1757,1898,11.2,Public and Private,5,5,5,0.044801474,0.955198526,0.94283233,0.82237637,0.844109282,0.991998977,0.908520027,0.999941209,0.930678691,0.997815045,0.994168182,0.947996215,0.869854599,1,0.999999851
1758,1758,1899,11.2,public private and protected,5,4.75,4.875,0.053645194,0.946354806,0.931547548,0.686886728,0.725197301,0.990722551,0.89392596,0.999881921,0.860771944,0.964117295,0.90422621,0.95585552,0.889523406,0.924835265,0.906305991
1759,1759,1900,11.2,Public Private,5,5,5,0.119905531,0.880094469,0.846997893,0.773127139,0.800885877,0.986667623,0.847563799,0.999827209,0.796260186,0.997815045,0.994168182,0.947996215,0.869854599,1,0.999999851
1760,1760,1901,11.2,"Private, public, protected",5,4.75,4.875,0.059580803,0.940419197,0.923973579,0.74443692,0.775706013,0.989014246,0.874393996,0.99984799,0.820762991,0.898432583,0.728908497,0.98370222,0.959212947,0.924835265,0.906305991
1761,1761,1902,11.2,The access-specifiers that can be used in a C++ class definition is private and public.,5,5,5,0.076639175,0.923360825,0.902206719,0.53619206,0.592940685,0.984378614,0.821392341,0.999899261,0.881217332,0.976978081,0.93855267,0.914145268,0.785138744,0.911615491,0.889827363
1762,1762,1903,11.2,public and private.,5,5,5,1.79E-07,1,1,0.93765986,0.945287408,0.989996414,0.885623656,0.999954224,0.946025309,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1763,1763,1904,11.2,"static, long, unsigned",0,1.25,0.625,0.121665716,0.878334284,0.844751858,0.065815829,0.180116735,0.985111499,0.829771811,0.999727754,0.678990971,0.956553425,0.88403764,0.949878242,0.874564586,0.449179649,0.313394822
1764,1764,1905,11.2,"Private, Public, Protected, or Friend.",5,4.75,4.875,0.049857736,0.950142264,0.936380428,0.722705185,0.756633237,0.976095237,0.726684055,0.999919809,0.905445195,0.951910764,0.871646009,0.973255917,0.933069883,0.887970746,0.860353868
1765,1765,1906,11.2,"A C++ class definition may include access-specifiers public, private, and static.",4,5,4.5,0.064240873,0.935759127,0.918027227,0.559927464,0.613771975,0.982902776,0.80451829,0.999871756,0.84878579,0.907146768,0.752167349,0.940545363,0.851207992,0.789683044,0.737836916
1766,1766,1907,11.2,"local, global, local-variable, function specific",1.5,2.5,2,0.129514694,0.870485306,0.834736389,0.212761581,0.309083128,0.977419754,0.74182797,0.999877279,0.855298481,0.942089871,0.845433266,0.965512216,0.913690388,0.460868031,0.327964548
1767,1767,1908,11.2,"public, private",5,5,5,0.051513791,0.948486209,0.934267265,0.763932347,0.792816102,0.984733355,0.825448277,0.999803541,0.768352687,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1768,1768,1909,11.2,"Public, protected, and private.",5,4.75,4.875,0.028919339,0.971080661,0.963098284,0.805903316,0.829651767,0.977568287,0.743526227,0.999891556,0.872132122,0.969132216,0.917611433,0.94436355,0.86076344,0.924835265,0.906305991
1769,1769,1910,11.2,"private, public",5,5,5,0.051513791,0.948486209,0.934267265,0.763932407,0.792816155,0.992271207,0.911632575,0.999733306,0.68553798,0.99945829,0.998554133,0.913739483,0.784123221,1,0.999999851
1770,1770,1911,11.2,public - can be accessed by any of the program  private - can only be accessed by the class functions themselves and no outside functions or calls,5,5,5,0.084553123,0.915446878,0.892108348,0.222416222,0.317556488,0.972147415,0.681546499,0.999827184,0.796230601,0.921575755,0.790679461,0.972511831,0.931207723,0.732246339,0.666241286
1771,1771,1912,11.2,"public , private, protected",5,5,5,0.059580803,0.940419197,0.923973579,0.669864953,0.710258203,0.981399872,0.787334788,0.999820003,0.787763703,0.964117295,0.90422621,0.95585552,0.889523406,0.924835265,0.906305991
1772,1772,1913,11.2,public and private,5,5,5,0.044801474,0.955198526,0.94283233,0.78288126,0.809446545,0.988644603,0.870167675,0.999921496,0.907434495,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1773,1773,1914,11.2,"public, private, protected",5,4.75,4.875,0.059580803,0.940419197,0.923973579,0.669864953,0.710258203,0.981399872,0.787334788,0.999820003,0.787763703,0.964117295,0.90422621,0.95585552,0.889523406,0.924835265,0.906305991
1774,1774,1915,11.2,"functions and data members can be given access-specifications of public, private, and friend. public access is given to any functions or members not given specific access rights.",5,4.75,4.875,0.062497497,0.937502503,0.920251814,0.42869553,0.498596756,0.974143192,0.704365288,0.999926284,0.913080399,0.814730644,0.505501373,0.949216087,0.872907467,0.709912479,0.638401826
1775,1775,1916,11.2,data member or data functions are access specifiers,0,1.25,0.625,0.179870963,0.820129037,0.770480677,0.02304237,0.142576768,0.985256827,0.831433422,0.99989288,0.873693592,0.948704494,0.86308822,0.938016817,0.844880017,0.475508302,0.346213845
1776,1776,1917,11.2,public or private,5,5,5,0.086602628,0.913397372,0.889493133,0.731060207,0.763965991,0.986839832,0.849532763,0.999893674,0.874629906,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1777,1777,1918,11.2,public and private,5,5,5,0.044801474,0.955198526,0.94283233,0.78288126,0.809446545,0.988644603,0.870167675,0.999921496,0.907434495,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1778,1778,1919,11.2,public and private,5,5,5,0.044801474,0.955198526,0.94283233,0.78288126,0.809446545,0.988644603,0.870167675,0.999921496,0.907434495,0.997674361,0.993792685,0.873669214,0.683842804,1,0.999999851
1779,1779,1920,11.2,"public - can be accessed from outside the class private - accessible only from inside the class, not inherited protected - accessible only from inside the class, inherited",5,4.75,4.875,0.089356244,0.910643756,0.885979459,0.261085153,0.351494131,0.964556627,0.594756964,0.9998564,0.830679377,0.837220838,0.565529487,0.978831172,0.947022594,0.752029777,0.690901608
1780,1780,1921,11.2,public private protected,5,5,5,0.103266358,0.896733642,0.868229845,0.630900085,0.676060832,0.985739091,0.836947398,0.999810618,0.776696832,0.964117295,0.90422621,0.95585552,0.889523406,0.924835265,0.906305991
1781,1781,1922,11.3,ie. GradeBook myGradeBook();  call upon the class and then give it a name like shown,0,2.5,1.25,0.119067013,0.880932987,0.848067861,0.246250019,0.338474131,0.979861671,0.769747719,0.999914825,0.899568907,0.933742699,0.823154001,0.966451677,0.916041497,0.680594683,0.601856796
1782,1782,1923,11.3,They are initialized as a named instance of the template formed by the class. This named instance can then be modified to be different from the class that it was created from.,3,3.75,3.375,0.097771347,0.902228653,0.875241602,0.248461083,0.340414663,0.989728673,0.882562423,0.999767123,0.725411289,0.80955178,0.491678574,0.959332116,0.898223983,0.680438042,0.601661541
1783,1783,1924,11.3,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
1784,1784,1925,11.3,Objects are initialized by a value given.  When an object is defined for a certain task.,2,2.5,2.25,0.076124132,0.923875868,0.902863926,0.338646799,0.419565822,0.992937095,0.919246035,0.999866087,0.842101943,0.906210903,0.749669451,0.96136011,0.90329927,0.653714716,0.568350554
1785,1785,1926,11.3,"They are initialized with a "" . "" (dot) between the constructor and the object being created.",0,4.5,2.25,0.083353996,0.916646004,0.893638459,0.387848139,0.462747195,0.987499782,0.857078318,0.999903987,0.886789887,0.979851527,0.946222125,0.93846442,0.846000195,0.621522784,0.528222874
1786,1786,1927,11.3,objectname classname();  to call a function from the class:  objectname.funciton();,0,2.5,1.25,0.116461396,0.883538604,0.851392685,0.164377496,0.266619016,0.983458002,0.810866486,0.99995193,0.943319512,0.949666437,0.865655722,0.954131651,0.885209227,0.579562604,0.475918942
1787,1787,1928,11.3,"If the object refers to a class, the constructor(s) will initialize the objects based on return type and parameters passed. Compiler will auto-create one if one is not provided.",5,5,5,0.088753939,0.911246061,0.886748013,0.440699309,0.509131828,0.972460458,0.685125688,0.999934202,0.922417089,0.888398516,0.702126775,0.960242542,0.900502428,0.739789128,0.675643475
1788,1788,1929,11.3,classname objectname(input parameters);,3,2.5,2.75,0.147553206,0.852446795,0.81171885,0.17768845,0.278301325,0.995180688,0.944898226,0.999932459,0.920361707,0.982447914,0.953152088,0.956701209,0.891639839,0.503366768,0.3809398
1789,1789,1930,11.3,When the class is called by the Constructor,2,5,3.5,0.095255017,0.904744983,0.878452493,0.408785254,0.481122576,0.984658223,0.824589259,0.999899558,0.881567619,0.980045124,0.946738851,0.955911565,0.889663665,0.731985688,0.665916381
1790,1790,1931,11.3,"Constructors; default when not provided by user, or programmer specified constructors.",5,5,5,0.068544328,0.931455672,0.912535923,0.647261143,0.690420053,0.986046911,0.840466867,0.99991083,0.894858216,0.949172624,0.864337696,0.961169097,0.902821238,0.735413373,0.670189036
1791,1791,1932,11.3,Objects are usually initialized at the beginning of the program and are initialized usually in the main function. They are initialized after the class's name.,1,3.75,2.375,0.102659404,0.897340596,0.869004332,0.229009628,0.323343167,0.989544466,0.880456289,0.99987644,0.854308535,0.917791559,0.780579141,0.956735901,0.891726659,0.662520349,0.579326894
1792,1792,1933,11.3,"&lt;variable type&gt; &lt;variable name&gt;; or, if you want to initialize a variable to a certain value, &lt;variable type&gt; &lt;variable name&gt; = &lt;value&gt;;",1,3.75,2.375,0.163224399,0.836775601,0.791722061,0.11310599,0.22162077,0.965631672,0.607048524,0.99977029,0.729145741,0.943909476,0.850289936,0.961561537,0.903803364,0.535866678,0.421451377
1793,1793,1934,11.3,"variables are set to a given value, or 0 if none is given.",1,1.25,1.125,0.093239963,0.906760037,0.881023747,0.212754488,0.309076903,0.987410531,0.856057868,0.99986712,0.843320051,0.924241197,0.797793737,0.942862506,0.857006907,0.595959067,0.496357355
1794,1794,1935,11.3,"When the object is initialized, its constructor is called (whether one is provided or c++ assigns a default constructor).",5,5,5,0.076667726,0.923332274,0.902170288,0.443088681,0.511228851,0.981423249,0.787602075,0.999941077,0.93052326,0.917275926,0.779202876,0.963613156,0.908937774,0.742078841,0.678497632
1795,1795,1936,11.3,"Objects are initialized essentially as copies of the corresponding classes, complete with their own separate variables.",2,3,2.5,0.100179374,0.899820626,0.872168905,0.230752945,0.324873182,0.991834283,0.906636988,0.999944276,0.934294678,0.954776282,0.879294305,0.962916675,0.907194751,0.586029828,0.483980423
1796,1796,1937,11.3,"If you had a class Gradebook, you would initialize it in your main function by use of a constructor in the Gradebook class.  If no constructor is specified or found, c++ will use a default one with no parameters.  Gradebook myGradebook;  In this bit of code, the class Gradebook has been initialized as object myGradebook.",5,5,5,0.089241982,0.910758019,0.88612526,0.436686277,0.505609806,0.971708194,0.676524649,0.999935661,0.924136944,0.881641096,0.684090684,0.964270783,0.910583561,0.731832206,0.665725063
1797,1797,1938,11.3,objects are initialized by stating the classname first then assigning a name to the object. Within the object's ( ) is a place where it can be initialized.,3,3.75,3.375,0.092074156,0.907925844,0.882511343,0.286148846,0.373491189,0.985263634,0.831511247,0.999919356,0.904911893,0.924283885,0.797907675,0.960767627,0.901816513,0.678341269,0.599047886
1798,1798,1939,11.3,They are initialized with a constructor.,5,5,5,0.064617813,0.935382187,0.917546244,0.569301844,0.621999364,0.993742735,0.928457345,0.999927733,0.91478916,0.951267562,0.869929252,0.88275946,0.706592181,0.607875824,0.511211754
1799,1799,1940,11.3,"The value is specified after declaration,  It can initialized anywhere between the declaration and the corresponding }.",1,3.75,2.375,0.106202185,0.893797815,0.864483665,0.22292763,0.318005324,0.990610167,0.892641021,0.999956517,0.948728035,0.971754531,0.9246106,0.960734465,0.901733522,0.589654028,0.488498038
1800,1800,1941,11.3,"with the default constructor for that object in its class.  if no constructor is specified, it uses the default system constructor.",4,5,4.5,0.07455641,0.92544359,0.904864373,0.555116773,0.60954989,0.986601468,0.846807421,0.999913509,0.898017064,0.898401396,0.728825256,0.957135347,0.892726319,0.680030882,0.601154011
1801,1801,1942,11.3,initialized using the same name as the class,1,4,2.5,0.138062358,0.861937642,0.823829381,0.185462594,0.285124274,0.99349813,0.925660639,0.999786472,0.748227036,0.948266756,0.861919863,0.909512738,0.77354531,0.73071754,0.664335617
1802,1802,1943,11.3,they are initialized to a value dependent on the compiler,1,1.25,1.125,0.107223511,0.892776489,0.863180431,0.056680985,0.172099574,0.989472373,0.879632016,0.999875252,0.85290787,0.99088457,0.975670193,0.911822598,0.779325998,0.478604198,0.35007292
1803,1803,1944,11.3,memory is allocated in accordance with their type and initialization input.,1,2.5,1.75,0.090737522,0.909262478,0.884216918,0.247975364,0.339988375,0.990743217,0.894162248,0.999940941,0.930363053,0.967918082,0.914370813,0.960548804,0.901268884,0.631919801,0.541182897
1804,1804,1945,11.3,Objects are assigned a space in memory when they are created. the name given to the object points to the memory address where the objects data resides.,1,1.25,1.125,0.109606087,0.890393913,0.860140211,0.223341048,0.318368158,0.988046875,0.863333527,0.999875483,0.853180151,0.875787269,0.668466355,0.929061286,0.82246778,0.573243618,0.46804224
1805,1805,1946,11.3,using constructor,5,5,5,0.138198197,0.861801803,0.823656048,0.691962779,0.729652278,0.996899284,0.96454786,0.99987571,0.853447535,0.951221217,0.869805554,0.950767538,0.87679015,0.852108479,0.815651066
1806,1806,1947,11.3,by giving them a value,2,1.25,1.625,0.11231184,0.88768816,0.856687611,0.13072899,0.23708753,0.990264083,0.888684049,0.9998142,0.780920296,0.977606876,0.940230973,0.932198847,0.830319884,0.473776668,0.344055339
1807,1807,1948,11.3,"By declaring the class first, the name of the variable, and then any variables that need to be put in the constructor.  Ex. Class myClass(x, y)",5,5,5,0.085033894,0.914966106,0.891494873,0.459220648,0.525387012,0.980543804,0.777546909,0.999918879,0.904348801,0.900706052,0.734976566,0.969596031,0.923910601,0.76440686,0.70632981
1808,1808,1949,11.3,"objects are initialized by giving the object a type, name, and initial value",1,3.75,2.375,0.096088707,0.903911293,0.877388687,0.083966948,0.196046998,0.989943243,0.88501572,0.99980266,0.767313708,0.92030058,0.787275918,0.956322741,0.890692679,0.599193275,0.500388839
1809,1809,1950,11.3,they are initialized to 0,1,1.25,1.125,0.137619197,0.862380803,0.824394864,-0.022495423,0.102610694,0.987775397,0.86022958,0.99982221,0.790365033,0.952717779,0.873799997,0.930493435,0.826051896,0.197762549,0
1810,1810,1951,11.3,"obj. are initialized by the variables that call them, when they are created within a class.   e.i. classname objectname etc. ",1,3.75,2.375,0.068589985,0.931410015,0.912477663,0.450479627,0.517715487,0.984749488,0.825632738,0.999929054,0.916346177,0.939376528,0.838191138,0.94909363,0.872601005,0.639925122,0.551161638
1811,1811,1952,11.4,"Name of the function, parameters it must receive in order to perform and a return type.",5,5,5,0.019817889,0.980182111,0.974711936,0.56069088,0.614441984,0.994979125,0.942593652,0.999974838,0.970331097,0.971355397,0.923545279,0.975663496,0.939095124,0.81353122,0.767563991
1812,1812,1953,11.4,a function signature is the elements that make it unique such as the variables it calls for and also I suppose this includes the program it is in.,3.5,4,3.75,0.025405109,0.974594891,0.96758252,0.37294814,0.449670266,0.990101275,0.886822581,0.999960433,0.95334609,0.973805483,0.930084754,0.977941576,0.944796279,0.812624693,0.766433993
1813,1813,1954,11.4,"A function signature is the return type of a function, its name, and the number and type of its parameters.",5,5,5,0.013575256,0.986424744,0.982677674,0.720500052,0.75469791,0.99031149,0.889226086,0.999952649,0.944168099,0.970942539,0.922443329,0.9698137,0.924455342,0.841576934,0.802523353
1814,1814,1955,11.4,function prototype that contains functions and data members.,1,5,3,0.06574595,0.93425405,0.916106716,0.452427805,0.519425298,0.98945082,0.879385579,0.9999711,0.965923302,0.968145655,0.914978223,0.962876128,0.907093278,0.691771328,0.615788636
1815,1815,1956,11.4,A function signature is a declaration of the function that includes the parameter types and the number of parameters.,5,5,5,0.011502683,0.988497317,0.985322322,0.70800513,0.743731788,0.990338453,0.889534366,0.999975665,0.971306405,0.979282641,0.944703723,0.975038101,0.937530002,0.870424688,0.838482469
1816,1816,1957,11.4,the declaration of the function.,2,3,2.5,0.019137621,0.980862379,0.975579973,0.513827622,0.57331262,0.994423339,0.936239052,0.99997441,0.969825996,0.885556413,0.694540976,0.967434706,0.918501639,0.43157649,0.291452246
1817,1817,1958,11.4,"Includes the name, accepted parameters, and return type.",5,5,5,0.016565859,0.983434141,0.978861598,0.618044019,0.664777753,0.995539932,0.949005653,0.999973494,0.968746554,0.985844673,0.962218308,0.972093164,0.930159961,0.851800144,0.815266723
1818,1818,1959,11.4,its return type and its input parameters,5,5,5,0.063131154,0.936868846,0.919443253,0.385563463,0.460742058,0.987604617,0.858276957,0.999939923,0.929162001,0.967952606,0.91446296,0.970576087,0.926363303,0.732470572,0.666520795
1819,1819,1960,11.4,Contains the function name and its paramaters.  The return type is not included,5,5,5,0.024278581,0.975721419,0.969019994,0.63503176,0.679686981,0.995106314,0.944047872,0.999970943,0.965737996,0.977745002,0.940599643,0.978690221,0.946669848,0.866416574,0.833486301
1820,1820,1961,11.4,"Return type, function name, and the parameter types",5,5,5,0.02472806,0.97527194,0.968446449,0.623106003,0.669220385,0.987556709,0.857729199,0.999931172,0.918843879,0.980771998,0.948678935,0.966780453,0.916864296,0.834944069,0.794255398
1821,1821,1962,11.4,The function signature tells what the function parameters and includes all the function calls,2.5,5,3.75,0.029190779,0.970809221,0.962751922,0.501946628,0.56288531,0.990468955,0.891026461,0.999964547,0.958196721,0.966024215,0.909315931,0.970790578,0.926900091,0.795673788,0.745304459
1822,1822,1963,11.4,"The function's name, as well as what it returns and what it accepts.",5,5,5,0.034089148,0.965910852,0.956501494,0.369927198,0.447018948,0.99259829,0.915372294,0.99997332,0.968541424,0.962811296,0.900740395,0.982960919,0.957357757,0.798427999,0.748737621
1823,1823,1964,11.4,the body of the function that holds all the actual code,1,2.5,1.75,0.027242541,0.972757459,0.965237915,0.320233852,0.403405767,0.991322651,0.90078723,0.999965045,0.95878357,0.967207914,0.912475318,0.965286965,0.913126672,0.640016139,0.551275091
1824,1824,1965,11.4,A function signature is the return type and accepted pass value type it takes,3,4,3.5,0.036198914,0.963801086,0.953809386,0.308528513,0.39313262,0.988529802,0.868855092,0.999971397,0.966273973,0.955887254,0.882259577,0.964956375,0.912299333,0.753228664,0.692396038
1825,1825,1966,11.4,A function signature specifies the name and input variables of a function.,5,5,5,0.022979975,0.977020025,0.970677045,0.528700173,0.586365459,0.992223805,0.911090607,0.999967495,0.961672878,0.976501706,0.937281187,0.971237448,0.928018434,0.824700594,0.781486767
1826,1826,1967,11.4,A function signature is the function's parameters and their type and the name of the function.  The return type is not a part of the function signature.,5,5,5,0.012928844,0.987071157,0.98350251,0.674182355,0.714047356,0.991919654,0.90761308,0.999973478,0.968727814,0.967638645,0.913624973,0.970582882,0.926380308,0.873739481,0.842614404
1827,1827,1968,11.4,the name of the function and what it accepts/ returns,5,5,5,0.031306326,0.968693674,0.960052436,0.417319059,0.488612239,0.99363758,0.927255045,0.999948697,0.939507576,0.925003461,0.799828281,0.963337633,0.908248246,0.616829991,0.522373244
1828,1828,1969,11.4,"the unique identifier of a function, which includes input variables along with the function name, but excludes the output type.",5,4,4.5,0.016924858,0.983075142,0.978403507,0.621712983,0.667997806,0.993021143,0.920206994,0.999971716,0.966649531,0.959069224,0.890752508,0.974761309,0.936837298,0.83163178,0.790126584
1829,1829,1970,11.4,"The order, number, and type of data items included inside the function parameters.",4.5,5,4.75,0.0130741,0.9869259,0.98331716,0.700816929,0.73742309,0.979160474,0.76173056,0.999974756,0.970234778,0.977267138,0.939324186,0.976904292,0.942200357,0.86064291,0.826289351
1830,1830,1971,11.4,"its the scope, type, and parameters of that function that give it it's properties and defines it against other functions.",5,5,5,0.023364544,0.976635456,0.970186326,0.571427703,0.623865117,0.989596888,0.881055659,0.999974957,0.970472002,0.972887867,0.927635564,0.970107158,0.925189755,0.782745779,0.729189521
1831,1831,1972,11.4,"is the name of the fuction, return type, and parameters that are being used",5,5,5,0.019162476,0.980837524,0.975548257,0.53291738,0.590066675,0.996594415,0.96106213,0.999977394,0.973345431,0.97433231,0.931490897,0.969318717,0.923216591,0.818089068,0.77324541
1832,1832,1973,11.4,"a function signature should include the name of the function, parameters, and a body.",2.5,5,3.75,0.012332022,0.987667978,0.984264067,0.667473793,0.708159611,0.993345136,0.923911382,0.99996658,0.960593607,0.973739204,0.92990785,0.950893391,0.877105112,0.86932373,0.837110111
1833,1833,1974,11.4,the name of the function and the arguments passed to that function,5,5,5,0.018667281,0.981332719,0.976180137,0.466897368,0.532124457,0.994373286,0.935666772,0.999979309,0.975602827,0.925003461,0.799828281,0.963337633,0.908248246,0.735348463,0.670108125
1834,1834,1975,11.4,"A function signature, used in a function's prototype, is the set of object types it take in as parameters, with or without names given for the objects.",5,5,5,0.017379403,0.982620597,0.977823498,0.538539648,0.595001038,0.976829633,0.735080798,0.999955444,0.947463837,0.943592583,0.849444124,0.974199722,0.935431863,0.834504366,0.793707301
1835,1835,1976,11.4,function name and parameter are called function signature.,5,5,5,0.048116028,0.951883972,0.938602885,0.553403556,0.608046292,0.995467758,0.94818045,0.999972619,0.967714191,0.950596147,0.868137192,0.944503006,0.861112445,0.785470843,0.732586351
1836,1836,1977,11.4,fuction name and parameters,5,5,5,0.073999107,0.926000893,0.905575505,0.468740761,0.533742304,0.989846193,0.883906093,0.999907577,0.891023231,0.929906964,0.812916119,0.961713172,0.904182848,0.808200955,0.760919744
1837,1837,1978,11.4,"The parameters needed, the return type, and name of the function.",5,5,5,0.008916736,0.991083264,0.988622048,0.768490434,0.79681649,0.986352262,0.843958117,0.999935882,0.924398174,0.974555238,0.932085909,0.950646346,0.876486854,0.878977656,0.84914386
1838,1838,1979,11.4,"the signature of a function includes the name of the function, the number and types of parameters, and the return type",5,5,5,0.005891383,0.994108617,0.992482466,0.753276885,0.783464375,0.997647749,0.973105458,0.999973618,0.968892351,0.984818919,0.959480489,0.969093856,0.922653851,0.895544171,0.869794246
1839,1839,1980,11.4,"It is what uniquely separates overloaded functions. It includes the return type, and the parameter list of the function.",4.5,5,4.75,0.015981734,0.984018266,0.979606955,0.678228736,0.717598646,0.989805357,0.883439191,0.999972417,0.967476197,0.975165829,0.933715625,0.965252981,0.913041623,0.845960259,0.807987228
1840,1840,1981,11.4,"function sig is, is what is the class recognizes as the main function, or rather its specification ",0,3.75,1.875,0.027814865,0.972185135,0.964507618,0.358551323,0.437034954,0.986579934,0.846561208,0.999967284,0.961424174,0.965075783,0.906784491,0.970104587,0.92518332,0.660783648,0.577162074
1841,1841,1982,11.5,A function that calls upon it self to solve a problem.  Each time it calls upon it self it splits up a problem into a simplier form until it reaches a 'base case' which is the most simplest form of the problem.,5,5,5,0.042712927,0.957287073,0.945497362,0.484973609,0.547989003,0.99116681,0.89900541,0.999913658,0.898192644,0.706610723,0.216920716,0.938878057,0.847035369,0.734461963,0.669003091
1842,1842,1983,11.5,A function that calls itself to perform an opperation such as a factorial recursive function.,5,5,5,0.027792871,0.972207129,0.964535683,0.739690065,0.771539954,0.997542101,0.971897526,0.99997055,0.965275257,0.988687862,0.969807005,0.964961595,0.912312396,0.812013566,0.765672215
1843,1843,1984,11.5,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
1844,1844,1985,11.5,A base case that calls upon itself until the problem becomes smaller and terminates.,2.5,5,3.75,0.03707993,0.96292007,0.95268519,0.555515051,0.609899437,0.995625282,0.949981514,0.99996843,0.962775294,0.886880398,0.698074797,0.948384125,0.870825388,0.742157757,0.678596003
1845,1845,1986,11.5,It's a function that calls itself. It runs multiple times until the base case is reached.,5,5,5,0.026317596,0.973682404,0.966418166,0.680060029,0.719205874,0.99662577,0.961420621,0.999900415,0.882577946,0.875930145,0.668847702,0.939743742,0.849201844,0.688347042,0.611520217
1846,1846,1987,11.5,a function that calls itself untill it reaches a base case.,5,5,5,0.020115554,0.979884446,0.974332108,0.718302012,0.752768808,0.997405586,0.970336678,0.999975342,0.970925605,0.906923738,0.751572064,0.933019372,0.832373341,0.661817849,0.578451218
1847,1847,1988,11.5,"A function that calls itself. Each time it does, it must get smaller, and eventually MUST converge to a base case, otherwise you can start an infinite loop.",5,5,5,0.034992039,0.965007961,0.955349385,0.486285627,0.54914049,0.987602247,0.858249863,0.999932928,0.920913954,0.832029851,0.551674331,0.944719212,0.861653525,0.682998061,0.60485264
1848,1848,1989,11.5,a function that calls itself until a base case is met,5,5,5,0.032756507,0.967243493,0.958201973,0.608454764,0.656361779,0.997121987,0.967094143,0.999912052,0.896299321,0.911007879,0.76247296,0.920421459,0.800845628,0.688146412,0.611270129
1849,1849,1990,11.5,A function that calls itself. With each function call the problem is diminished.,5,5,5,0.016945899,0.983054102,0.978376659,0.856289625,0.873873124,0.998326939,0.980870999,0.999956612,0.948840931,0.920769479,0.788527446,0.943017784,0.857395507,0.847882688,0.810383561
1850,1850,1991,11.5,A function that calls itself to perform a certain task,5,5,5,0.033592403,0.966407597,0.957135352,0.666281819,0.70711348,0.99795552,0.976624367,0.999956467,0.94866916,0.922625106,0.793480262,0.94577532,0.864296556,0.821946561,0.778053828
1851,1851,1992,11.5,A recursive function is a function that calls itself. Usually called the base case. If the base case is not correct it causes a infinite loop.,5,5,5,0.028326511,0.971673489,0.963854746,0.664590597,0.705629185,0.994837587,0.940975366,0.999955904,0.948005296,0.834640081,0.558641242,0.930774829,0.826756117,0.732625186,0.666713524
1852,1852,1993,11.5,"A function that calls itself, in order to solve a problem.",5,5,5,0.025549591,0.974450409,0.967398158,0.770730376,0.798782367,0.994834446,0.940939463,0.999945417,0.935640586,0.940250946,0.840525029,0.940586021,0.851309743,0.778714836,0.724164896
1853,1853,1994,11.5,"a function that calls itself over and over until it finds the simplest form of solution, or the base case.",5,5,5,0.035872638,0.964127362,0.954225721,0.571355999,0.623802186,0.992892631,0.918737644,0.999927177,0.914133548,0.88397059,0.690308289,0.93755826,0.843732426,0.66646719,0.584246685
1854,1854,1995,11.5,"A recursive function is a function that calls itself repeatedly until a base case is achieved. The fundamental idea is to break one large problem into a series of smaller, similar problems.",5,5,5,0.037285626,0.962714374,0.952422718,0.582355201,0.633455595,0.994103073,0.932577282,0.999968553,0.962920464,0.87582581,0.668569224,0.924562354,0.81120869,0.738921642,0.674562141
1855,1855,1996,11.5,"A recursive function typically simplifies a problem by calling itself, until arriving at a base case, at which it recursively returns a solution.",5,5,5,0.046777427,0.953222573,0.940310969,0.540361583,0.596600052,0.991336612,0.900946847,0.999956088,0.948222871,0.869494106,0.651669403,0.950924478,0.877182911,0.71276021,0.641951562
1856,1856,1997,11.5,"A recursive function is a function that breaks down a large problem into two or more smaller problems and calls itself to solve those smaller problems until a base case or terminating point is reached.  At the base case, a definite answer is called and the function no longer recurses, but unwinds itself back through function calls to determine the answer to the original large problem.",5,4,4.5,0.038631916,0.961368084,0.950704822,0.549375236,0.604510851,0.987867432,0.861281861,0.999949263,0.940175638,0.816580717,0.510439365,0.939627251,0.848910312,0.732417881,0.666455116
1857,1857,1998,11.5,a function that calls itself into a loop with a base case for a loop exit.,2.5,5,3.75,0.038813055,0.961186945,0.950473685,0.476220816,0.540307147,0.996049657,0.954833616,0.999915316,0.90014792,0.846865993,0.591273172,0.909930996,0.774592048,0.588598728,0.487182592
1858,1858,1999,11.5,a function that calls itself until the base cases are met.,5,5,5,0.022759259,0.977240741,0.970958683,0.714205325,0.749173366,0.997426659,0.97057762,0.999924527,0.911009253,0.911088415,0.762687917,0.896034588,0.739814703,0.684358001,0.606547823
1859,1859,2000,11.5,A recursive function only knows how to solve base cases  A recursive function calls itself directly or indirectly until a base case is reached.,5,5,5,0.044989765,0.955010235,0.942592066,0.527030766,0.58490031,0.993153983,0.921725822,0.999976013,0.971716324,0.842882867,0.580641892,0.960768618,0.901818993,0.745315015,0.682531568
1860,1860,2001,11.5,a function that calls on itself and uses a base case to stop the recursion,5,5,5,0.037329316,0.962670684,0.952366968,0.524891675,0.583022945,0.99547067,0.948213746,0.999923674,0.910002541,0.903388096,0.742135154,0.937723702,0.844146464,0.678121269,0.598773652
1861,1861,2002,11.5,"a function that calls itself, and which eaach calls get closer and close to the base case.",5,5,5,0.035773337,0.964226663,0.954352432,0.583500326,0.634460609,0.992653825,0.916007248,0.999956936,0.949222715,0.872377086,0.659364306,0.935200544,0.837831973,0.712287188,0.641361933
1862,1862,2003,11.5,A function that divides and conquers a problem.  There is a base case that will eventually be reached.  The function calls itself over and over until the base case is satisfied.,5,5,5,0.027431309,0.972568691,0.964997043,0.632832706,0.67775699,0.994514746,0.937284154,0.999928554,0.915757351,0.803135395,0.474552732,0.950531583,0.876199646,0.693540514,0.61799395
1863,1863,2004,11.5,a function that calls itself in the definition code,5,5,5,0.034481764,0.965518236,0.956000508,0.614169836,0.661377591,0.997244942,0.96849995,0.999950633,0.941791266,0.942275232,0.845928009,0.9073841,0.76821815,0.690924764,0.614733382
1864,1864,2005,11.5,A recursive function solves a problem by repeatedly calling itself. the initial problem is broken into successively smaller parts until a much simpler base case is reached. the solutions to each piece of the problem are then returned a step at a time.,5,5,5,0.04623878,0.95376122,0.940998295,0.468130529,0.533206736,0.993163255,0.921831841,0.999938619,0.927624494,0.744468374,0.317965794,0.946063678,0.865018204,0.650222063,0.563996914
1865,1865,2006,11.5,"It invoke by itself again ana again, unless it reach bas case",4,5,4.5,0.067339599,0.932660401,0.914073184,0.329373598,0.411427232,0.992379931,0.912875672,0.999832334,0.802303063,0.869065505,0.650525433,0.916119397,0.790079227,0.600429773,0.501930151
1866,1866,2007,11.5,"a function that solves a problem by dividing the problem into smaller problems, by calling its self again and again, until a base case is reached.",5,5,5,0.043020964,0.956979036,0.9451043,0.419928789,0.490902659,0.989166463,0.876134379,0.999928545,0.915746131,0.852423506,0.606106616,0.944468119,0.861025136,0.578615606,0.474738495
1867,1867,2008,11.5,"A function that calls itself over and over again till a base case is reached, then it returns back to the original function.",5,5,5,0.03518647,0.96481353,0.955101287,0.617760658,0.664529063,0.991784901,0.906072375,0.999924962,0.911522039,0.919635919,0.785501885,0.941907944,0.854618006,0.723993301,0.655953762
1868,1868,2009,11.5,"a recursive function is a function that during execution, calls itself over and over until a base case is reached",5,5,5,0.039766967,0.960233033,0.949256471,0.56058532,0.61434934,0.992491827,0.914155047,0.999950702,0.941871807,0.928030794,0.807908473,0.936819887,0.841884564,0.667790711,0.585896472
1869,1869,2010,11.5,A function that calls itself. Usually used to split a problem into several smaller problems of the same type.,5,5,5,0.034378946,0.965621054,0.956131706,0.637978733,0.682273381,0.997201453,0.96800271,0.999952478,0.943966513,0.867877944,0.647355738,0.94497172,0.862285455,0.735743582,0.670600647
1870,1870,2011,11.5,function that calls it self till the base case is met,5,5,5,0.043976963,0.956023037,0.943884424,0.474147141,0.538487193,0.99544168,0.947882289,0.999894019,0.875036952,0.890255897,0.707084272,0.918439552,0.79588568,0.645314515,0.557879589
1871,1871,2012,11.6,"Iteration, performers  a series of checks and loops.",5,5,5,0.073633671,0.926366329,0.906041809,0.463516384,0.529157149,0.987406398,0.856010609,0.99993735,0.926129046,0.930009146,0.813188851,0.961852885,0.904532495,0.704771817,0.631993921
1872,1872,2013,11.6,The alternative method is to use loops in the program instead of a function which calls itself.,5,2.5,3.75,0.091927111,0.908072889,0.882698975,0.292691946,0.379233716,0.992256028,0.911459022,0.999919824,0.905463213,0.853374491,0.60864487,0.964569384,0.911330844,0.718667507,0.649315088
1873,1873,2014,11.6,An alternative to solving a problem using recursive functions is to solve the problem using iteration.,5,5,5,0.091035008,0.908964992,0.883837318,0.36526987,0.442931461,0.992748335,0.917087838,0.999946821,0.937296396,0.920724667,0.788407839,0.92550737,0.8135737,0.774607718,0.719045318
1874,1874,2015,11.6,"Iteration, this would be more efficient and has repetition structure.",5,5,5,0.064922035,0.935077965,0.917158049,0.370986342,0.447948502,0.986503926,0.845692171,0.999917999,0.903311851,0.934478363,0.825117547,0.937337307,0.843179466,0.741740763,0.678076214
1875,1875,2016,11.6,One can use iteration or by using a simple while/for loop.,5,5,5,0.084301174,0.915698826,0.89242984,0.472859442,0.537357049,0.993608549,0.926923118,0.999885732,0.865265524,0.90378529,0.743195297,0.956428504,0.890957363,0.781270564,0.727350646
1876,1876,2017,11.6,iteration,5,5,5,0.124714553,0.875285447,0.840861475,0.599102855,0.648154111,0.980687516,0.779190042,0.999764904,0.722795941,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1877,1877,2018,11.6,"Iteration. A while loop or a for loop will be able to accomplish the same desired outcome... It may be faster than recursion, but could also be harder to understand.",5,5,5,0.065563142,0.934436858,0.916339982,0.310581833,0.394934709,0.988770657,0.871608918,0.999916838,0.901942366,0.874570097,0.665217626,0.965606418,0.91392614,0.778876662,0.724366615
1878,1878,2019,11.6,you can also solve the problem iteratively,5,5,5,0.149843216,0.850156784,0.808796746,-0.025902404,0.09962057,0.990641788,0.89300256,0.999898771,0.880639275,0.999998934,0.999997155,0.929200246,0.822815543,0.62031883,0.526722129
1879,1879,2020,11.6,iterative,5,5,5,0.343356431,0.65664357,0.561869609,0.18598026,0.285578602,0.980687516,0.779190042,0.999764904,0.722795941,0.999603693,0.998942225,0.959392308,0.898374621,0.463548928,0.331306323
1880,1880,2021,11.6,Using iteration loops.,5,5,5,0.058660209,0.941339791,0.925148277,0.709436357,0.744987899,0.998968485,0.988206133,0.999979022,0.975264889,0.969858961,0.919551173,0.959392309,0.898374623,0.821005106,0.776880291
1881,1881,2022,11.6,Another alternative way to solve a problem instead of using recursive functions is by using iteration.,5,5,5,0.090736628,0.909263372,0.884218059,0.422308058,0.492990815,0.992385633,0.912940867,0.999945458,0.935689002,0.913976843,0.770397361,0.90877031,0.771687299,0.783387482,0.729989413
1882,1882,2023,11.6,"A recursive function can often be solved using an iterative function, which runs faster, but is often more complicated.",5,5,5,0.094340265,0.905659735,0.879619738,0.188651994,0.287923439,0.989770195,0.88303717,0.999904341,0.887207055,0.841641995,0.577329906,0.847542256,0.618457113,0.693853557,0.618384163
1883,1883,2024,11.6,iteration,5,5,5,0.124714553,0.875285447,0.840861475,0.599102855,0.648154111,0.980687516,0.779190042,0.999764904,0.722795941,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1884,1884,2025,11.6,Any recursive function can be solved using an iterative method.,5,5,5,0.124804616,0.875195384,0.840746553,0.280875742,0.368863269,0.995719518,0.95105896,0.999926943,0.913857548,0.912647535,0.766849333,0.957217388,0.892931635,0.665655196,0.583234523
1885,1885,2026,11.6,"Many recursive solutions may also be solved with looping control statements, such as while, for, do-while, etc.",5,3,4,0.079217851,0.920782149,0.898916272,0.32468459,0.407311941,0.989241046,0.876987122,0.999914962,0.899731105,0.881959633,0.684940885,0.927512097,0.818590758,0.645313561,0.5578784
1886,1886,2027,11.6,"Using an iterative function, which repeats a specified operation or set of operations until a terminating point or base case is reached.  ",5,5,5,0.083455086,0.916544914,0.893509467,0.306208819,0.39109675,0.987205701,0.853715936,0.999897236,0.878829788,0.852831113,0.607194551,0.95809378,0.895124906,0.737195134,0.672410026
1887,1887,2028,11.6,iteratively,5,5,5,0.491513133,0.508486867,0.372818383,0.054302577,0.170012173,0.980687516,0.779190042,0.999764904,0.722795941,0.999603693,0.998942225,0.959392308,0.898374621,0.629217446,0.537814374
1888,1888,2029,11.6,using an Iterative calls,5,5,5,0.15619725,0.84380275,0.800688858,0.15275462,0.256418242,0.994188478,0.933553756,0.999967704,0.961918949,0.962059637,0.898734158,0.953793099,0.884361962,0.624450803,0.531872689
1889,1889,2030,11.6,Iteration.,5,5,5,0.034874976,0.965125024,0.955498761,0.735193312,0.767593395,0.993010467,0.920084935,0.999967044,0.961140997,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1890,1890,2031,11.6,iteration is the alternative way to solve a problem,5,5,5,0.094587028,0.905412972,0.879304863,0.249784336,0.341576011,0.991892274,0.907300034,0.999910074,0.893967579,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1891,1891,2032,11.6,using an iterative solution instead,5,5,5,0.183657408,0.816342592,0.76564909,0.242988557,0.335611721,0.995580344,0.949467711,0.999916379,0.901401625,0.925595061,0.801407308,0.944392689,0.860836364,0.695605814,0.620568375
1892,1892,2033,11.6,"Using an iterative solution.  For, while, or do while loop.",5,5,5,0.066075623,0.933924377,0.915686045,0.543336332,0.59921083,0.992356754,0.912610682,0.999867279,0.843506706,0.919221493,0.784395749,0.941307962,0.853116483,0.766350269,0.708752297
1893,1893,2034,11.6,the alternative way to solve a problem that could be solved using recursion is iteration.,5,5,5,0.087141097,0.912858903,0.888806036,0.340862095,0.421510069,0.992087365,0.909530611,0.999931715,0.919484703,0.962059637,0.898734158,0.953793099,0.884361962,0.765437782,0.707614869
1894,1894,2035,11.6,"Any problem solved recursively could be solved with an iterative function. Iterative replacements for recursive functions may be more difficult to program, but often lead to more efficient solutions to a problem. ",5,5,5,0.085843921,0.914156079,0.890461261,0.234434441,0.328104233,0.987878317,0.861406316,0.999916996,0.90212882,0.837930854,0.567424576,0.954194053,0.885365395,0.688949525,0.612271221
1895,1895,2036,11.6,by iteration,5,5,5,0.116901815,0.883098185,0.850830702,0.586472809,0.637069399,0.987251631,0.854241076,0.999957998,0.950475,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1896,1896,2037,11.6,"itteration, like a for loop, a while loop, or a do while loop",5,5,5,0.095371842,0.904628158,0.878303422,0.14176552,0.2467737,0.97898303,0.759701746,0.999797885,0.761683699,0.822112586,0.525204363,0.921012937,0.802325869,0.686469376,0.609179681
1897,1897,2038,11.6,Iteration by using loops,5,5,5,0.126323581,0.873676419,0.83880832,0.382687688,0.458218144,0.993873222,0.929949266,0.99996198,0.955169702,0.949855784,0.866161105,0.942461307,0.85600286,0.821005106,0.776880291
1898,1898,2039,11.6,iterative functions,5,5,5,0.350726366,0.649273634,0.552465408,0.134499371,0.240396591,0.997979979,0.976904023,0.999781355,0.742192663,0.999603693,0.998942225,0.959392308,0.898374621,0.463548928,0.331306323
1899,1899,2040,11.6,iteration,5,5,5,0.124714553,0.875285447,0.840861475,0.599102855,0.648154111,0.980687516,0.779190042,0.999764904,0.722795941,0.999603693,0.998942225,0.959392308,0.898374621,0.799601197,0.750200029
1900,1900,2041,11.6,"the alt, way is to use a functions parameter in a call ""to"" function. ",2.5,2.5,2.5,0.081312895,0.918687105,0.89624295,0.192335993,0.291156687,0.984732056,0.825433436,0.999850311,0.823500218,0.874283824,0.664453541,0.953746069,0.884244264,0.57772851,0.473632718
1901,1901,2042,11.7,The array that is declared static retains its modified elements so once it is called upon again the latest elements are modified again.  An array that is not declared static will keep its original elements.,5,4.5,4.75,0.017482877,0.982517123,0.977691463,0.570653141,0.623185325,0.995995331,0.954212475,0.999980595,0.977119152,0.921134984,0.789503008,0.968520363,0.921218619,0.745664358,0.682967028
1902,1902,2043,11.7,A static array only has a specific size and it cannot grow. Also static arrays cannot be accessed outside the program which created it.,2,3.75,2.875,0.021236122,0.978763878,0.97290224,0.533765078,0.590810654,0.995643578,0.950190695,0.999948095,0.938798552,0.959237841,0.89120256,0.963756012,0.909295288,0.751063049,0.689696569
1903,1903,2044,11.7,Arrays declared as static are not created and initialized when a function is called and destroyed when the function terminates.,5,5,5,0.013239682,0.986760318,0.983105874,0.71363169,0.748669917,0.996784215,0.963232214,0.999965917,0.959812141,0.942498242,0.846523241,0.960942787,0.902254871,0.83994031,0.800483279
1904,1904,2045,11.7,Static can be initialized and non-static cannot in C++.,1,4,2.5,0.054408848,0.945591152,0.930573108,0.318626314,0.401994918,0.991972461,0.908216854,0.999950555,0.941698253,0.990702,0.975182899,0.919530372,0.798615581,0.545593917,0.433576513
1905,1905,2046,11.7,An array declared static remains the same throughout the execution of the program.,0.5,4,2.25,0.031557381,0.968442619,0.959732084,0.41578278,0.487263929,0.996823512,0.963681512,0.999960593,0.953534853,0.984016581,0.957338985,0.961136964,0.902740821,0.635041773,0.545074477
1906,1906,2047,11.7,a static array will be called only once. once it has been declared the complier will ignore the static line if it comes to it again.,3.5,5,4.25,0.021610379,0.978389621,0.972424679,0.671877027,0.712024092,0.996338129,0.958131876,0.99996042,0.953331056,0.961172888,0.896367354,0.952888354,0.882097734,0.719673216,0.650568718
1907,1907,2048,11.7,"The static array will be available to the whole of the program, whereas an array that is not static is only available within the scope in which it is declared.   //pass-by-reference???",3.5,3.75,3.625,0.020286798,0.979713202,0.974113597,0.533278406,0.590383528,0.991867109,0.907012303,0.999964812,0.958509084,0.941037304,0.842623881,0.918258939,0.795433675,0.717311382,0.64762466
1908,1908,2049,11.7,a static array has a predetermined size and that size cannot be altered,2,3.75,2.875,0.028653026,0.971346974,0.963438106,0.310952097,0.39525967,0.996119291,0.955629777,0.999955205,0.947181635,0.942960262,0.847756409,0.919346346,0.798155035,0.494116724,0.369409494
1909,1909,2050,11.7,Arrays declared static can not be changed.  One not declared static can be altered.,0.5,3.75,2.125,0.031805694,0.968194306,0.959415232,0.500835836,0.561910427,0.995757804,0.951496705,0.999915469,0.900328263,0.969451189,0.918462797,0.950147567,0.875238602,0.69062835,0.614363898
1910,1910,2051,11.7,"an array that is declared as static will retain the values stored in it's elements between function calls, and will not reinitialize them to default values.",5,4,4.5,0.018737257,0.981262744,0.976090847,0.500262141,0.561406926,0.991786383,0.906089327,0.999987081,0.98476741,0.939359708,0.838146244,0.96263713,0.906495158,0.757856846,0.698165129
1911,1911,2052,11.7,An array that is declared static causes anything that is not initialized to be set to 0.,1,3.75,2.375,0.033247471,0.966752529,0.957575493,0.487474859,0.550184215,0.99697411,0.965403385,0.999977764,0.973781383,0.937217605,0.832428801,0.959015918,0.897432662,0.659451365,0.575501365
1912,1912,2053,11.7,A static array will have a null character at the end of the array.,2.5,2.5,2.5,0.027984083,0.972015917,0.964291692,0.374196529,0.450765911,0.996954153,0.965175206,0.999915754,0.900664535,0.970942872,0.922444217,0.882980949,0.707146483,0.62082237,0.527349799
1913,1913,2054,11.7,static arrays cannot be changed while normal arrays can be changed,0.5,3.75,2.125,0.036832869,0.963167131,0.953000445,0.404577732,0.47742986,0.995363157,0.946984497,0.999894805,0.875963385,0.971078738,0.922806855,0.959409,0.898416394,0.673403919,0.592893411
1914,1914,2055,11.7,An array they is declared as static can be accessed outside of the method it was declared without passing it as an argument to other functions in the same class.,3,3,3,0.019259989,0.980740011,0.975423828,0.454755783,0.52146844,0.994712356,0.93954354,0.999969658,0.964223236,0.935891201,0.828888523,0.962945523,0.907266946,0.706932127,0.634686778
1915,1915,2056,11.7,"A static array has class scope, allowing it to remain where other arrays might be recycled.",5,3.25,4.125,0.022506356,0.977493644,0.971281392,0.478408039,0.542226754,0.992860951,0.918375438,0.999971371,0.966243632,0.974978121,0.933214617,0.956589988,0.891361495,0.753336608,0.692530592
1916,1916,2057,11.7,An array that is static does not change or uninitialize if called later unless explicitly acted upon.  It does not terminate or change across objects.  An automatic local array will be cleared and uninitialized if called later outside of it's specific scope.,5,4.5,4.75,0.022555768,0.977444232,0.971218341,0.567778289,0.620662223,0.993138593,0.921549868,0.999966611,0.960631045,0.87901815,0.677089833,0.957788797,0.894361652,0.755739987,0.695526436
1917,1917,2058,11.7,"one declared as static is one that is already defined. The program knows the length and the array from the start, whereas non-static arrays are declared or assigned later.",2,3.75,2.875,0.01970458,0.98029542,0.97485652,0.611032307,0.658623951,0.994136556,0.932960104,0.999973756,0.96905586,0.959530347,0.891983282,0.957871623,0.894568933,0.807444334,0.759976605
1918,1918,2059,11.7,"a non static array must reinitialize itself every function call, while a static array will only initialize itself once, unless otherwise forced.",5,5,5,0.020313025,0.979686976,0.974080132,0.618184567,0.664901104,0.992529445,0.914585146,0.99997597,0.971666061,0.966133842,0.909608534,0.964256525,0.910547878,0.702766418,0.629494165
1919,1919,2060,11.7,A static array retains any modified values after a function call. Automatic arrays reset to their initial values when the function ends.,5,3.75,4.375,0.023622155,0.976377845,0.969857608,0.591628969,0.641594683,0.995771604,0.951654483,0.999966777,0.960826343,0.915303816,0.773939158,0.96819966,0.920416023,0.818170249,0.773346604
1920,1920,2061,11.7,"a static array is one that keeps its values and is not initialized every time a class function is called, it's data is not lost at function end.",5,4,4.5,0.01918602,0.98081398,0.975518215,0.555819809,0.610166907,0.992846511,0.918210331,0.999943822,0.93376017,0.877970144,0.674292622,0.952911331,0.882155237,0.817849517,0.772946806
1921,1921,2062,11.7,an array that is declared as static can only be used in the function that its being called in. Its a constant array. Static is another way of say const.,0.5,4,2.25,0.019402742,0.980597258,0.975241672,0.648723662,0.691703628,0.994441305,0.936444464,0.999960692,0.953651175,0.949742579,0.865858951,0.952335499,0.880714152,0.821192622,0.777114032
1922,1922,2063,11.7,Values in an array that is not delcared as static will remain constant.  When an array is declared const values within the array can be manipulated.,0.5,3.75,2.125,0.016640186,0.983359814,0.978766755,0.549164593,0.604325981,0.993825803,0.929407098,0.999973845,0.969159771,0.958781473,0.889984477,0.961387043,0.903366673,0.694107711,0.618700969
1923,1923,2064,11.7,the data of a static array cannot be changed,0.5,3.75,2.125,0.027132511,0.972867489,0.965378316,0.270232439,0.359522213,0.993352111,0.923991128,0.999901699,0.884092286,0.942390239,0.846234972,0.902056507,0.754885241,0.588133454,0.486602622
1924,1924,2065,11.7,"Standard arrays terminate when the functions that call them finish. A static array is not removed from memory when it's parent function terminates, leaving it available for other functions (or new instances of the original function).",5,2.5,3.75,0.016563118,0.983436883,0.978865096,0.576100349,0.627966048,0.994147648,0.933086927,0.999983357,0.980376003,0.915602066,0.774735211,0.956051248,0.890013237,0.808706582,0.761550014
1925,1925,2066,11.7,by defining static array it doese not lose scope in locala function. static array makes programm more scalable. non static array lose scope inside the local function.,4,4.5,4.25,0.029797256,0.970202744,0.961978043,0.468345404,0.53339532,0.994177463,0.933427816,0.999925902,0.912630459,0.890206569,0.706952612,0.954787779,0.886851262,0.808720767,0.761567697
1926,1926,2067,11.7,static arrays can be called from anywhere,3,1.25,2.125,0.034579396,0.965420604,0.955875927,0.426156938,0.49636877,0.99370843,0.928065113,0.999938453,0.927428988,0.979185994,0.944445765,0.935937009,0.839675061,0.717295706,0.647605119
1927,1927,2068,11.7,A static array cannot be changed. A regular array can be changed when it is passed to a function or manually.,0.5,3.75,2.125,0.02037245,0.97962755,0.974004303,0.529058933,0.586680324,0.997012527,0.965842619,0.999912885,0.897281907,0.956096827,0.882818944,0.963347408,0.908272709,0.711029649,0.639794394
1928,1928,2069,11.7,"a static array can be can be edited throughout the program, while a non-static array can only be edited within a given function",3,3.75,3.375,0.028816283,0.971183717,0.963229787,0.437430888,0.506263311,0.991151337,0.898828509,0.999949781,0.940785766,0.947924035,0.861005113,0.955738694,0.889231035,0.732313931,0.66632554
1929,1929,2070,11.7,"An array that is declared static is allocated when the program begins to run, and is not freed until the program exits, but has limited scope. A non-static array is allocated and freed every time that it comes in and out of scope.",5,3.75,4.375,0.021568775,0.978431225,0.972477766,0.525187314,0.583282411,0.985762113,0.837210628,0.999990962,0.989343611,0.923751922,0.796487824,0.955530146,0.88870912,0.728718877,0.661844256
1930,1930,2071,11.7,static has a predetermined size that cannot be passed while vis versa.,2,3.75,2.875,0.029547274,0.970452726,0.962297026,0.355402082,0.434271034,0.995463972,0.948137163,0.999960453,0.953369939,0.971649545,0.924330384,0.944694921,0.861592734,0.589050055,0.487745177
1931,1931,2072,11.8,the type char[] has a  null ('\n' ) element at the very end.,5,5,5,0.019476354,0.980523646,0.975147742,0.646970093,0.690164615,0.992644777,0.915903798,0.999968495,0.962852526,0.946591557,0.857448623,0.960335266,0.900734481,0.809279442,0.762264092
1932,1932,2073,11.8,a variable char is basically any non command key on the keyboard that you can press. A string is a collection of letters or numbers that is stored together to be used later. Comonly strings are used for words. Chars can be used for less but can have opperations performed on them in a useful way.,0,3.75,1.875,0.026899397,0.973100603,0.965675775,0.242328391,0.335032329,0.986384458,0.844326224,0.999973374,0.968604567,0.944732236,0.852485948,0.967858699,0.91956273,0.75634414,0.69627952
1933,1933,2074,11.8,The programmer must provide the null terminating character in a string of characters using type char[] and must also ensure that the array is large enough to contain the input string of characters and the null terminating character.,5,5,5,0.018563628,0.981436372,0.9763124,0.598984003,0.648049801,0.987069129,0.85215444,0.999977259,0.973185889,0.949946507,0.866403251,0.968539271,0.921265939,0.842251003,0.803363589
1934,1934,2075,11.8,String of characters are followed by a null statement.  type string is for example   string s;,5,5,5,0.038358331,0.961641669,0.951053923,0.44305706,0.5112011,0.990057222,0.886318898,0.999958341,0.950879179,0.965200115,0.907116343,0.959623533,0.898953288,0.740227282,0.676189639
1935,1935,2076,11.8,String contains a word where as char can contain phrases or a string of characters.,0,3.75,1.875,0.024308562,0.975691438,0.968981738,0.297540844,0.383489333,0.989871589,0.884196463,0.999973842,0.969156238,0.900681604,0.734911312,0.954593561,0.886365209,0.524901927,0.407783666
1936,1936,2077,11.8,a string is a variable with a single entinty of letters combined into one while in a char[] each letter is assigned a memory value and each has its own variable assigned i.e. char[0] char[1].,0,4,2,0.018340886,0.981659114,0.976596625,0.513960898,0.573429589,0.987769988,0.860167731,0.99997625,0.971995828,0.944003305,0.850540373,0.957931671,0.89471921,0.751999259,0.690863568
1937,1937,2078,11.8,"A string contains a null character at the end of the string, which makes it easily possible to get the string length. A char array can have a virtually unlimited length, therefore, its size must be declared/limited.",5,2.5,3.75,0.019275844,0.980724156,0.975403597,0.486881197,0.54966319,0.988952356,0.873686378,0.999979855,0.976246533,0.942414112,0.846298691,0.96753763,0.918759218,0.833737433,0.792751309
1938,1938,2079,11.8,an array of characters stores a null character at the end,5,5,5,0.030085623,0.969914377,0.96161008,0.415216923,0.486767307,0.991064268,0.897832999,0.999979993,0.976409504,0.964689651,0.905753874,0.969398118,0.923415301,0.80545336,0.757494829
1939,1939,2080,11.8,"When you read a string of characters, you also read in the white space.  When you read characters declared char you only read the characters, no white space.",1.5,4,2.75,0.035748959,0.964251041,0.954383539,0.352252424,0.431506748,0.981438197,0.787772975,0.999972721,0.96783507,0.93060458,0.814778112,0.932518703,0.83112036,0.728248179,0.661257525
1940,1940,2081,11.8,"Character arrays will terminate at any whitespace, including spaces. Strings terminate when they encounter the new line character.",1.5,5,3.25,0.032776654,0.967223346,0.958176266,0.364726514,0.442454587,0.990680675,0.893447176,0.999962993,0.956364262,0.951234088,0.869839907,0.973633067,0.934013744,0.717478871,0.647833437
1941,1941,2082,11.8,The difference is that a string that is declared a variable of type char[] is each char is included in the array versus the string of characters that is read into a variable.,0,3.75,1.875,0.023086011,0.976913989,0.970541739,0.494553089,0.556396398,0.985605703,0.835422309,0.999970951,0.965747706,0.903956163,0.74365137,0.964659382,0.911556074,0.727232575,0.659991561
1942,1942,2083,11.8,"An array of strings reads the string literals, meaning anything within ""quotes"". A char array reads a string as each individual character.",0,3.75,1.875,0.024044156,0.975955844,0.969319126,0.427427948,0.497484267,0.98620587,0.842284329,0.999951751,0.943109328,0.937024382,0.831913073,0.964416712,0.910948765,0.731070697,0.664775832
1943,1943,2084,11.8,character arrays can call on individual letters were a string array can only call words.,0,3.75,1.875,0.039062858,0.960937142,0.950154931,0.242187962,0.334909082,0.988008015,0.862889221,0.999971235,0.966082316,0.947529603,0.859952343,0.964153729,0.91029062,0.651746392,0.565897011
1944,1944,2085,11.8,The character array has an end of line character at the end of it.,4.5,5,4.75,0.021865427,0.978134573,0.972099231,0.450639695,0.517855971,0.990019993,0.885893239,0.999920432,0.90618023,0.936351309,0.830116588,0.966992659,0.917395366,0.81882906,0.77416782
1945,1945,2086,11.8,"Type char[] may contain a null value as the last element, whereas type string will not.",5,5,5,0.018987715,0.981012285,0.975771256,0.5142712,0.573701924,0.99771396,0.97386248,0.999967399,0.96155986,0.971974552,0.925197853,0.959663609,0.899053582,0.784571946,0.731465863
1946,1946,2087,11.8,The variable of type string has a terminating character \0 at the end of it.,2.5,5,3.75,0.013392627,0.986607373,0.982910712,0.530790687,0.588200191,0.990330995,0.889449092,0.99998267,0.979565715,0.953014321,0.874591491,0.978391515,0.945922303,0.879532218,0.849835129
1947,1947,2088,11.8,the one that is type string has an extra string member. The /0 at the end.,2.5,5,3.75,0.022944152,0.977055848,0.970722755,0.482348055,0.545684695,0.985320382,0.832160073,0.999972809,0.96793812,0.953977444,0.877162143,0.969951041,0.924799054,0.843939424,0.805468229
1948,1948,2089,11.8,"a string has variable size and function calls available, while an character array usually has a static size.",2.5,4,3.25,0.033366144,0.966633856,0.957424064,0.273901165,0.362742057,0.989913139,0.884671525,0.999931983,0.919800544,0.945827669,0.855409746,0.955346477,0.888249467,0.702638686,0.629334945
1949,1949,2090,11.8,a string char[] adds a null value to the end of the string.,5,5,5,0.014922082,0.985077918,0.980959093,0.748988152,0.779700385,0.996217347,0.956750907,0.999963421,0.956869349,0.946224103,0.85646786,0.913765874,0.784189267,0.819473922,0.77497165
1950,1950,2091,11.8,"char array needs an end character signature and is made up of characters each separate from each other, a string is an object in itself, with a value that the user enters.",5,5,5,0.021212161,0.978787839,0.972932814,0.298516303,0.384345442,0.990101339,0.886823317,0.99997254,0.967621034,0.958606555,0.889517607,0.969818908,0.924468376,0.813758075,0.767846769
1951,1951,2092,11.8,"the variable of type char[], each character is stored into a different memory address and can be accessed easly, where as in a string of character, its not easy to be able to access each character in the string.",0,4,2,0.0193187,0.9806813,0.975348912,0.440178752,0.508674963,0.988077845,0.863687622,0.999965722,0.959582669,0.957165283,0.885670738,0.965763741,0.914319858,0.734815359,0.669443604
1952,1952,2093,11.8,"When the string is passed into the array char, individual characters are stored and can be manipulated.  Although when a word is stored into a string variable, it is stored as one word and not as individual characters.",0,4,2,0.025275767,0.974724233,0.967747563,0.326367348,0.408788808,0.989293941,0.877591903,0.999971127,0.965954863,0.949996295,0.86653614,0.961215257,0.902936758,0.689479291,0.612931581
1953,1953,2094,11.8,"a string variable can change in size and is passed to functions by value, whereas a type char[] cannot change in size and is passed to functions by reference only",0,3.75,1.875,0.029231668,0.970768333,0.962699746,0.210027888,0.306683913,0.987929113,0.861987091,0.999974838,0.970331041,0.937855503,0.834131401,0.941998993,0.854845867,0.703755856,0.630727512
1954,1954,2095,11.8,"A string type string acts as a single object, with individual char entities accessible only through specific string class functions. A char array is less robust, but allows direct access to specific char entities.",1.5,3.75,2.625,0.034684956,0.965315044,0.95574123,0.277836502,0.366195891,0.987528546,0.857407194,0.999969185,0.963665611,0.934676429,0.8256462,0.946990788,0.867338403,0.705832064,0.633315534
1955,1955,2096,11.8,"In arrays strings are stored as a characters (char[]), each character of string will be stored in each memory location of the array, while string of characters is only one memory location.",0,3.75,1.875,0.024544418,0.975455582,0.968680781,0.474671602,0.538947485,0.986339886,0.843816615,0.999966942,0.961020978,0.947404069,0.859617283,0.961557382,0.903792965,0.680704296,0.60199343
1956,1956,2097,11.8,"an array of characters has one more element, its last element,the terminating element, or null, which doesnt exist in a variable of type string",5,5,5,0.028406143,0.971593857,0.963753134,0.258785248,0.349475629,0.988956115,0.873729354,0.999973995,0.969336572,0.958788514,0.89000327,0.962319242,0.905699607,0.771710753,0.715434213
1957,1957,2098,11.8,A string of characters is a specific variable type that has no extra data at the end. A string of type char[] is all the characters and a null ('\0'),5,5,5,0.014928818,0.985071182,0.980950499,0.652899265,0.695368331,0.987265676,0.854401664,0.999946146,0.936500185,0.963359689,0.9022041,0.965651734,0.914039548,0.838441253,0.798614684
1958,1958,2099,11.8,a string of characters will have a null character or value at the end of the string,5,5,5,0.016614079,0.983385921,0.978800068,0.482698351,0.545992131,0.991373466,0.901368221,0.999979081,0.975333926,0.934027594,0.823914408,0.951161655,0.877776473,0.846907675,0.809168195
1959,1959,2100,11.8,"when the characters are put in a char array, there is also a null terminating character added to the end, '\0'",5,5,5,0.020018697,0.979981303,0.974455701,0.517161787,0.576238837,0.992175942,0.910543356,0.999984339,0.981534143,0.977873496,0.940942603,0.966758301,0.916808858,0.910569012,0.888522913
1960,1960,2101,11.8,"string of characters that is read into a variable of type string includes, ",0,3,1.5,0.03435874,0.96564126,0.956157489,0.289153576,0.376128279,0.989471291,0.879619634,0.99997196,0.96693771,0.814715516,0.505460995,0.959623529,0.898953278,0.316118628,0.147532456
1961,1961,2102,11.9,"For example we have an array on n elements, the divide and conquer splits up the array into equal halves and repeats this process until each element is by itself",3,4.5,3.75,0.020183742,0.979816258,0.974245099,0.294099838,0.380469347,0.994045397,0.931917834,0.999982844,0.979771237,0.960179074,0.893714786,0.977311603,0.9432197,0.732433856,0.666475027
1962,1962,2103,11.9,Divide and coquer means dividing a problem into 2+ problems which are solved and then merged  back together for a final solution to the whole problem.,5,5,5,0.012106001,0.987893999,0.984552475,0.726695538,0.760135355,0.990032008,0.886030621,0.999992044,0.990618948,0.976905136,0.938357974,0.979287958,0.948165753,0.892387331,0.865859201
1963,1963,2104,11.9,The divide and conquer paradigm divides a problem into smaller and smaller portions that are easier to solve.,4,4.5,4.25,0.013713479,0.986286521,0.982501298,0.587076306,0.637599056,0.989129122,0.875707443,0.999979155,0.975420759,0.985120013,0.960284133,0.983905354,0.959721313,0.847833216,0.810321894
1964,1964,2105,11.9,"Divide elements,recur then conquer, which works in merge sort and quicksort.",3,4.5,3.75,0.023716331,0.97628367,0.969737438,0.360284537,0.438556102,0.994981361,0.942619217,0.99998907,0.987111674,0.958461408,0.889130199,0.979299382,0.948194343,0.745364904,0.682593755
1965,1965,2106,11.9,"To divide and conquer, you divide the program in half once or multiple times to the extent that the program as a whole is easier to work in groups to solve the problem.",4,4.5,4.25,0.016089082,0.983910918,0.979469976,0.472901464,0.537393929,0.987889572,0.861535,0.999985,0.982313035,0.938077439,0.834723766,0.980615333,0.951487661,0.817702413,0.772763439
1966,1966,2107,11.9,to divide one larger string/line of values and sepereate them into smallers lines to easily manipulate them and then replace them in the order in which they should be.,2,5,3.5,0.022229135,0.977770865,0.971635133,0.435850948,0.504876682,0.985564901,0.834955795,0.999974852,0.9703481,0.974615789,0.932247525,0.980985448,0.952413916,0.768779576,0.71178046
1967,1967,2108,11.9,"Split the problem into smaller, more manageable parts, and proceed to address the smaller problems.",4,4.5,4.25,0.013161361,0.986838639,0.983205812,0.539144874,0.595532212,0.995555143,0.949179575,0.999986514,0.984098492,0.976831379,0.93816111,0.983672478,0.959138515,0.830430746,0.788629479
1968,1968,2109,11.9,dived and conquer is the breaking up of a large complex program into small easy to solve components.,4,4.5,4.25,0.017559528,0.982440472,0.977593654,0.41373536,0.485467018,0.981280486,0.785969786,0.999973201,0.968401207,0.957354588,0.886176008,0.971974305,0.929862503,0.762802482,0.704329931
1969,1969,2110,11.9,Dividing a larger problem into the smallest incident of the problem and solving the smallest incident.,4,4.5,4.25,0.019574165,0.980425835,0.975022933,0.519658566,0.578430126,0.990702516,0.893696893,0.999941619,0.931161969,0.97836397,0.942251717,0.988169799,0.970393573,0.847192764,0.809523562
1970,1970,2111,11.9,"Break up very large data structures into smaller sub-units, that are easier to manipulate.",4,4.5,4.25,0.030752659,0.969247341,0.960758928,0.345297247,0.425402563,0.993176136,0.921979107,0.999983819,0.980920754,0.953475462,0.875822313,0.97363237,0.934012,0.709506154,0.637895337
1971,1971,2112,11.9,The divide-and-conquer technique is where it takes the sorting algorithm and breaks up the array into smaller elements of the array to tackle the problem and run the algorithm.,4,4.25,4.125,0.01508975,0.98491025,0.980745145,0.361831278,0.439913594,0.985935816,0.839196666,0.999980893,0.977470659,0.969792185,0.919372942,0.98282996,0.957030017,0.784132957,0.730918658
1972,1972,2113,11.9,"The divide-and-conquer paradigm divides the problem into two pieces and works on each piece separately, allowing for a faster approach to 2 separate smaller problems. ",4,4.5,4.25,0.015041709,0.984958291,0.980806447,0.485803038,0.548716948,0.993525537,0.925974007,0.99998582,0.98328048,0.971169585,0.923049332,0.976610968,0.941466281,0.816594481,0.771382388
1973,1973,2114,11.9,"Take a problem and divide it into a smaller problem and solve that smaller problem, or divide it into a smaller problem and solve it, thus solving the whole problem in the process.",4.5,4.5,4.5,0.009614766,0.990385234,0.987731347,0.736968041,0.769150979,0.99472144,0.9396474,0.999983069,0.980036073,0.883796128,0.689842636,0.977992537,0.944923815,0.917355001,0.89698174
1974,1974,2115,11.9,The idea is to split the problem into half and solve for the smaller split-problems.,4,4.5,4.25,0.013642132,0.986357868,0.982592338,0.635034561,0.67968944,0.985136213,0.83005437,0.999988669,0.986639272,0.967145429,0.91230854,0.980425117,0.951011623,0.865189075,0.831956208
1975,1975,2116,11.9,"The divide and conquer paradigm, splits a large problem into simpler problems, at which point it solves the simpler problems and merges the simple solutions together to answer the large problem.",5,5,5,0.008508503,0.991491497,0.989142962,0.701859474,0.738338076,0.995496559,0.948509748,0.999996022,0.995309235,0.952035891,0.871979983,0.984279793,0.96065839,0.886313617,0.858288235
1976,1976,2117,11.9,"Divide-and-conquer refers to abstraction, the act of separating large, complex problems into smaller, easier problems that can be solved by a relatively simple algorithm.",4,4.5,4.25,0.014997602,0.985002399,0.980862729,0.518776536,0.577656016,0.992945641,0.919343736,0.999990934,0.989310623,0.971562464,0.924097958,0.980767067,0.951867392,0.82432735,0.781021513
1977,1977,2118,11.9,"It takes a large problem and splits it into two or more easier or faster solutions, and  makes for better readability. ",4,4.5,4.25,0.020359874,0.979640126,0.974020351,0.468907297,0.533888464,0.994604295,0.938308024,0.999993515,0.992353704,0.969071411,0.917449139,0.978561836,0.94634855,0.757342994,0.697524606
1978,1978,2119,11.9,it is the taking of a larger problem and splitting it into simpler smaller problems.,4,4.5,4.25,0.015884519,0.984115481,0.979731003,0.531077802,0.588452177,0.985975791,0.839653714,0.999964163,0.957744548,0.923106918,0.794766257,0.982823273,0.957013282,0.847381592,0.809758938
1979,1979,2120,11.9,It divides the problem into singular units and works on the problem piece by piece until the problem is solved.,4,4.5,4.25,0.016706407,0.983293593,0.978682255,0.57240063,0.624719002,0.989356938,0.878312182,0.99997111,0.965935556,0.952743047,0.873867439,0.969731579,0.924249825,0.837364852,0.797272937
1980,1980,2121,11.9,"smaller parts are easier to compare than comparing the whole, so it divides the problem down in halves until it can easily compare, then works backwards putting it back together to give the solution.",5,5,5,0.019799352,0.980200648,0.97473559,0.451035857,0.518203661,0.98744749,0.856480441,0.999993371,0.992183967,0.961278667,0.896649687,0.981232061,0.953031093,0.831947505,0.79052014
1981,1981,2122,11.9,"a divide-and-conquer paradigm. takes some data, divides it into two parts, and works on each part indiviually until the item is found.",4,4.5,4.25,0.023751378,0.976248622,0.969692717,0.325680733,0.408186202,0.995195195,0.9450641,0.999984691,0.981949377,0.957226853,0.885835073,0.97675587,0.941828914,0.716428816,0.646524529
1982,1982,2123,11.9,"The idea of divide and conquer is to take a large problem, split it into n smaller problems, making the program easier to read and modify.",4,4.5,4.25,0.012986124,0.987013876,0.983429419,0.538706422,0.595147406,0.992999923,0.919964377,0.999993269,0.992063061,0.955185953,0.880387749,0.979926384,0.949763487,0.824507117,0.781245596
1983,1983,2124,11.9,the divide and conquer paradigm is a recursive solution that keeps dividing the problem into halves until a base case is reached.,4,4.5,4.25,0.013126314,0.986873686,0.983250534,0.567410111,0.620339093,0.984367734,0.821267944,0.999994814,0.993885652,0.980120131,0.946939051,0.988407949,0.970989571,0.879445016,0.849726431
1984,1984,2125,11.9,"dividing and conquering means breaking a problem into two smaller problems, solving both of those, and putting the two solutions together.",5,5,5,0.013977468,0.986022532,0.982164442,0.631756067,0.676812082,0.995351487,0.946851067,0.999991812,0.990345199,0.96790895,0.914346439,0.98303322,0.957538699,0.870258987,0.838275921
1985,1985,2126,11.9,"Divide the big problem into small problem, solve small problem and join small solved elements of the problem. if there is two ore more elements in the array, divide the array into parts and compare the elements, after comperison, conquer the elements. If array have n element, first half have n/2 elements",5,5,5,0.011955798,0.988044202,0.984744138,0.511683583,0.571430912,0.979829201,0.769376467,0.99997948,0.975804203,0.949106674,0.86416167,0.980550288,0.951324878,0.822987735,0.779351665
1986,1986,2127,11.9,"divide the array in half, sort each half, then sort them back in one array",3,3,3,0.028342724,0.971657276,0.963834058,0.163821548,0.266131091,0.983290453,0.808950812,0.999819175,0.786787458,0.915059736,0.773287689,0.97096109,0.927326817,0.701889038,0.628400499
1987,1987,2128,11.9,You take a class and break down everything it is supposed to do into easily managed functions.,1,4.5,2.75,0.02846694,0.97153306,0.963675556,0.189205751,0.288409442,0.980624134,0.778465358,0.999977966,0.974019815,0.961159801,0.896332424,0.973552666,0.933812531,0.643847227,0.556050595
1988,1988,2129,11.9,"this is shown by the use of .cpp and header files.  by splitting the program up into smaller subsections of individual code, it becomes easier to write and keep up with as opposed to having all of your code in one file",1,4.5,2.75,0.021277606,0.978722394,0.972849304,0.285445571,0.372873962,0.983391145,0.810102084,0.999971712,0.966645457,0.921226086,0.789746167,0.976991793,0.942419339,0.733264387,0.667510296
1989,1989,2130,11.9,"When a problem is too big, split it into smaller problems of the same type, and solve those, then from the solutions of the smaller problem, give the solution to the larger original problem.",5,4.5,4.75,0.009555101,0.990444899,0.98780748,0.751557171,0.781955075,0.984990154,0.8283844,0.999985198,0.982546315,0.945817159,0.855381694,0.983383529,0.958415387,0.911630571,0.889846161
1990,1990,2131,11.9,it is the separating of large program into smaller classes then until target is reached.,1.5,5,3.25,0.023556471,0.976443529,0.969941423,0.355157614,0.434056477,0.986771924,0.848756332,0.999979346,0.975646653,0.952914605,0.874325341,0.957745271,0.894252723,0.672843933,0.592195382
1991,1991,2132,11.11,"It uses the divide and conqure technique recursively and then when merging back together it compares each element together in a sorted list, this is done by reversing the divide and conquer technique",5,5,5,0.018044353,0.981955648,0.976975008,0.36015141,0.438439264,0.993257305,0.922907162,0.999990467,0.988759706,0.89548354,0.721037267,0.98524585,0.963076057,0.844117701,0.805690454
1992,1992,2133,11.11,A merge sort works by removing all items to sepperate memory locations and merging them back together in order.,2,5,3.5,0.023214996,0.976785004,0.970377152,0.334278852,0.415732309,0.98869212,0.870710955,0.99998318,0.980167664,0.950767808,0.868595369,0.978342845,0.9458005,0.830455184,0.788659941
1993,1993,2134,11.11,"It divides the array into two halves, sorts each half, then merges the two halves together.",5,5,5,0.00587517,0.99412483,0.992503153,0.81755805,0.839880501,0.998885154,0.987253372,0.99999678,0.996203263,0.950925537,0.86901636,0.980390496,0.95092498,0.929921031,0.912645467
1994,1994,2135,11.11,"Divide into two sublists and then those sublists break into length 1, then merges the sublists sorted. ",5,5,5,0.019127011,0.980872989,0.975593511,0.51630491,0.575486803,0.994217425,0.933884732,0.999987373,0.985110734,0.981484539,0.950580764,0.981489992,0.953676595,0.816544652,0.771320275
1995,1995,2136,11.11,"Merge sort uses the ""divide and conquer"" idea where it divides the array in half multiple times and then joins each element of the array back into one sorted array. This is one of the best sorting algorithms besides Quicksort.",5,5,5,0.008765936,0.991234064,0.988814472,0.662057519,0.703406038,0.98998277,0.885467654,0.999987943,0.985783087,0.950450195,0.867747635,0.983296364,0.958197246,0.895388007,0.869599585
1996,1996,2137,11.11,divides the line in half coninuously until you get to only a single value then recombine the values to form a sorted line.,5,5,5,0.023171544,0.976828456,0.970432598,0.399262428,0.472764904,0.981669192,0.790414073,0.999975131,0.970676542,0.962959227,0.901135235,0.972350869,0.930804897,0.826306283,0.783488281
1997,1997,2138,11.11,"Continually split array in half, sort each side of the halves, then put them back together once organized.",5,5,5,0.012743473,0.987256527,0.983739047,0.566708505,0.619723331,0.992689025,0.916409708,0.99992175,0.907734908,0.946536192,0.85730085,0.974891814,0.937163902,0.846077561,0.808133446
1998,1998,2139,11.11,merge sort splits the array of elements into smaller arrays until the arrays reach size 1 and then the merge sort merges the smaller arrays into arrays of size 2 then it moves to the next step and merges the next arrays.,5,5,5,0.011782646,0.988217354,0.984965083,0.727509618,0.760849829,0.991524144,0.903091006,0.999978068,0.974140066,0.948442142,0.862387982,0.970198506,0.925418363,0.848860741,0.811602717
1999,1999,2140,11.11,By divide and conquer.,1.5,5,3.25,0.053846061,0.946153939,0.931291236,0.242088705,0.33482197,0.977775038,0.745890127,0.999969839,0.964437091,0.954551476,0.87869428,0.964513585,0.9111912,0.593351841,0.493107412
2000,2000,2141,11.11,"Break a single array down into many arrays with individual elements, then sort the elements as you reconstruct them back into a single array.",5,5,5,0.020598829,0.979401171,0.973715439,0.600428462,0.649317525,0.992004051,0.908578039,0.999973537,0.968796572,0.96239809,0.899637516,0.978956887,0.94733721,0.833141029,0.792007883
2001,2001,2142,11.11,"Merge sort breaks the array in half, and continues to do so until it has 2 elements to compare and sorts them, after doing so it ""merges"" back as it keeps on sorting the algorithm as it does so.",5,5,5,0.016872466,0.983127534,0.978470361,0.48354435,0.546734619,0.993193889,0.922182096,0.999972836,0.967970661,0.978123317,0.941609395,0.981800332,0.954453256,0.881654263,0.852480286
2002,2002,2143,11.11,"Merge sort divides the problem in half, organizes each half, then brings the two halves together again.",5,5,5,0.011326194,0.988673806,0.985547527,0.563921511,0.617277336,0.995956829,0.95377226,0.999985159,0.982500509,0.962061825,0.898739998,0.983921307,0.959761238,0.852720559,0.816414032
2003,2003,2144,11.11,"Take an array and split it into two, then solve these simpler problems and merge the two answers in correct order.",5,5,5,0.011148155,0.988851845,0.985774708,0.541423619,0.597532144,0.993571109,0.926495053,0.999985821,0.983280822,0.963281144,0.901994457,0.97936301,0.94835358,0.842021644,0.803077691
2004,2004,2145,11.11,"A merge sort recursively divides the array into half until only one element remains, then it sorts the data on its way out of the recursive call by merging the cells.",5,5,5,0.012425244,0.987574756,0.984145114,0.585040093,0.63581198,0.995411087,0.947532502,0.999988816,0.986812805,0.960262378,0.893937131,0.979773129,0.949379949,0.867446423,0.834770021
2005,2005,2146,11.11,"Merge sort recursively divides an array into two arrays until all arrays have 1 element, at which point it merges the 1 element arrays into larger sorted arrays, the final returned array being the sorted version of the initial array.",5,5,5,0.014112473,0.985887528,0.981992173,0.730707765,0.763656671,0.995979918,0.954036249,0.999992552,0.991217355,0.883928961,0.690197177,0.980002569,0.949954149,0.87908864,0.849282203
2006,2006,2147,11.11,Merge sort continuously breaks an array in half then sorts the arrays as it concatenates them back together into one sorted array.,5,5,5,0.011394978,0.988605022,0.985459757,0.725513279,0.75909775,0.989211578,0.876650203,0.999982855,0.979783833,0.970697211,0.921788529,0.978233645,0.945527215,0.906876743,0.88392045
2007,2007,2148,11.11,"It takes an array, splits itself in half, sorts the two halves (either by recursion or iteration) and compares them together giving a third array a full sorted list with both halves rejoined. ",5,5,5,0.011481762,0.988518238,0.985349018,0.689619303,0.727595535,0.992167629,0.910448308,0.999989132,0.987185148,0.970274215,0.920659519,0.971200934,0.927927054,0.928418815,0.910772935
2008,2008,2149,11.11,"it splits a large array into small arrays and recurs until the array is a size of 1, and then merges all of the arrays back together until the source array is completely sourted.",5,5,5,0.013041258,0.986958742,0.983359067,0.669358492,0.70981371,0.992026161,0.908830839,0.999986264,0.983803521,0.943369754,0.848849375,0.981086314,0.952666344,0.892810404,0.866386568
2009,2009,2150,11.11,Mergesort divides the array into smaller halves and then combines the sorted subarrays into one sorted array.,5,5,5,0.016297042,0.983702958,0.979204614,0.765396476,0.794101089,0.992174601,0.910528029,0.999971306,0.966166119,0.960252815,0.893911606,0.97409569,0.935171511,0.87450242,0.843565418
2010,2010,2151,11.11,"merge sort breaks the array down in halves until it is comparing two values, sorts those two values, then merges that back with the other broken down parts that it sorted, each level merging more sets together till you return back to your whole array in order.",5,5,5,0.011915326,0.988084674,0.984795781,0.682796955,0.721607927,0.993607993,0.926916763,0.999979539,0.975873854,0.913396728,0.768848988,0.981627759,0.954021372,0.913959503,0.892749206
2011,2011,2152,11.11,"Divides the data into twor separate arrays, sorts the two arrays and merges them back to back together recursively. ",5,5,5,0.016201854,0.983798146,0.979326077,0.643267512,0.686915059,0.996711519,0.962401037,0.999984455,0.981670658,0.974308338,0.931426913,0.981085096,0.952663296,0.911054075,0.889127551
2012,2012,2153,11.11,"Take the initial array and split it into two, temporary, smaller arrays, sort the two smaller arrays, and merge them back into a single array.",5,5,5,0.008216977,0.991783023,0.989514956,0.730031133,0.763062827,0.997727977,0.974022743,0.99998783,0.985650394,0.950852988,0.868822721,0.981063213,0.952608531,0.892065346,0.865457843
2013,2013,2154,11.11,merge sort divides the data into halves until data of one element is reached and then merges each element together according to its placement in comparison to the rest of the data,5,5,5,0.018211603,0.981788397,0.976761592,0.410042018,0.48222557,0.991322828,0.90078925,0.999985504,0.982907045,0.942885283,0.847556284,0.972861431,0.932082637,0.79925096,0.749763454
2014,2014,2155,11.11,"merge sort uses the divide and conquer strategy, sorting an array in parts, then merging the sorted parts back together.",5,5,5,0.012550831,0.987449169,0.983984863,0.624365389,0.670325681,0.99429925,0.934820281,0.999985617,0.983040464,0.949585171,0.865438817,0.982637717,0.956548907,0.844232023,0.805832957
2015,2015,2156,11.11,"Divide recursuivly big array into two arrays, sort two array and merge them togather recuruivly.",5,5,5,0.021474779,0.978525221,0.972597708,0.665235877,0.706195512,0.994668929,0.939047014,0.99998282,0.979743049,0.984378102,0.958303913,0.980923962,0.95226004,0.887742102,0.860068861
2016,2016,2157,11.11,"divides an array in half and sorts each half by calling its self, thus dividing each half again and again and sorting it until the array is sorted. then putting the elements back in the original array sorted.",5,5,5,0.012087166,0.987912834,0.984576509,0.691490054,0.729237393,0.989025734,0.874525347,0.999978049,0.974117534,0.922127728,0.792152721,0.982618755,0.956501453,0.909502983,0.887194094
2017,2017,2158,11.11,Merge sort takes an array and splits it in half and sends each half back to itself recursively and merges and sorts the two halves when it starts going back up.,5,5,5,0.014552355,0.985447645,0.981430874,0.637632132,0.681969188,0.988304449,0.866278513,0.999988644,0.986610275,0.903671913,0.742892685,0.981331444,0.95327981,0.893262625,0.866950267
2018,2018,2159,11.11,"merge sort splits an array into two halves and then sorts the two smaller arrays, and then merges them back together to form a sorted array",5,5,5,0.009032845,0.990967155,0.98847389,0.818214834,0.840456925,0.996106063,0.955478534,0.999991874,0.990418335,0.96395912,0.903804029,0.985105081,0.962723767,0.96192807,0.952542674
2019,2019,2160,11.11,"the merge sort continually divides the array (or set of containers) into halves, until it reaches the point where there is just one element left, then merges each of the sets of two sorted arrays (containers).",5,5,5,0.008898437,0.991101563,0.988645398,0.718994618,0.753376671,0.994354637,0.935453547,0.999993363,0.992173711,0.977080711,0.938826597,0.984434587,0.961045779,0.880818427,0.851438406
2020,2020,2161,11.11,merge sort splits an array of elements into smaller and smaller array's till the value of 1 is reached.,2.5,5,3.75,0.014989793,0.985010207,0.980872693,0.606254399,0.654430637,0.988849556,0.872511011,0.999984465,0.981682356,0.970628924,0.921606265,0.977787129,0.944409758,0.807988465,0.760654871
2021,2021,2162,12.1,A variable in memory that hold the address of another memory location to which it points too,5,5,5,0.026589632,0.973410368,0.966071042,0.614706874,0.66184892,0.995269284,0.945911196,0.999937727,0.926572548,0.973813309,0.930105642,0.97003637,0.9250126,0.886992812,0.859134861
2022,2022,2163,12.1,A pointer is a variable that contains the memory address of a given value.,4.5,5,4.75,0.028078437,0.971921563,0.964171294,0.535072029,0.591957695,0.995679087,0.950596694,0.999962069,0.955274749,0.965655483,0.908331756,0.967947231,0.919784291,0.795060039,0.744539413
2023,2023,2164,12.1,A pointer is a variable that stores the address of another variable.,5,5,5,0.031656861,0.968343139,0.959605146,0.378329694,0.454393368,0.996048487,0.954820233,0.99993296,0.92095268,0.948276521,0.861945926,0.964542595,0.911263801,0.68724823,0.610150533
2024,2024,2165,12.1,A pointer is a variable that holds a memory address or location of another variable.,5,5,5,0.025514364,0.974485636,0.967443108,0.564825714,0.618070906,0.996007862,0.954355749,0.999959889,0.952704096,0.953193941,0.875070911,0.956543777,0.891245847,0.801510274,0.752579719
2025,2025,2166,12.1,A data type that points to an address in memory which contains certain information. Used for pass-by-reference to save memory.,5,5,5,0.036708534,0.963291466,0.9531591,0.594998837,0.644552235,0.992340271,0.912422226,0.999954947,0.946877378,0.954407807,0.878310816,0.97658264,0.941395387,0.82022047,0.775902232
2026,2026,2167,12.1,a pointer points to a location in memory of a certain data type,4.5,5,4.75,0.027739465,0.972260535,0.96460383,0.38943702,0.464141671,0.996933943,0.96494413,0.999921957,0.907978626,0.971684132,0.924422699,0.950377782,0.875814742,0.801413,0.752458465
2027,2027,2168,12.1,A pointer is a variable that points to the address location of another variable.  Represented by (*).,5,5,5,0.028828204,0.971171796,0.963214575,0.513545513,0.573065028,0.994753811,0.940017518,0.999951512,0.942826961,0.968897654,0.916985368,0.962534177,0.906237506,0.759727061,0.700496377
2028,2028,2169,12.1,A pointer is a variable that holds the address of a given variable (and of a given data type),5,5,5,0.035790384,0.964209616,0.95433068,0.232388392,0.326308526,0.993890801,0.930150263,0.999952165,0.943597031,0.918321323,0.781993123,0.958281662,0.895595103,0.70615977,0.633724024
2029,2029,2170,12.1,pointer is a programming data type whose value points to another value stored in computer memory by its address.,5,5,5,0.038270712,0.961729288,0.951165726,0.440094739,0.50860123,0.992395122,0.913049359,0.999937407,0.926195969,0.964788017,0.906016421,0.971377707,0.928369448,0.806211174,0.758439454
2030,2030,2171,12.1,A data type that points to a specific memory address.,5,5,5,0.035309672,0.964690328,0.954944078,0.594746649,0.644330903,0.993872112,0.929936576,0.999943039,0.932836473,0.968554801,0.916070266,0.962338723,0.90574836,0.807894707,0.760538001
2031,2031,2172,12.1,Its like a variable except it only holds the address in memory of the variable not the physical information.,5,5,5,0.024921834,0.975078166,0.968199189,0.452846766,0.519792998,0.993201724,0.922271678,0.999959534,0.952286164,0.945522882,0.854596245,0.972966504,0.932345594,0.752146602,0.691047232
2032,2032,2173,12.1,a pointer is a reference to a memory location.,5,5,5,0.025664449,0.974335551,0.967251596,0.58454454,0.63537706,0.995064134,0.943565599,0.999905225,0.888249023,0.974233091,0.931226073,0.964521602,0.911211264,0.847601891,0.810033543
2033,2033,2174,12.1,A pointer is an alias to an object in memory.,3.5,4.25,3.875,0.028960705,0.971039295,0.963045501,0.428053707,0.498033462,0.996805537,0.963475995,0.999924104,0.910509953,0.970812401,0.92209598,0.960019423,0.899944048,0.725791872,0.658195704
2034,2034,2175,12.1,"A pointer is a variable that contains a memory address for something that you can use, such as a value, array, or even a function.",5,5,5,0.032144129,0.967855871,0.958983381,0.382244706,0.457829363,0.993141321,0.921581054,0.999940471,0.929808272,0.95221584,0.872460282,0.974566174,0.936348951,0.743082821,0.679749108
2035,2035,2176,12.1,its a data type with a memory address and a value,1.5,5,3.25,0.030699968,0.969300032,0.960826162,0.478970707,0.542720578,0.994786675,0.940393263,0.999926505,0.913340633,0.973973738,0.930533839,0.9129364,0.782113414,0.821730196,0.777784126
2036,2036,2177,12.1,a form of storing data that keeps the location in memory of an data type or object.,5,5,5,0.019286692,0.980713308,0.975389755,0.539451957,0.595801722,0.994362503,0.935543485,0.999952317,0.943776601,0.952276138,0.872621222,0.92570968,0.814080004,0.791445911,0.740034354
2037,2037,2178,12.1,it contains a object's memory address,5,5,5,0.046981573,0.953018427,0.940050475,0.486920178,0.549697402,0.995863585,0.95270616,0.999907796,0.891281322,0.961668495,0.897690169,0.955369899,0.888308084,0.778072715,0.723364484
2038,2038,2179,12.1,variable that contains the memory address of a data object.,5,5,5,0.026905894,0.973094106,0.965667484,0.598378718,0.647518575,0.994644228,0.938764589,0.999969984,0.964607912,0.976830273,0.938158158,0.9572793,0.893086577,0.785948515,0.733181775
2039,2039,2180,12.1,A pointer is an element that references a memory location.,5,5,5,0.03306365,0.96693635,0.957810052,0.541126669,0.597271527,0.996485356,0.959815194,0.999938374,0.92733592,0.967343978,0.912838483,0.968473192,0.921100568,0.809144735,0.762096178
2040,2040,2181,12.1,"an object that points to a specific place in memory, where a variable or value is stored.",5,5,5,0.029412389,0.970587611,0.962469142,0.388406277,0.463237043,0.990924828,0.896238706,0.99994078,0.930173264,0.970436557,0.921092822,0.969979822,0.924871082,0.791900098,0.740600505
2041,2041,2182,12.1,a variable that stores the address of a memory location,5,5,5,0.025420725,0.974579275,0.967562593,0.670466483,0.710786134,0.995485653,0.948385059,0.999943464,0.933337126,0.977010956,0.938640416,0.958543696,0.896250872,0.883111,0.854296129
2042,2042,2183,12.1,"A pointer is a variable that points to an address in memory, which contains some data. The pointer does not contain or point to any data, only a memory address.",5,5,5,0.026057661,0.973942339,0.966749849,0.540381074,0.596617158,0.990037808,0.88609693,0.999946466,0.936877232,0.935953629,0.829055149,0.969942361,0.924777331,0.859353304,0.824681839
2043,2043,2184,12.1,Pointer is a variable which have a memory address of a variable.,5,5,5,0.028896511,0.971103489,0.963127414,0.490108252,0.552495403,0.995666185,0.950449175,0.99993385,0.922001818,0.966623864,0.910916442,0.963857667,0.909549691,0.753010988,0.692124702
2044,2044,2185,12.1,a pointer points to a location in memory where data is stored,5,5,5,0.040724158,0.959275842,0.948035074,0.417487085,0.488759706,0.996913061,0.964705374,0.999933781,0.921920691,0.975946816,0.935800141,0.965703496,0.914169088,0.82908684,0.786954282
2045,2045,2186,12.1,a variable that holds the address of another variable and can access the contents of the variable.,5,5,5,0.027379334,0.972620666,0.965063365,0.324599266,0.407237057,0.992364043,0.91269402,0.999951701,0.943050541,0.956803514,0.884705148,0.955252118,0.888013323,0.656054795,0.571267493
2046,2046,2187,12.1,a pointer is a memory address that points to a data member,5,5,5,0.043503344,0.956496656,0.944488772,0.437395126,0.506231924,0.995520879,0.94878781,0.999912545,0.896880723,0.984618543,0.95894567,0.959026867,0.897460063,0.849087477,0.811885347
2047,2047,2188,12.1,A data type that stores the memory address of another variable.,5,5,5,0.0260728,0.9739272,0.966730531,0.623821795,0.669848597,0.989749015,0.882795002,0.999937233,0.925991031,0.972643155,0.926982408,0.969379035,0.923367544,0.79728961,0.747318604
2048,2048,2189,12.1,its like a variable but only holds an address in meomrry not the physical address.,1,5,3,0.028523147,0.971476853,0.963603834,0.479783148,0.543433614,0.991081683,0.898032113,0.999937105,0.925840262,0.967790059,0.914029109,0.955359983,0.888283268,0.737531543,0.672829364
2049,2049,2190,12.2,"Try several sets of data on an algorithm that includes worst case, best case, and random cases.  Also try and run the same program on a different computer with the same specs",5,3.75,4.375,0.031205416,0.968794584,0.9601812,0.257201344,0.348085521,0.98583899,0.838089605,0.999952399,0.943873095,0.871940394,0.65819874,0.946926487,0.867177482,0.614355922,0.519289283
2050,2050,2191,12.2,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
2051,2051,2192,12.2,time complexity using big O  logarthmic O(log n) linear O(n) exponential O(n^2) quadratic O(n^k) k&gt;=1 Polynomial O(a^n) n&gt;1,1.5,3,2.25,0.107609689,0.892390311,0.862687659,0.05932701,0.174421848,0.97432043,0.706391742,0.999940819,0.930219229,0.956279635,0.883306873,0.93910115,0.847593684,0.596805215,0.497412089
2052,2052,2193,12.2,Using some sort of counting principle of the number of operations performed in an algorithm.,5,3.75,4.375,0.033973992,0.966026008,0.956648436,0.360333622,0.438599181,0.994279471,0.934594128,0.999959503,0.952249626,0.947038358,0.858641171,0.951617517,0.87891732,0.730486631,0.664047786
2053,2053,2194,12.2,Experimental means you would actually write a prototype of the algorithm and measure the time it takes to run given certain parameters.,5,5,5,0.021182954,0.978817046,0.972970082,0.492308348,0.55442631,0.994975034,0.94254688,0.999979292,0.975582454,0.92463537,0.798845816,0.957978988,0.894837626,0.720138133,0.651148242
2054,2054,2195,12.2,measuring the relationship of running an algorithm with different input sizes.,5,3.75,4.375,0.023215652,0.976784349,0.970376316,0.513540924,0.573061,0.997259457,0.968665906,0.999985696,0.983133993,0.987049458,0.965433975,0.938272217,0.845519185,0.579999387,0.476463398
2055,2055,2196,12.2,"Oposite of a theoretical assessment of the algorithm to determine runtime, but to run the code first to determine the the runtime.  This is not recommended because it is a limited test.  It does not include all possibilities of the data, nor the hardware used to process the data.",5,4.25,4.625,0.028283358,0.971716642,0.963909811,0.4096573,0.481887924,0.988663433,0.870382961,0.999981169,0.977796596,0.876788062,0.671137551,0.947159713,0.867761157,0.722351134,0.653906778
2056,2056,2197,12.2,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
2057,2057,2198,12.2,The experimental approach for measuring the running time is by using the Big O equation which tells you the running time.,1.5,3.75,2.625,0.022595108,0.977404892,0.971168144,0.478689104,0.542473431,0.995857039,0.952631306,0.999977795,0.973817348,0.965339154,0.907487449,0.935319616,0.838129964,0.631709695,0.540920996
2058,2058,2199,12.2,"You create and run  the algorithm multiple times, while measuring the amount of time it takes, you then average the results.",5,5,5,0.024489224,0.975510776,0.968751209,0.447312087,0.514935508,0.99098873,0.896969326,0.999975932,0.971621055,0.903027762,0.741173394,0.948687236,0.871583958,0.632036626,0.541328521
2059,2059,2200,12.2,keep a value of how many operations it takes and add to this value each time a function is called.,3,3.75,3.375,0.039108276,0.960891724,0.950096975,0.169161066,0.270817299,0.994785882,0.9403842,0.999952754,0.944291961,0.928559136,0.80931866,0.9385641,0.846249655,0.636237741,0.546565267
2060,2060,2201,12.2,BIG-OH,1.5,3,2.25,0.668759972,0.331240028,0.146647501,0.039980397,0.157442364,0.967930292,0.633329883,0.999539975,0.457578745,0.952242225,0.872530705,0.947982559,0.869820423,0.214271739,0.020578929
2061,2061,2202,12.2,Running the program with various input data and measuring the running time with system time.,5,5,5,0.02270776,0.97729224,0.971024396,0.548686802,0.60390665,0.996912221,0.964695766,0.999968967,0.963408615,0.917434938,0.779627291,0.923520538,0.808601426,0.640201628,0.551506306
2062,2062,2203,12.2,"You run a program with different data sizes, like 10^x.  As you increase x and measure the completion speeds for the program, you can find patterns and attempt the measure the running time.  It's very important to keep the same software and hardware however, which makes experimental testing inferior to theoretical in the eyes of most.",5,3,4,0.019739151,0.980260849,0.974812407,0.509171546,0.569226232,0.988203747,0.865127135,0.999985406,0.982792291,0.801501855,0.470192684,0.947622547,0.868919452,0.736213267,0.671186115
2063,2063,2204,12.2,to run the program through and see how many times each thing is called and the runtime of each function is based on that.,5,3.5,4.25,0.034508646,0.965491355,0.955966206,0.223327115,0.31835593,0.992815654,0.917857531,0.99989527,0.876511386,0.894089903,0.717317539,0.942518326,0.856145557,0.653281569,0.56781063
2064,2064,2205,12.2,the number of times a specific segments get called per unit work.,3,3,3,0.043210685,0.956789315,0.944862211,0.171491817,0.272862873,0.994131948,0.932907422,0.99994967,0.940655771,0.919671078,0.785595727,0.948977205,0.872309638,0.689657092,0.613153212
2065,2065,2206,12.2,"For every call into memory, add/ multiply it into an equation of type O(n)",1.5,3,2.25,0.050371528,0.949628472,0.935724818,0.006916229,0.12842372,0.988909193,0.873192869,0.99996866,0.963046292,0.927812869,0.807326814,0.945256346,0.862997764,0.5938586,0.493739094
2066,2066,2207,12.2,"adding a time marker at the before the algorithm is called and another time marker immediately after so that you have the change in time, then you can calculate the efficiency by the speed of the computers cpu.",3,4.25,3.625,0.026331663,0.973668337,0.966400216,0.3503218,0.429812343,0.994054934,0.932026877,0.999975281,0.970853156,0.925315012,0.800659835,0.946045106,0.864971726,0.653205216,0.567715455
2067,2067,2208,12.2,Big O(h) notation,1.5,3,2.25,0.123094857,0.876905143,0.842928243,0.031166868,0.149707204,0.989184612,0.876341884,0.999887832,0.867741116,0.967858422,0.914211575,0.91452483,0.786088641,0.474361241,0.344784017
2068,2068,2209,12.2,the experimental approach measures actual running time in t.  t= seconds.,5,5,5,0.037834048,0.962165952,0.951722919,0.462120473,0.527932033,0.993834988,0.929512118,0.999963993,0.957543717,0.982631682,0.95364258,0.947982555,0.869820413,0.711888671,0.640865176
2069,2069,2210,12.2,running an algorithm on a specific set of data,5,3,4,0.042853892,0.957146108,0.945317487,0.312813133,0.396893001,0.991122005,0.898493139,0.999941645,0.93119287,0.983732726,0.956581354,0.912749554,0.781645811,0.665349662,0.582853672
2070,2070,2211,12.2,"In experimental terms, the running time of an algorithm is measured by the number of operations required to complete the function. This number can usually be expressed in big-O notation.",2.5,3.75,3.125,0.029523671,0.970476329,0.962327144,0.492144167,0.554282217,0.988917708,0.87329023,0.999979424,0.975738031,0.897441956,0.726264434,0.946801379,0.866864385,0.745419681,0.682662035
2071,2071,2212,12.2,"run the code for n-times and get average values, drop the constant and lowest number. for example if             f(x) = 3n +1 the running time will bef  f(x) = O(n)",2.5,4.5,3.5,0.060241818,0.939758182,0.923130109,0.173351318,0.274494857,0.985508528,0.834311253,0.999971888,0.96685283,0.901703956,0.737640051,0.943589449,0.858826164,0.636855841,0.547335737
2072,2072,2213,12.2,to measure the actual time of the program to run. and calculate the running time using the input and operations done,5,5,5,0.017859936,0.982140064,0.977210327,0.566298664,0.619363635,0.992792054,0.917587704,0.999941281,0.930763992,0.933518645,0.822555983,0.94238506,0.855812044,0.780209363,0.726027844
2073,2073,2214,12.2,adding up the number of operations performed based on the worst case possible.,2,3,2.5,0.04461503,0.95538497,0.943070236,0.179998055,0.280328342,0.995127324,0.944288093,0.99996527,0.959049182,0.929896053,0.812886997,0.953699009,0.884126491,0.620311558,0.526713065
2074,2074,2215,12.2,the experimental approach would be to run through the algorithm and see how long it takes,5,5,5,0.02917248,0.97082752,0.962775271,0.300202906,0.385825682,0.993497746,0.92565625,0.999973704,0.968994474,0.949693315,0.865727462,0.914211955,0.785305636,0.524727404,0.407566122
2075,2075,2216,12.2,"trying it with different sets of inputs, and measuring the amount of time that the algorithm actually takes.",5,5,5,0.02794838,0.972051621,0.96433725,0.431155682,0.500755899,0.991668932,0.904746447,0.99997458,0.970026578,0.960346643,0.894162041,0.947898903,0.869611064,0.604195118,0.506623704
2076,2076,2217,12.2,running the input with various inputs measuring the running time with  system time,5,3.75,4.375,0.035348535,0.964651465,0.954894489,0.408278674,0.480677978,0.996896138,0.96451189,0.999956736,0.948986825,0.990958141,0.97586656,0.953386691,0.883344879,0.527382672,0.410875949
2077,2077,2246,12.4,"it scans the list and selects the smallest(largest) element and places it in the front, increment the curPtr by one, scan the list again for the next smallest(largest) element and place it in with respect with the other sorted elements.",5,5,5,0.01034385,0.98965615,0.986801019,0.462587178,0.528341635,0.991356321,0.901172199,0.999892435,0.873168881,0.92782082,0.807348035,0.976072732,0.940119284,0.880763531,0.851369977
2078,2078,2247,12.4,"Selection sort searches the array for the lowest value and swaps it with the first value in the array. Then searches for the next lowest value and swaps it with the second item in the array, and so on.",5,5,5,0.012061596,0.987938404,0.984609137,0.51639539,0.575566212,0.996052859,0.954870226,0.999923094,0.909319147,0.942415161,0.846301491,0.973925041,0.934744442,0.857605934,0.822503719
2079,2079,2248,12.4,Compare the largest element to the front element and swap data according to value if needed.,4,3.75,3.875,0.027289033,0.972710967,0.965178591,0.193455562,0.292139273,0.991436997,0.902094604,0.999862318,0.837657989,0.929197337,0.811022069,0.972898712,0.932175937,0.796478391,0.746307408
2080,2080,2249,12.4,"Selection sort is a sorting algorithm that divides a list in half and has two lists. It then compares the first elements in both these lists and puts these elements in another list, having the smaller element before the bigger one.",1,3,2,0.014963388,0.985036612,0.980906386,0.388987958,0.463747553,0.994066774,0.932162248,0.999845762,0.818136556,0.927502326,0.80649795,0.980331552,0.950777466,0.829872131,0.787933158
2081,2081,2250,12.4,"Iterate through the list (assume list of integers), find the smallest one, and put it in a separate ""sorted"" list... then traverse again and find the next smallest, and move it to the sorted section... and repeat until you run out of elements to sort.",5,4.5,4.75,0.015344143,0.984655857,0.980420535,0.38470456,0.459988245,0.984891314,0.82725431,0.999809203,0.775029434,0.926712676,0.804390311,0.967545454,0.918778798,0.837189257,0.797054055
2082,2082,2251,12.4,selection sort selects the smallest element out of the list then the second smallest ....and sorts them acordingly.,5,5,5,0.018016756,0.981983244,0.977010222,0.481981516,0.545363003,0.993270622,0.923059427,0.999847448,0.820123556,0.879945429,0.679564814,0.981768151,0.954372719,0.794661403,0.744042508
2083,2083,2252,12.4,You select the smallest element and place it on the left.  You select the smallest element and sort it with respect the the item already on the left.  You continue this till the end of the collection of items.,5,5,5,0.012162626,0.987837374,0.984480221,0.508160353,0.568338762,0.995095437,0.943923512,0.99993497,0.923322179,0.945086697,0.853432033,0.977054212,0.942575549,0.84609884,0.808159971
2084,2084,2253,12.4,"A selection sort scrolls through the data structure looking for the lowest (or highest) unsorted piece of data, moves it to the held spot, increments that spot by one, and starts the process over.",5,5,5,0.012751639,0.987248361,0.983728627,0.383355469,0.45880422,0.992310196,0.912078354,0.999817389,0.784681262,0.924268983,0.7978679,0.969174482,0.922855627,0.860820115,0.826510239
2085,2085,2254,12.4,Selection sort works by finding the smallest element and then compares it with the largest and sorts the elements.,0,3.75,1.875,0.012703478,0.987296522,0.983790081,0.385705054,0.460866324,0.993628099,0.927146651,0.999874168,0.851630365,0.89099229,0.709049764,0.968622202,0.921473483,0.753271639,0.692449607
2086,2086,2255,12.4,"Selection sort is usually a recursive sorting method where you divide the elements to be sorted in half repeatedly. You then sort the smallest case, then work your way up, sorting each until they are all sorted.",1,4,2.5,0.019478321,0.980521679,0.975145232,0.292965233,0.379473566,0.995339335,0.946712126,0.999816005,0.783049084,0.903718913,0.743018131,0.981370546,0.953377667,0.811234474,0.764701066
2087,2087,2256,12.4,"goes to the middle of the list, checks to see if it is greater or less then the value given and moves through the list accordingly to add the value into the proper place.",0,3.75,1.875,0.013827085,0.986172915,0.982356333,0.365031958,0.442722658,0.985540164,0.834672967,0.999885807,0.865353521,0.937262118,0.83254761,0.976914562,0.942226059,0.850652516,0.813836189
2088,2088,2257,12.4,selection sort finds the lowest element in the data set and places it behind the pivot point.,5,3.75,4.375,0.020117581,0.979882419,0.974329522,0.464434922,0.5299633,0.993925819,0.930550637,0.999832958,0.803038409,0.912026634,0.765192099,0.97036689,0.925839764,0.847967505,0.810489287
2089,2089,2258,12.4,"Selection sort iterates through the array one element at a time, seeking the least value from the right and replacing the current value with it.",5,3.75,4.375,0.013441741,0.986558259,0.982848041,0.43554318,0.50460657,0.995235376,0.945523509,0.999867774,0.844090899,0.938092113,0.834762932,0.980286773,0.950665402,0.860303342,0.825866075
2090,2090,2259,12.4,"Selection sort traverses an unsorted array looking for the smallest value, when it's found it is put at the beginning of the unsorted array.  Performed several times, this will output a sorted array.",5,5,5,0.016825914,0.983174086,0.978529762,0.403867662,0.47680667,0.997121613,0.96708986,0.999826061,0.794906021,0.942276312,0.845930892,0.979847294,0.949565555,0.87053436,0.838619178
2091,2091,2260,12.4,it runs through the list and finds the smallest (or largest) value and puts it at the appropriate position,5,3.75,4.375,0.01307869,0.98692131,0.983311303,0.442596734,0.510797096,0.991882303,0.907186026,0.999831229,0.801000323,0.90678208,0.751193967,0.978829389,0.947018132,0.822479725,0.778718423
2092,2092,2261,12.4,"pick a number, and set all values less than that number to the left, while all numbers on the right of that number is larger.",1,5,3,0.02109921,0.97890079,0.973076942,0.309540838,0.394021084,0.989849696,0.883946142,0.999833609,0.803806401,0.948582936,0.862763772,0.973553356,0.933814258,0.75685823,0.696920341
2093,2093,2262,12.4,It takes the largest item in the unsorted array and swaps it with last item in the unsorted array.,5,3.75,4.375,0.02326417,0.97673583,0.970314406,0.369041413,0.446241542,0.99475678,0.940051459,0.999854435,0.828362948,0.941787515,0.844626254,0.971892546,0.929657892,0.843244374,0.80460184
2094,2094,2263,12.4,"by selecting the first object and comparing it with the next objects to find one that is smaller, if it does it switches the two.  then it comes back the other way and sees if the objects previous to the last one is greater, if it does it switches them.  it does this while decreasing the range it looks at until it finishes in the middle.",1,3.75,2.375,0.014107287,0.985892713,0.98199879,0.44717139,0.514812026,0.99296893,0.919610021,0.999893564,0.874500379,0.936058452,0.82933493,0.976383994,0.940898252,0.852749944,0.816450661
2095,2095,2264,12.4,"Selection sorts works by going through a certain list. Goes through the unsorted list and selecting the largest item in the list and placing it in a sorted array. There are two arrays, unsorted and sorted. Complete these steps until the list is sorted.",5,3.75,4.375,0.017483234,0.982516766,0.977691007,0.406485617,0.479104309,0.993281735,0.923186481,0.999830171,0.799751942,0.930743618,0.815149215,0.975804417,0.939447795,0.867483318,0.834816012
2096,2096,2265,12.4,"selection sort works by pulling all of the values off to the side, leaving one value in the list.  It will then insert a value into the list.  if the value is bigger it will go to the right, if smaller if will go to the left.",1,3.75,2.375,0.01700455,0.982995451,0.978301819,0.33777073,0.418796944,0.992998326,0.919946119,0.999911086,0.895160606,0.936284766,0.82993898,0.976371352,0.940866614,0.844624817,0.806322581
2097,2097,2266,12.4,selection sort searches for the smallest element of the remaining data organization and places it at the largest point of the new data organization,5,3.75,4.375,0.022907376,0.977092624,0.970769682,0.329817683,0.411816981,0.993885284,0.930087184,0.999878809,0.857102283,0.928133767,0.808183316,0.972572003,0.93135831,0.806882203,0.759275901
2098,2098,2267,12.4,"Selection sort sorts an array one element at at time. It first finds the element with the smallest key and puts it into the first location within its array or list, then finds the next smallest and puts it in the second location, and so on.",5,5,5,0.006176114,0.993823886,0.992119142,0.595202148,0.64473067,0.996046926,0.954802389,0.999888087,0.868042268,0.951844434,0.871468969,0.977225939,0.943005316,0.901975453,0.877810925
2099,2099,2268,12.4,"select an element compare it with 2nd element if it is greater, swap it ",1,4.5,2.75,0.029743433,0.970256567,0.962046722,0.321863949,0.404836416,0.992315476,0.912138727,0.999830194,0.799779894,0.896271283,0.723139815,0.976592993,0.941421296,0.737764657,0.673119943
2100,2100,2269,12.4,"it selects the smallest element in a list and switches it with the element in its correct position, then it selects the next smallest and does the same...",5,4.25,4.625,0.011155307,0.988844693,0.985765581,0.562314689,0.615867114,0.99688414,0.964374705,0.999850049,0.823190726,0.933551794,0.82264446,0.979569637,0.948870687,0.853780627,0.817735422
2101,2101,2270,12.4,It starts at the first element and replaces it with the smallest element found to the right. It then repeats with the next element in the list.,5,4.25,4.625,0.011597633,0.988402367,0.985201164,0.432307184,0.501766511,0.994231291,0.934043263,0.999902751,0.885332976,0.931466795,0.817079432,0.976410769,0.94096526,0.799034715,0.749493901
2102,2102,2271,12.4,"selection sort is when you pick a data member and put it in a new array, then you pick another data member and put it in order with the new array, then pick another and insert it in the correct place in the new array, etc etc",1,5,3,0.016956985,0.983043015,0.978362513,0.450192601,0.51746358,0.993875281,0.929972811,0.99990782,0.891309047,0.949277317,0.86461713,0.965583069,0.913867706,0.876018345,0.845455039
2103,2103,2272,12.4,"it searches through the entire data set for the best element to go in the current position, then it moves up a position and searches through the remainder of the set for the best element for the new position.",5,3,4,0.01398778,0.98601222,0.982151284,0.452399701,0.519400633,0.987241021,0.85411977,0.999936132,0.924691831,0.941125607,0.842859569,0.980172786,0.950380136,0.862427413,0.828513758
2104,2104,2273,12.4,selection sort  iterates through the array one element @ a time searching for the right and replacing current value with it.,5,3,4,0.018800139,0.981199861,0.976010607,0.393725365,0.467905321,0.991273926,0.900230132,0.999831177,0.800938602,0.92122069,0.789731764,0.979496323,0.948687211,0.833704174,0.792709851
2105,2105,2274,12.5,A link list can grow to a infinite size as a array has a fixes size.,5,5,5,0.020553172,0.979446828,0.973773699,0.358591855,0.437070526,0.992965942,0.919575853,0.999952353,0.943818688,0.96658364,0.910809081,0.982319263,0.95575194,0.759713888,0.700479958
2106,2106,2275,12.5,The advantage of linked lists is that they are not limited in size like arrays.,5,5,5,0.023725748,0.976274252,0.969725421,0.411153734,0.483201264,0.992927025,0.919130892,0.999978669,0.974848823,0.96299841,0.901239817,0.958152709,0.895272383,0.57330972,0.468124636
2107,2107,2276,12.5,link lists dont have a fixed size,5,5,5,0.03890574,0.96109426,0.950355417,0.32918039,0.411257663,0.991676511,0.904833097,0.999951566,0.942891311,0.963426188,0.902381591,0.952716816,0.881668441,0.649407268,0.562981261
2108,2108,2277,12.5,"Linked Lists can be of variable size, where arrays have fixed size.",5,5,5,0.012529433,0.987470567,0.984012167,0.542604387,0.598568441,0.994076838,0.932277323,0.999983666,0.980740909,0.974870083,0.932926255,0.969698954,0.924168178,0.815262318,0.769721828
2109,2109,2278,12.5,"Linked lists do not have a definite size. They can be as big or as small as needed, and they don't have to allocate extra memory for elements you don't need. Arrays size must be defined.",5,5,5,0.021692157,0.978307843,0.972320329,0.397097081,0.470864495,0.993161265,0.921809085,0.99997121,0.966052735,0.940001622,0.839859564,0.979611526,0.948975519,0.780173004,0.725982522
2110,2110,2279,12.5,"a linked list has a dynamic size , but an array only has a fixed size and takes allot of extra operations to increase its size.",5,5,5,0.018609941,0.981390059,0.976253304,0.431477934,0.501038723,0.99060567,0.892589606,0.99997906,0.975309919,0.936516515,0.830557536,0.977740839,0.944293912,0.794848382,0.744275581
2111,2111,2280,12.5,You do not have to predetermine your list size as you do with arrays. Linked list have the ability to be as large as you want them adding memory as needed.,5,5,5,0.02498579,0.97501421,0.96811758,0.318367362,0.40176765,0.990269322,0.888743953,0.999958473,0.951035303,0.962743354,0.900559053,0.976738724,0.941786005,0.748032272,0.685918665
2112,2112,2281,12.5,The main advantage to a linked list is that it can have it's size adjusted during runtime.,5,5,5,0.024491608,0.975508392,0.968748167,0.35471952,0.433671986,0.99237117,0.912775505,0.999960542,0.953474119,0.977715594,0.94052115,0.975995408,0.939925772,0.684837818,0.607145922
2113,2113,2282,12.5,Linked lists are able to grow in size. So elements can be added to the list.,5,5,5,0.016063511,0.983936489,0.979502605,0.542497397,0.598474541,0.99491495,0.941859909,0.999970777,0.965542799,0.971558772,0.924088103,0.975358296,0.938331326,0.807471216,0.760010113
2114,2114,2283,12.5,"Linked lists are not confined to a specific size, and can have elements added and removed far easier. They are also easier to traverse.",4.5,5,4.75,0.015295982,0.984704018,0.980481989,0.437628716,0.506436934,0.994862002,0.941254522,0.99999063,0.988951356,0.961474463,0.897172282,0.9822072,0.955471489,0.770478964,0.71389877
2115,2115,2284,12.5,There is no predetermined length,5,5,5,0.119014978,0.880985022,0.848134258,0.057753604,0.173040954,0.985469133,0.833860823,0.999939503,0.928666746,0.952958193,0.874441681,0.942296757,0.855591055,0.590499699,0.489552178
2116,2116,2285,12.5,"Inserts into a linked list are far cheaper than an insert into an array. With an array, all items after the one being inserted must me shifted, with a linked list, only the pointers are replaced.",4,5,4.5,0.016320884,0.983679116,0.979174191,0.430263013,0.499972451,0.992278532,0.91171633,0.999973275,0.968487714,0.950008941,0.866569893,0.983732049,0.959287598,0.748893857,0.686992642
2117,2117,2286,12.5,Linked lists may be dynamically grown.,5,5,5,0.030986547,0.969013453,0.960460481,0.454434186,0.521186192,0.991847171,0.90678435,0.999971555,0.966459923,0.954207064,0.877775017,0.954561011,0.886283749,0.761113107,0.702224103
2118,2118,2287,12.5,"Linked lists are very dynamic in that they can change and be added/subtracted to very easily because they are not linear in memory.   Arrays are pre-specified in size to be cast over a certain amount of disk space.  This makes insertion into Arrays difficult because all elements must be shifted, and if you reach the end of the array, you are done even if you have more data to input.  Linked Lists do not run into these problems.",5,5,5,0.018382609,0.981617391,0.976543385,0.531769753,0.589059464,0.990447207,0.890777809,0.999975879,0.971558859,0.949153261,0.864286015,0.984875102,0.962148218,0.852777421,0.816484913
2119,2119,2288,12.5,"linked lists have an indefinite size, whereas arrays are a specific size.",5,5,5,0.015539646,0.984460354,0.980171068,0.384715408,0.459997766,0.995371293,0.947077516,0.999976641,0.972457049,0.939720745,0.83910988,0.926839414,0.816907292,0.647315085,0.560373327
2120,2120,2289,12.5,"Linked lists have no predefined length, and thus you can have virtually unlimited items in that list.",5,5,5,0.027813554,0.972186446,0.964509291,0.418308258,0.489480405,0.996728637,0.962596761,0.999977092,0.972988465,0.976036414,0.936039286,0.978636697,0.946535898,0.806378186,0.758647637
2121,2121,2290,12.5,"They grow dynamically, unlike the fixed size array",5,5,5,0.03441143,0.96558857,0.956090255,0.221674204,0.316905259,0.993555023,0.926311131,0.999979284,0.975573793,0.949848394,0.86614138,0.961838034,0.904495329,0.756647825,0.696658069
2122,2122,2291,12.5,"you can add as many nodes as you like without having to specify a list size, if an array gets too big you have to copy its entire contents to another larger array to get more room",5,5,5,0.020011127,0.979988873,0.97446536,0.227247417,0.321796569,0.990902921,0.895988234,0.999964994,0.958724105,0.941310524,0.843353127,0.972755733,0.931818115,0.729372442,0.662658934
2123,2123,2292,12.5,Linkded list does not have a fixed size. Arrays have a fixed size.,5,5,5,0.02178967,0.97821033,0.9721959,0.35872975,0.437191549,0.99179813,0.906223629,0.999935593,0.924056842,0.96094704,0.895764548,0.966786086,0.916878393,0.746090949,0.683498779
2124,2124,2293,12.5,"Linked lists have a dynamic size, where as arrays have a static size.",5,5,5,0.015225112,0.984774888,0.98057242,0.505739868,0.566214433,0.996321056,0.957936664,0.999967533,0.96171779,0.9585791,0.889444328,0.944328727,0.860676292,0.765898466,0.708189118
2125,2125,2294,12.5,linked lists do not have a memory constraint other than total memory,5,5,5,0.044700801,0.955299199,0.94296079,0.251161993,0.342785107,0.994450145,0.936545539,0.999907802,0.891288387,0.967240932,0.912563445,0.976191072,0.940415443,0.598966062,0.500105615
2126,2126,2295,12.5,"The primary advantage of linked lists over arrays is their ability to become larger or smaller as data is added and removed from the list, whereas arrays may waste memory for small data sets, and run out of space for large data sets.",5,5,5,0.020370126,0.979629874,0.974007269,0.361608058,0.439717686,0.990829972,0.895154165,0.999986953,0.984616601,0.944883283,0.852889104,0.978488721,0.946165572,0.753622353,0.692886777
2127,2127,2296,12.5,"Array have fixed size, in Link List are flexible for adding or deleting an element. ",5,5,5,0.016897082,0.983102918,0.97843895,0.455758452,0.522348429,0.995849627,0.952546569,0.999966201,0.960147483,0.970956409,0.922480349,0.977289739,0.943164982,0.777342558,0.722454333
2128,2128,2297,12.5,they are resizeable,5,5,5,0.093030274,0.906969726,0.881291315,0.116867147,0.224921735,0.979980604,0.771107539,0.99995663,0.948861641,0.904342849,0.744683466,0.981282706,0.953157838,0.412400633,0.26754928
2129,2129,2298,12.5,Linked lists can be dynamically allocated and their size can change as needed.,5,5,5,0.020853162,0.979146838,0.973390905,0.47741732,0.541357254,0.993086058,0.920949199,0.999977717,0.973725908,0.967777246,0.91399491,0.978186842,0.945410085,0.816347718,0.771074794
2130,2130,2299,12.5,"linked lists do not have to have a specified size, they are easier to add to and remove from",5,5,5,0.019201279,0.980798721,0.975498744,0.314067453,0.397993851,0.996242349,0.957036761,0.999916613,0.901676744,0.936956493,0.831731872,0.953625728,0.883943097,0.65595305,0.571140667
2131,2131,2300,12.5,"they dont have a fixed size, no shiftnig needs to be done for insertion/deletion.",5,5,5,0.037736416,0.962263584,0.9518475,0.214475766,0.310587576,0.995844468,0.952487581,0.999980669,0.977206295,0.96905336,0.91740096,0.963782514,0.909361612,0.70444721,0.631589294
2132,2132,2301,12.5,linked list many be dynamically grown. It has not limit,5,5,5,0.031482637,0.968517363,0.95982746,0.456088573,0.522638158,0.993353044,0.924001802,0.999954862,0.946777441,0.971411564,0.923695194,0.983072177,0.957636193,0.714519501,0.644144541
2133,2133,2302,12.6,A data structure in C++ where the the first element in the queue is the first element taken out of the queue.,5,5,5,0.01429671,0.98570329,0.981757082,0.671807647,0.711963201,0.997256042,0.968626855,0.999973685,0.968971947,0.963183313,0.901733338,0.989295824,0.973211579,0.881557107,0.852359181
2134,2134,2303,12.6,A queue is an abstract data type that performs operations on both ends of the list and exhibits first-in first-out behavior.,5,5,5,0.033742785,0.966257215,0.95694346,0.533996522,0.591013781,0.995393592,0.947332473,0.999986795,0.984430115,0.979191038,0.944459228,0.988560754,0.971371983,0.86329639,0.829596949
2135,2135,2304,12.6,First in first out.,4,5,4.5,0.06100291,0.93899709,0.922158939,0.36058405,0.438818969,0.983705137,0.813692113,0.999849589,0.822648259,0.89899222,0.730402212,0.931506487,0.828587174,0.654838502,0.569751368
2136,2136,2305,12.6,"A queue is an abstract data type that involves putting an element at the back of the list. Queues use the FIFO, first in first out, idea where the first element in the list is the first that comes out.",5,5,5,0.012247741,0.987752259,0.984371612,0.606734574,0.654852061,0.994718311,0.939611624,0.999977528,0.97350239,0.959007858,0.890588717,0.98536301,0.963369264,0.912978113,0.89152589
2137,2137,2306,12.6,"A data structure that implements first in, first out. The element that has been there the longest is the first to get served.",5,5,5,0.018125296,0.981874704,0.976871722,0.539561153,0.595897557,0.996043924,0.95476807,0.999959343,0.9520613,0.977628566,0.940288866,0.987407616,0.968486123,0.916956067,0.896484464
2138,2138,2307,12.6,a data structure that inserts elements at the end of it and removes elements from the front.,5,5,5,0.018728495,0.981271505,0.976102027,0.47095257,0.53568349,0.996355273,0.958327886,0.999991,0.989388045,0.958268721,0.888615902,0.978099528,0.945191572,0.830962777,0.789292663
2139,2139,2308,12.6,A queue is a collection of elements with the characteristics of first in first out (FIFO).  The first item in is the first item out.  All additional items are added to the end of the list.,5,5,5,0.014850259,0.985149741,0.981050742,0.557423651,0.611574513,0.992298337,0.911942773,0.999976941,0.972810885,0.949191599,0.864388342,0.985215497,0.963000096,0.905730486,0.882491625
2140,2140,2309,12.6,"A queue is a data structure that inserts data into a FIFO configuration, that is, data input to the structure is always at it's end, and data taken is always from the beginning.",5,5,5,0.018729806,0.981270194,0.976100354,0.428922743,0.498796168,0.99169454,0.905039231,0.999983018,0.979975803,0.925487638,0.801120587,0.97497499,0.937372059,0.866124809,0.833122612
2141,2141,2310,12.6,It is a particular set of entities that are put in to a certain order by the enqueue and the dequeue functions.,1.5,5,3.25,0.01913178,0.98086822,0.975587426,0.43754366,0.506362285,0.993914718,0.930423712,0.999987161,0.984861028,0.972486006,0.926562965,0.988817162,0.972013673,0.868976772,0.836677622
2142,2142,2311,12.6,A queue is a data type that operates under a FILO (First In Last Out) method. This means that the first element inserted into the queue is the first element removed.,5,2.5,3.75,0.011203825,0.988796175,0.985703671,0.651957691,0.694541961,0.989777094,0.883116049,0.999980604,0.977129563,0.951780802,0.871299131,0.990280752,0.975676474,0.894132495,0.868034572
2143,2143,2312,12.6,like a linked list except it is first in last out,0,5,2.5,0.027157009,0.972842991,0.965347057,0.132536024,0.238673467,0.992856313,0.918322404,0.999820676,0.788556696,0.965382899,0.907604208,0.921448276,0.803415354,0.802233636,0.7534814
2144,2144,2313,12.6,A queue is like a stack except it follows FIFO (First in first out) .,5,5,5,0.022431493,0.977568507,0.97137692,0.458154351,0.52445118,0.993945865,0.930779833,0.999945832,0.9361301,0.970959391,0.922488308,0.987305747,0.968231184,0.828987241,0.78683013
2145,2145,2314,12.6,A queue is a data structure where the first node in is the first node out.,5,5,5,0.013393104,0.986606896,0.982910103,0.537308633,0.593920642,0.996346496,0.958227536,0.999949007,0.939873819,0.952404943,0.872965012,0.979800502,0.949448453,0.841465592,0.802384565
2146,2146,2315,12.6,A queue is a First in First out data structure much like a line for a movie theatre.  The first object in line is the first object to be handled or enacted upon.,5,5,5,0.014441252,0.985558748,0.981572644,0.488921881,0.551454189,0.996761622,0.962973891,0.999966908,0.960980994,0.955323666,0.880755316,0.978673468,0.946627922,0.90086633,0.876428388
2147,2147,2316,12.6,"its a lot like a stack, except that the first item put into the list is the first item to be taken from the list.",5,5,5,0.020686984,0.979313016,0.973602951,0.251458168,0.343045044,0.991166782,0.89900509,0.999915794,0.900712024,0.93379791,0.823301363,0.983150869,0.957833129,0.850372136,0.813486691
2148,2148,2317,12.6,"a first in first out list of items, like if you put 5, 4, 3, 2, and 1 in the queue it will when you dequeue items remove the items in the same order as put in, so thus it will put out, 5, 4, 3, 2, and 1 in that exact order.",5,5,5,0.022683263,0.977316737,0.971055656,0.217713073,0.313428787,0.983191147,0.807815396,0.999876803,0.854736723,0.916214038,0.776368612,0.980112788,0.950229984,0.775913119,0.720672519
2149,2149,2318,12.6,"A linked list with a First In, Out structure dequeue at the head of the list enqueue at the end of the list",5,5,5,0.022089958,0.977910042,0.971812725,0.301325828,0.38681121,0.989248164,0.877068505,0.999947989,0.93867268,0.969749037,0.919257777,0.968345892,0.920781986,0.895170152,0.869328026
2150,2150,2319,12.6,"a list of objects that follow the rule first in first out, essentially a linked list that goes in order of the first object in the list is the first to be taken off.",5,5,5,0.013626933,0.986373067,0.982611732,0.286664993,0.373944183,0.991921125,0.907629896,0.999926427,0.913249439,0.945105926,0.853483356,0.951030509,0.877448265,0.865453959,0.832286388
2151,2151,2320,12.6,A queue is an abstract data type that is based off of the priniple of first in first out. FIFO. The first item inserted into the list will the first item taken out.,5,5,5,0.014092207,0.985907793,0.982018033,0.550864995,0.605818332,0.996485985,0.959822381,0.999980903,0.977482261,0.962622092,0.900235395,0.991220817,0.978029094,0.908183873,0.885549805
2152,2152,2321,12.6,"It is a ""first in first out"" data structure.  It can be implemented with either a linked list or an array.",5,5,5,0.018789411,0.981210589,0.976024297,0.423767149,0.494271381,0.996764732,0.963009451,0.999937277,0.926042946,0.977258798,0.939301926,0.972849278,0.932052223,0.897717059,0.872502779
2153,2153,2322,12.6,an ordered list that performs task in the order of first in first out. adding items to the queue places items behind the rest of them. taking items off the queue takes the one that has waited the longest.,5,5,5,0.014415264,0.985584736,0.981605805,0.501307786,0.562324632,0.993026223,0.92026508,0.999927659,0.914701364,0.969163287,0.917694364,0.987337004,0.968309409,0.869696021,0.837574176
2154,2154,2323,12.6,"A queue is a linear, first-in first-out data structure. Data must be accessed in the same order it was put into the queue, so only the oldest item in the queue is accessible at any time. Main functions defined are enqueue and dequeue.",5,5,5,0.01435113,0.985648871,0.981687642,0.663379669,0.704566418,0.987005813,0.851430507,0.999985199,0.982548287,0.972008555,0.92528861,0.984225229,0.960521837,0.909450412,0.887128563
2155,2155,2324,12.6,"Queue is a buffer, it follows the rule of First In and First out. Queue is very useful in computer science for scheduleing .",5,5,5,0.010738611,0.989261389,0.986297295,0.495456368,0.557189157,0.986371474,0.844177775,0.999967699,0.961912946,0.978055455,0.941428266,0.981945616,0.954816846,0.868078709,0.835558174
2156,2156,2325,12.6,a queue is a set of elements where the first element inserted is the first element to be removed,5,5,5,0.028673649,0.971326351,0.963411791,0.399875999,0.473303401,0.993756272,0.928612123,0.999971786,0.966732733,0.964608024,0.905536005,0.985339292,0.963309907,0.841034055,0.801846647
2157,2157,2326,12.6,Is a list of items where the the user only has access to the first element and each new element is added at the end.,5,5,5,0.021248698,0.978751302,0.972886192,0.346714944,0.426646799,0.994112943,0.932690131,0.99989558,0.876876667,0.943739903,0.849837332,0.981060648,0.952602112,0.850053966,0.813090089
2158,2158,2327,12.6,"a queue is a list of data that follows the fifo principle, an example of this would be when you get into a line at a movie theater...the first one there gets to buy a ticket first",5,5,5,0.017411888,0.982588112,0.977782047,0.394625843,0.468695622,0.991215601,0.899563271,0.999956961,0.949252602,0.976363622,0.93691263,0.980454422,0.951084963,0.898029566,0.872892324
2159,2159,2328,12.6,"A queue is a data structure that holds a set of objects, which has a FIFO (first in first out) priority.",5,5,5,0.012741506,0.987258494,0.983741557,0.54645133,0.601944696,0.994715916,0.939584239,0.999954421,0.946257485,0.977525993,0.94001509,0.991412001,0.978507553,0.924871683,0.906351387
2160,2160,2329,12.6,like a linked list expect first in last out,0,2.5,1.25,0.025861979,0.974138022,0.966999544,0.16130957,0.263926462,0.992078363,0.909427685,0.999901353,0.883683614,0.95485795,0.879512283,0.971122289,0.927730236,0.804544508,0.756361933
2161,2161,2330,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2162,2162,2331,12.7,"Pop, which removes the head, or least recently inserted node from the stack. Push, which inserts a new node at the head of the stack.",5,5,5,0.066876829,0.933123171,0.914663689,0.142500162,0.247418455,0.962937769,0.576247692,0.999886592,0.866278987,0.868832831,0.649904407,0.950830234,0.876947054,0.733614147,0.667946276
2163,2163,2332,12.7,Push and pop,5,5,5,0,1,1,0.854469299,0.872275522,0.991316008,0.900711275,0.999932941,0.920930334,0.999626023,0.999001826,1,1,1,0.999999851
2164,2164,2333,12.7,The Push function and the Pop function.,5,5,5,0.057644129,0.942355871,0.926444818,0.298810124,0.384603313,0.976899544,0.735880138,0.999833824,0.804060114,0.912451364,0.766325737,0.916149569,0.790154736,0.730271161,0.663779199
2165,2165,2334,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2166,2166,2335,12.7,push - puts an element on the stack pop- takes an element off the stack,5,5,5,0.095525205,0.904474795,0.878107728,0.338428468,0.419374204,0.979179408,0.761947033,0.999841908,0.813591151,0.944831133,0.852749912,0.952579766,0.881325458,0.78292805,0.729416724
2167,2167,2336,12.7,Push  and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.704518795,0.740672019,0.99207813,0.909425027,0.999929796,0.917221863,0.999626023,0.999001826,1,1,1,0.999999851
2168,2168,2337,12.7,Push and Pop,5,5,5,0,1,1,0.67974478,0.718929197,0.986679455,0.847699082,0.999918139,0.903476908,0.998229208,0.995273615,0.961384429,0.903360131,1,0.999999851
2169,2169,2338,12.7,push and pop.,5,5,5,0.029791236,0.970208764,0.961985725,0.806218505,0.829928391,0.99785766,0.97550548,0.999981123,0.977741284,1,1,1,1,1,0.999999851
2170,2170,2339,12.7,"Push and Pop. Push adds an element to the stack, while Pop removes the top element from a stack.",5,5,5,0.055690885,0.944309115,0.928937201,0.393014818,0.467281712,0.972558963,0.686251947,0.999923391,0.909669703,0.876748301,0.671031426,0.962891198,0.907130992,0.879226387,0.849453906
2171,2171,2340,12.7,pop and push,5,5,5,0,1,1,1,1,0.993155412,0.921742165,0.999963857,0.957383547,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
2172,2172,2341,12.7,"push,pop,search,isEmpty",4,5,4.5,0.056273699,0.943726301,0.928193517,0.6280725,0.673579213,0.984989462,0.828376495,0.999872159,0.849261232,0.980371734,0.947610599,0.941663049,0.854005129,0.369233668,0.213741073
2173,2173,2342,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2174,2174,2343,12.7,"Push, Pop, isEmpty, isFull  Maybe List to show all elements or an operation to count how many elements in the stack.",4.5,5,4.75,0.062502921,0.937497079,0.920244892,0.177201912,0.277874317,0.963804935,0.58616247,0.999907967,0.891483144,0.897226618,0.72568968,0.954795707,0.886871103,0.674034536,0.593679484
2175,2175,2344,12.7,"pop, push",5,5,5,0.027692318,0.972307682,0.96466399,0.93170315,0.940059524,0.989143945,0.875876919,0.999896067,0.877450833,0.996792008,0.991437615,0.930477885,0.82601298,1,0.999999851
2176,2176,2345,12.7,"isempty, push and pop, along with usually, ",5,5,5,0.058241308,0.941758692,0.925682805,0.548788726,0.603996103,0.976965379,0.736632855,0.999923742,0.910083158,0.938450751,0.835720166,0.953671989,0.88405887,0.802894235,0.754304845
2177,2177,2346,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2178,2178,2347,12.7,push and pop. push puts objects into the stack and pop takes them out following the first in last out rule.,5,5,5,0.043029308,0.956970692,0.945093652,0.590939045,0.640989174,0.978631324,0.755680496,0.999926539,0.913381072,0.883024206,0.687782315,0.955834105,0.889469812,0.81163013,0.765194256
2179,2179,2348,12.7,"The main operations in a stack are push and pop. Push adds an item to the top of the stack, pop removes the top item from the stack.",5,5,5,0.060750365,0.939249635,0.922481192,0.42818585,0.498149438,0.974531763,0.708808028,0.999904486,0.887378029,0.840451491,0.574152357,0.9587938,0.896876786,0.822239399,0.778418854
2180,2180,2349,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2181,2181,2350,12.7,"push, which adds an item to the top of the stack, and pop, which takes the first item off the top to the stack",5,5,5,0.073892772,0.926107228,0.90571119,0.32531786,0.407867728,0.976230802,0.728234048,0.999910083,0.893977422,0.845160473,0.586721004,0.964165016,0.910318867,0.704336762,0.63145162
2182,2182,2351,12.7,"the main functions defined for a stack are push, which puts an element on the top of the stack, and pop, which removes an item from the top.",5,5,5,0.07341063,0.92658937,0.906326414,0.296363354,0.382455914,0.970159442,0.658816944,0.999912963,0.897373938,0.893920494,0.716865373,0.958131378,0.895219,0.731068134,0.664772637
2183,2183,2352,12.7,Push() Pop() Full() IsEmpty(),4.5,5,4.75,0.194964111,0.805035889,0.751221487,0.180955008,0.281168208,0.957207068,0.510725526,0.999780876,0.741628658,0.953950355,0.87708984,0.952357773,0.880769895,0.842623174,0.803827506
2184,2184,2353,12.7,pop and push to remove an element and to insert an element,5,5,5,0.065241516,0.934758484,0.916750385,0.508953214,0.569034614,0.988977682,0.87397594,0.999918639,0.904066025,0.838789302,0.569715842,0.956330061,0.890710998,0.786415398,0.733763752
2185,2185,2354,12.7,"Push, Pop",5,5,5,0.027692378,0.972307622,0.964663914,0.616493106,0.6634166,0.975892214,0.724362785,0.999809067,0.774868321,0.998229208,0.995273615,0.961384429,0.903360131,1,0.999999851
2186,2186,2355,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2187,2187,2356,12.7,push - Add an element to the top of the stack pop - remove the top element from the stack,5,5,5,0.087966323,0.912033677,0.887753029,0.363372892,0.441266586,0.977321778,0.740707755,0.999800059,0.76424653,0.805656098,0.481280689,0.957032219,0.892468229,0.738218188,0.673685277
2188,2188,2357,12.7,push and pop,5,5,5,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0.999999851
2189,2189,2358,12.8,When you traverse a tree of any size you will visit each node three times.  Its on the order of 3n or O(n) running time.,5,3,4,0.01906842,0.98093158,0.975668275,0.442615181,0.510813286,0.990710245,0.893785263,0.999895841,0.877185371,0.975600761,0.934876493,0.986510548,0.966241108,0.891241312,0.864430673
2190,2190,2359,12.8,"The Euler tour traversal of a tree begins at the root and visits each node in the tree from the left, then bottom, then right sides.",5,5,5,0.011951983,0.988048017,0.984749006,0.525112271,0.583216551,0.990020315,0.885896924,0.999912396,0.896704976,0.971114974,0.922903571,0.980128417,0.950269098,0.893941283,0.867796224
2191,2191,2360,12.8,Where you visit the in order according to its data value.,2.5,3,2.75,0.029557109,0.970442891,0.962284476,0.186159849,0.285736217,0.983966214,0.816677152,0.999873029,0.850287385,0.967057545,0.912073971,0.981008252,0.952470985,0.730682433,0.664291855
2192,2192,2361,12.8,"It is a tree that shows how it functions. It contains parents, children, siblings, ancestors and descendents. The use of tree type algorithm is also an alternative sorting algorithm. ",0,3.75,1.875,0.022457659,0.977542341,0.971343531,0.249133259,0.341004597,0.992179001,0.910578337,0.999834908,0.805337676,0.951901298,0.871620744,0.98113398,0.952785634,0.751329958,0.690029276
2193,2193,2362,12.8,"Start from the root, circle around the _whole_ ""tree"", naming each node as you see it.",5,4.25,4.625,0.018027127,0.981972873,0.976996988,0.503286362,0.564061122,0.991459801,0.902355342,0.999918458,0.90385248,0.972290278,0.926040551,0.98159015,0.953927251,0.882243574,0.853214871
2194,2194,2363,12.8,it is where you visit the parent then you vistit the children,0,3,1.5,0.044940114,0.955059886,0.942655422,0.089776218,0.201145482,0.979336479,0.763742918,0.999870123,0.846860311,0.93695268,0.831721695,0.956357581,0.89077987,0.578920305,0.475118307
2195,2195,2364,12.8,"To start from the root , traveling left and visiting ever child along the way till you return to the root from the right.",4,4.25,4.125,0.014666915,0.985333085,0.981284693,0.516715646,0.575847283,0.991496722,0.902777471,0.99991629,0.901295965,0.968060208,0.914750158,0.979012966,0.947477555,0.918233454,0.898076744
2196,2196,2365,12.8,"Traversing a tree down to it's terminal child and then all of it's siblings, then it traverses up the terminal child's parent and all of it's siblings (repeating the first step if those siblings have children) until the root node has been visited.",4,4.25,4.125,0.030470669,0.969529331,0.961118753,0.194403827,0.292971514,0.990618573,0.892737127,0.999879295,0.85767486,0.931102403,0.816106841,0.978674095,0.946629491,0.760412276,0.701350507
2197,2197,2366,12.8,The Euler tour traversal of a tree the function that iteratively keeps track of the pointer on each node.,1.5,3.75,2.625,0.024531424,0.975468576,0.968697361,0.253573626,0.344901668,0.987558945,0.857754765,0.999877691,0.855783497,0.967293756,0.912704437,0.979589842,0.948921252,0.777210474,0.722289689
2198,2198,2367,12.8,"You travel the outside edge of the tree, clockwise, while naming each node.",4.5,3,3.75,0.019367576,0.980632424,0.975286546,0.412544936,0.484422247,0.991888944,0.907261959,0.999903941,0.88673546,0.962807304,0.90072974,0.973613669,0.933965198,0.758414745,0.698860558
2199,2199,2368,12.8,children to root,0,3.75,1.875,0.12838316,0.87161684,0.836180252,0.11716374,0.225182039,0.966784749,0.62023227,0.999847556,0.820251872,0.898987868,0.730390596,0.77688401,0.441626796,0.564384222,0.456998882
2200,2200,2369,12.8,go to the bottom of the left sub tree and visit the parent and then its children,2,3.75,2.875,0.024181902,0.975818098,0.969143358,0.204775944,0.302074564,0.98017634,0.773345489,0.999915392,0.900237881,0.955568355,0.88140841,0.967762002,0.919320734,0.838370085,0.798525972
2201,2201,2370,12.8,The Euler tour traverses through the tree in a rubber-band style shape.,3.5,3,3.25,0.035244286,0.964755714,0.955027512,0.16694276,0.268870411,0.985473289,0.833908345,0.999847469,0.820148525,0.955630838,0.881575182,0.972350712,0.930804504,0.69285959,0.617145169
2202,2202,2371,12.8,"The Euler tour traversal of a tree is a specific way of navigating a tree that involves following the tree starting at the very top and moving along the left side of the tree first, cupping in to visit the parents of children nodes.  It allows for each node to be visited from the left, the right and the bottom.  The Euler tour first progresses to a left child if there is one, then progresses to it's parent, then it's next child, then it's parent's parent.",5,3.75,4.375,0.012308121,0.987691879,0.984294566,0.450401634,0.517647037,0.990205639,0.888015832,0.99991468,0.899398342,0.946494512,0.857189603,0.9800744,0.950133914,0.909686387,0.887422709
2203,2203,2372,12.8,it runs through the parents and the children in order,2.5,3,2.75,0.048009753,0.951990247,0.938738494,0.06647706,0.180697063,0.985120007,0.829869081,0.999894988,0.87617844,0.954755087,0.879237733,0.955584071,0.888844073,0.681734562,0.603277671
2204,2204,2373,12.8,"it starts node on the left of the root and then proceeds to visits each node in a left to right order, visits the root, and then proceeds to repeat the previous step on the right side of the tree.",2.5,3.75,3.125,0.01049602,0.98950398,0.986606846,0.481893122,0.545285425,0.991935068,0.907789321,0.999907808,0.891295754,0.95351265,0.87592157,0.975842831,0.93954393,0.890815556,0.863899963
2205,2205,2374,12.8,"Travel from the root to the farthest left child Backup, travel the leftmost children in the right side repeat until reaching the rightmost child.",3.5,5,4.25,0.024619222,0.975380778,0.968585329,0.32243228,0.405335209,0.992771567,0.917353455,0.999906909,0.890234976,0.964850153,0.906182266,0.974038327,0.935027953,0.875594378,0.844926558
2206,2206,2375,12.8,"has preorder, in order, and postorder of a tree.  preorder = puts the parent node in front of the child node(s).  in order = puts the parent node between the left child and right child node(s).  postorder = puts the parent node after the child node(s).",2.5,3.75,3.125,0.019671261,0.980328739,0.974899036,0.36393556,0.441760409,0.987091532,0.85241058,0.999927004,0.913928876,0.938039858,0.83462346,0.975079668,0.937634028,0.777064383,0.722107585
2207,2207,2376,12.8,"The Euler traveral is when you go through a tree looking for nodes to put in the order of left, root, right. Like inOrder traversal. ",2.5,5,3.75,0.014301658,0.985698342,0.981750769,0.491443664,0.553667422,0.992886033,0.918662212,0.99989603,0.877407479,0.971766845,0.924643467,0.972204347,0.930438209,0.898001432,0.872857255
2208,2208,2377,12.8,"An Euler traversal is a traversal that begins with the root, and travels around the outside of the tree.  Each element in the tree is visited 3 times.  From the left, from the bottom and from the right.",5,5,5,0.007056057,0.992943943,0.990996315,0.702192724,0.738630551,0.993610264,0.926942732,0.999895591,0.87688954,0.98097588,0.949223113,0.990403435,0.975983502,0.946439028,0.933235374
2209,2209,2378,12.8,Euler tour traversal of a tree traverses down each branch straight to one leaf then starts again at the root and repeats until all elements have been traversed.,4,3.75,3.875,0.022963583,0.977036417,0.97069796,0.282130241,0.369964275,0.986704551,0.847986018,0.999856945,0.831322595,0.976772709,0.938004515,0.978830415,0.9470207,0.814708769,0.769031822
2210,2210,2379,12.8,"The Euler tour visits every node in a tree, starting with the root and working around the tree counterclockwise. in-order, post-order, and pre-order traversals can be seen as variations of the Euler tour traversal.",4,4.5,4.25,0.02522397,0.97477603,0.967813657,0.356149197,0.434926736,0.992080196,0.909448649,0.999869805,0.846485889,0.962354976,0.899522441,0.97563917,0.939034245,0.89220053,0.865626351
2211,2211,2380,12.8,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
2212,2212,2381,12.8,to traverse going down to the left then go to the right of last children and back to the top.. kind of like going around the tree,5,4.5,4.75,0.025098443,0.974901557,0.967973832,0.344005853,0.424269176,0.987277455,0.854536338,0.999887405,0.867238222,0.974464056,0.931842537,0.972497837,0.931172701,0.905560076,0.882279207
2213,2213,2382,12.8,"You recursively visit every node on the list. You visit the node from the left, the bottom, and from the right.",5,5,5,0.013584971,0.986415029,0.982665276,0.553832173,0.608422466,0.991166177,0.898998174,0.999925777,0.912482292,0.97197254,0.925192483,0.978041735,0.945046938,0.870355368,0.838396061
2214,2214,2383,12.8,"the euler tour is a way to traverse a tree where you come into contact with each node three times, from the left, from the right, and from the bottom",5,5,5,0.007153988,0.992846012,0.990871353,0.659195304,0.700894026,0.993480718,0.925461565,0.999932447,0.920346814,0.981849271,0.951554263,0.984796758,0.961952153,0.938112736,0.922856538
2215,2215,2384,12.8,traversing a tree level by level,0,3,1.5,0.087823987,0.912176013,0.887934652,0.167124882,0.26903025,0.978209422,0.750856668,0.999854648,0.828613642,0.931741958,0.817813864,0.944876526,0.862047221,0.610542297,0.514535549
2216,2216,2385,12.8,The Euler traversal through the tree in a rubber band style shape.,3.5,3,3.25,0.027915835,0.972084165,0.964378777,0.113725625,0.22216459,0.986505889,0.845714607,0.99986313,0.838614636,0.962003784,0.898585081,0.978819823,0.946994192,0.660198748,0.576432987
2217,2217,2386,12.9,"if root, set root to NULL else if deleting right leaf, set rightPtr of parent node to NULL else if deleting left leaf, set leftPtr of parent node to NULL else if deleting a left or right subtree child node, set the max leaf child in the left subtree as the new child node.",4.5,4,4.25,0.021129012,0.978870988,0.973038914,0.39585799,0.469777011,0.98240157,0.798787736,0.999969376,0.963890856,0.903829786,0.74331406,0.982436955,0.956046477,0.833394706,0.792324096
2218,2218,2387,12.9,"Traverse the tree and find the node, if the node has no children, simply delete it; otherwise set the node's data equal to the data of one of its children then set the pointer for that child to NULL.",3,3.75,3.375,0.022101939,0.977898061,0.971797438,0.480583608,0.544136135,0.993707123,0.928050167,0.999952582,0.94408896,0.930908979,0.815590577,0.958017786,0.894934723,0.718077421,0.648579537
2219,2219,2388,12.9,first attaching the elements from the node to be deleting to alternate nodes and then deleting that node.    delete node;,3,3.75,3.375,0.038713574,0.961286426,0.950600624,0.580449164,0.631782769,0.986288722,0.843231628,0.99995983,0.95263558,0.900218806,0.733676068,0.970223162,0.925480068,0.682303369,0.603986697
2220,2220,2389,12.9,"If you delete a node from a tree, you have to link that nodes parents to the children of that node.",2.5,3.75,3.125,0.030267656,0.969732344,0.961377803,0.500967741,0.562026193,0.987963216,0.862377015,0.999937364,0.926144837,0.949613726,0.865515033,0.95424389,0.885490118,0.538830459,0.425145771
2221,2221,2390,12.9,"Must delete the information that the node contains (to free up memory/ ""garbage collect"") and also delete the pointer (in that node's ""parent"") that points to the node you wish to delete.",0.5,3,1.75,0.034342051,0.965657949,0.956178785,0.457694799,0.524047856,0.994434058,0.936361604,0.999957809,0.950251669,0.945679162,0.855013369,0.969656758,0.924062577,0.671360612,0.590346402
2222,2222,2391,12.9,you replace the node with the largest element of its left subtree or replace it with the smallest element of the right subtree.,5,5,5,0.014268696,0.985731304,0.981792828,0.643773615,0.687359238,0.986156745,0.841722664,0.999971996,0.96698057,0.971190926,0.923106293,0.975906764,0.93970393,0.875507176,0.84481786
2223,2223,2392,12.9,"You traverse the tree till you find the node you are wanting to delete.  If the node has no children you delete it.  If the node has children, before you delete, you find the left-most of its children and attach it to the root then you can delete the node.",3.5,4.25,3.875,0.030180752,0.969819248,0.961488693,0.491141349,0.553402097,0.989123169,0.875639373,0.999956778,0.949036152,0.917036112,0.778562793,0.975689653,0.939160585,0.700763643,0.626997678
2224,2224,2393,12.9,Link the to-be-deleted's left child to the to-be-deleted's parent's left child pointer.,3.5,5,4.25,0.070498466,0.929501534,0.910042399,0.185579628,0.285226988,0.98106182,0.783469661,0.999950179,0.941254894,0.945298351,0.853996954,0.975451757,0.938565223,0.715983272,0.645969152
2225,2225,2394,12.9,The way you delete a node from a binary search tree is first you have take the root and then see the nodes that are coming from the root. And delete the nodes and set the root to NULL.,0,3.75,1.875,0.018429101,0.9815709,0.976484061,0.399991959,0.473405174,0.983279114,0.808821172,0.999957977,0.950450071,0.936455843,0.830395598,0.975187388,0.937903609,0.707625687,0.635551309
2226,2226,2395,12.9,You remove the element from the tree and move the next highest element from the left into its place.,5,3.75,4.375,0.019180834,0.980819166,0.975524832,0.288740456,0.375765706,0.987330894,0.85514733,0.999856711,0.831046326,0.952120994,0.87220713,0.974470541,0.936109618,0.772907674,0.716926191
2227,2227,2396,12.9,delete node;,0,3,1.5,0.1717785,0.8282215,0.780806839,0.486063361,0.54894542,0.981943136,0.793546219,0.999711507,0.659834647,0.846695675,0.59081858,0.975820686,0.93948851,0.54578197,0.433810923
2228,2228,2397,12.9,"the deletion of a node depends upon if it has children and if it is an AVL binary search tree. Assuming it is not an AVL tree, and the node being deleted has no children, you just set its pointer to null. If it has a left child or a right child exclusively, that child replaces the deleted node, if it has two children, the left most child of the right sub tree (or right most child of the left subtree)will replace it",5,5,5,0.020691216,0.979308784,0.973597551,0.494619429,0.556454621,0.987458589,0.85660734,0.999954553,0.946413389,0.926250235,0.803156019,0.968019715,0.91996569,0.782197535,0.728506128
2229,2229,2398,12.9,"If the node is a leaf, just set it's parent's pointer to null and delete it, if it has a single child, set the parent's pointer to the child and delete; if it has two children, set the node to one of the middle children and remove that child from its previous position as a leaf (rightmost child of the left subtree or leftmost child of the right subtree).",5,5,5,0.019911706,0.980088294,0.974592223,0.44304955,0.511194508,0.987864722,0.861250882,0.999873765,0.851154479,0.883984223,0.690344676,0.962661532,0.906556227,0.797932744,0.748120279
2230,2230,2399,12.9,"In a binary search tree, you must first establish a proper replacement for the node you are about to delete, usually a child from the soon to be deleted node.  Once that replacement node has been found, you simply reassign it to where the node that is going to be deleted is.  After the deleted node has been usurped, you remove the deleted node from memory so it may be used again. ",4,3.75,3.875,0.022229671,0.977770329,0.971634448,0.516254783,0.575442809,0.988337611,0.866657669,0.999965041,0.95877913,0.858642181,0.622704753,0.977500618,0.943692731,0.737507343,0.672799199
2231,2231,2400,12.9,It all depends on where the node is located. If its a child it can just be deleted but for a node inside the tree it must be replaced with another node that works in its place.,3,3.75,3.375,0.022656262,0.977343738,0.971090109,0.537622213,0.594195855,0.986289929,0.843245428,0.99993269,0.920633723,0.943834239,0.850089123,0.97798465,0.944904076,0.672347903,0.591577074
2232,2232,2401,12.9,"if the node has no children, delete it right away, otherwise, put either the furthest right node on the left side or the furthest left node on the right side in that place and perform a the above on that node to guarantee that it's children get handled properly.",5,5,5,0.01701647,0.98298353,0.978286608,0.566489458,0.619531085,0.99377191,0.92879092,0.99997369,0.968978036,0.944952599,0.853074114,0.980687398,0.951668012,0.801251531,0.752257192
2233,2233,2402,12.9,Create a temp Node  Set temp's values to the Node after head  or NULL in the case of only head Node in the list.   Set head equal to temp. Delete temp,0,3.75,1.875,0.022597373,0.977402628,0.971165253,0.341088891,0.421709115,0.985420388,0.833303497,0.999896111,0.877503483,0.899884477,0.732783717,0.974972372,0.937365507,0.688553751,0.611777882
2234,2234,2403,12.9,"by searching down the tree until you find the node, and replacing the link to that node with the greatest child node on the left subtree or the least child node on the right subtree.",5,4.25,4.625,0.014194608,0.985805392,0.981887367,0.697547376,0.734553579,0.98852382,0.868786695,0.999964782,0.958473683,0.953643256,0.876270168,0.983034679,0.95754235,0.892298877,0.865748943
2235,2235,2404,12.9,"Set the nodes to NULL, where that it doesn't point to anything, and the use the DELETE opertator to clear space from memory.",0,3,1.5,0.028805912,0.971194089,0.963243021,0.316525221,0.400150901,0.995231575,0.945480046,0.999973237,0.968443692,0.944034679,0.850624113,0.980559931,0.951349011,0.68366158,0.605679725
2236,2236,2405,12.9,"You must first traverse the tree to find the appropriate value.  Then you must make sure that the node is a leaf node.  If it is, then you can delete the pointer to that specific node.",1.5,3.75,2.625,0.023243368,0.976756632,0.970340949,0.515598357,0.574866699,0.983608239,0.812584227,0.999953485,0.945154019,0.929727037,0.81243588,0.964894152,0.912143613,0.715107203,0.64487712
2237,2237,2406,12.9,"if the node is a leaf, you set it's parent's pointer to null. if the node is in the tree you must replace the node with one in the tree: either the largest in the left of the tree or the smallest in the right of the tree. this can be done recursively if needed.",5,5,5,0.019590437,0.980409563,0.975002169,0.545179784,0.600828729,0.983437284,0.810629612,0.99990704,0.8903894,0.945723966,0.855132954,0.979927369,0.949765952,0.829297245,0.787216554
2238,2238,2407,12.9,"if the node is a leaf it can simply be deallocated/deleted from memory, and its parent's reference to it changed to NULL. If the node has a single child, the pointer to it should be made to point to its child before deleting the node. Should the node have two children, the easiest solution may be to copy the node's entire subtree to a new array or tree, delete the node and all descendants, then add the elements taken from the subtree back into the main tree.",4,4.5,4.25,0.02013725,0.97986275,0.974304424,0.613204837,0.660530663,0.988217546,0.865284905,0.999972216,0.967238908,0.931759666,0.817861128,0.969966885,0.924838705,0.786822855,0.734271653
2239,2239,2408,12.9,not answered,0,0,0,0.113388062,0.886611939,0.855314328,0.024732584,0.144060179,0.974181154,0.704799321,0.999560354,0.481607809,0.797582206,0.45973083,0.957582389,0.893845092,0.344307631,0.182670431
2240,2240,2409,12.9,you cannot delete a node because that can cause a node to have more than 2 children,0,2.5,1.25,0.037731171,0.962268829,0.951854193,0.326445788,0.40885765,0.979993333,0.771253081,0.99990962,0.893431428,0.91780546,0.780616244,0.870291045,0.675388551,0.46241799,0.329896593
2241,2241,2410,12.9,"You search the tree for the node using recursion. When you find the node, you determine whether it is a leaf or a internal node. If it is a leaf, you just delete it and set the parent pointer to that node to NULL. If it is a  node, you replace the node with either of the children nodes.",3.5,3.75,3.625,0.019938588,0.980061412,0.974557921,0.603982508,0.652436721,0.990742621,0.894155438,0.999948104,0.938808818,0.903259125,0.741790921,0.966109123,0.915184216,0.733538508,0.667851992
2242,2242,2411,12.9,"to delete the node, you would have to link the children nodes that are connected to the node to be deleted to the remaining nodes of the tree in such a way that nodes on the right of the parent node are larger than the parent and nodes on the left of the parent node are smaller",3,5,4,0.021050394,0.978949606,0.973139233,0.516506553,0.575663774,0.990613505,0.892679179,0.999966517,0.96051945,0.929508188,0.811851755,0.978415627,0.945982646,0.738349736,0.673849252
2243,2243,2412,12.9,"if it has no children, you just delete it. if it only has one child, just replace the node with whichever child it has. if it has both children, replace it with one of its children, and send the other child down along the other side of the new node.",3.5,3.75,3.625,0.030749738,0.969250262,0.960762655,0.374991119,0.451463279,0.985062973,0.829216977,0.999888378,0.868384749,0.910299069,0.76058109,0.948582602,0.871322099,0.660636544,0.576978706
2244,2244,2413,12.9,pointer to the child and delete it has 2 children set the node to the child and delete it. the node to th middle will then take its place,2,3.75,2.875,0.026873887,0.973126113,0.965708327,0.433225125,0.502572138,0.984099669,0.818203015,0.999875661,0.853390655,0.930721056,0.815088996,0.963607359,0.908923266,0.664300442,0.581545804
2245,2245,2414,12.11,Log(n) where n is the number of nodes.,4.5,5,4.75,0.052664697,0.947335303,0.932798683,0.266800225,0.356509943,0.979923281,0.770452133,0.999906949,0.890282357,0.956247191,0.883220278,0.940026454,0.849909363,0.481277943,0.353405779
2246,2246,2415,12.11,log(n) steps,4.5,5,4.75,0.164652109,0.835347891,0.789900271,0.114863806,0.22316351,0.979603692,0.766798102,0.999823691,0.792112101,0.982426751,0.953095603,0.951068015,0.877542128,0.289614588,0.114494811
2247,2247,2416,12.11,The number of levels and the height of the tree,5,5,5,0.020438075,0.979561925,0.973920565,0.660471916,0.70201444,0.995118377,0.944185791,0.999923406,0.909686472,0.947266728,0.859250708,0.946729165,0.866683662,0.887657404,0.859963283
2248,2248,2417,12.11,It is the same as the height of the tree.,5,5,5,0.015488446,0.984511554,0.980236401,0.778602481,0.805691291,0.9948787,0.941445433,0.999962973,0.95634043,0.999479896,0.998611801,0.918676773,0.796479352,0.860364437,0.82594223
2249,2249,2418,12.11,"Given n elements, it would take n/2 steps to find the search criteria.",0,3,1.5,0.063853204,0.936146796,0.918521901,0.141422227,0.24647241,0.985961775,0.839493464,0.999919701,0.905318548,0.922330366,0.792693578,0.9477308,0.869190367,0.608362794,0.511818768
2250,2250,2419,12.11,log n,4.5,5,4.75,0.234557271,0.765442729,0.70069974,0.088721894,0.200220158,0.951713334,0.447912723,0.999773964,0.733478593,0.98423274,0.957915931,0.881117087,0.702481955,0.444033414,0.30697997
2251,2251,2420,12.11,Depends on the location of the node you are looking for. If it is the root it is one step.  else If it is smaller than the current you are on node you go to the left.  If it is larger than the current node you are on go to the right.,0,3.75,1.875,0.041063011,0.958936989,0.947602691,0.319079846,0.402392959,0.983504743,0.811400901,0.999796478,0.760025089,0.782616035,0.419784931,0.934911226,0.837107922,0.651887536,0.566072949
2252,2252,2421,12.11,2^n where n is the # of levels the binary tree has,0,3.75,1.875,0.050558865,0.949441135,0.935485771,0.330689877,0.412582459,0.992535208,0.914651041,0.999934029,0.922213279,0.971266753,0.923308682,0.928680788,0.82151554,0.477039337,0.3481223
2253,2253,2422,12.11,The number of steps to search a node is the function n-1.,2.5,4,3.25,0.046303928,0.953696072,0.940915165,0.282745481,0.370504238,0.993511317,0.925811415,0.999935624,0.924093226,0.961163541,0.896342406,0.948249407,0.870488241,0.683375359,0.605322946
2254,2254,2423,12.11,"It would take n/2 elements, given n.",0,3,1.5,0.083457112,0.916542888,0.893506881,0.200670794,0.298471694,0.989676508,0.881965995,0.999901452,0.883801151,0.946976926,0.858477204,0.925109641,0.812578338,0.622942865,0.529993024
2255,2255,2424,12.11,log(n),4.5,5,4.75,0.181707323,0.818292677,0.768137442,0.097049795,0.20752911,0.974396625,0.707262918,0.999813799,0.780448287,0.926133428,0.802844252,0.969485984,0.923635196,0.393681526,0.244215659
2256,2256,2425,12.11,O(log n),4.5,5,4.75,0.153256238,0.846743763,0.804441655,0.101559386,0.211486935,0.983574952,0.812203637,0.999868965,0.845494788,0.946445588,0.857059021,0.924084863,0.810013714,0.505584061,0.383703685
2257,2257,2426,12.11,O( Log (n) ),4.5,5,4.75,0.171180189,0.828819811,0.781570297,0.092861734,0.203853474,0.983998343,0.817044497,0.999856911,0.831282234,0.943396415,0.848920536,0.902199159,0.755242244,0.480681568,0.352662391
2258,2258,2427,12.11,"If the binary search tree is constructed efficiently, best case scenario is O(log n) time.  Where n is the number of items in the tree.  If the binary search tree is constructed poorly, with for instance the root of the tree being 1, and progressing downwards and to the right its children are each more than the last: you have a one-way linear linked list.  That worse case scenario would be a full traversal at O(n) time. Where n is the number of items in the tree.",5,5,5,0.030823648,0.969176352,0.960668344,0.539504886,0.595848175,0.963753653,0.585576129,0.999942193,0.931838996,0.821821996,0.524428755,0.946108352,0.865130006,0.682029068,0.603644777
2259,2259,2428,12.11,"N, n being the number of nodes.",2.5,5,3.75,0.047605813,0.952394188,0.939253932,0.31611982,0.399795103,0.982686987,0.802051061,0.999925914,0.912644519,0.956159103,0.882985164,0.931109862,0.827594575,0.460256457,0.327202213
2260,2260,2429,12.11,"depending on the way that the tree is ordered, it could be anywhere between log(n) and N steps.",5,5,5,0.043635428,0.956364572,0.94432023,0.331134677,0.412972836,0.987119541,0.852730824,0.999936489,0.925112899,0.943917892,0.850312399,0.936309459,0.840607159,0.580272019,0.476803237
2261,2261,2430,12.11,log(n),4.5,5,4.75,0.181707323,0.818292677,0.768137442,0.097049795,0.20752911,0.974396625,0.707262918,0.999813799,0.780448287,0.926133428,0.802844252,0.969485984,0.923635196,0.393681526,0.244215659
2262,2262,2431,12.11,"worst case scenario = the number of levels of the tree, ie: the node at the farthest position from the root node.  best case = 1 step if its the root node.",5,5,5,0.032957733,0.967042267,0.957945205,0.445827991,0.513632997,0.982797076,0.803309772,0.999930023,0.917489563,0.830869774,0.548577993,0.932340232,0.830673716,0.664022207,0.581198981
2263,2263,2432,12.11,3 steps at most.  There are 3 cases.,0,3,1.5,0.072571278,0.927428722,0.907397447,0.406695634,0.479288629,0.992983309,0.919774423,0.999932321,0.920198645,0.938959314,0.837077561,0.916792608,0.791764014,0.491427124,0.366056871
2264,2264,2433,12.11,log(n)    where n equals the total number of nodes in the tree.,4.5,5,4.75,0.045738876,0.954261124,0.941636184,0.378376752,0.454434668,0.986657508,0.84744815,0.999944096,0.934083096,0.925225566,0.800421096,0.938654987,0.846477111,0.556676686,0.447391334
2265,2265,2434,12.11,the same number of steps as the number of levels or generations in the tree,5,5,5,0.028678417,0.971321583,0.963405706,0.311775029,0.395981913,0.992528686,0.914576471,0.999932732,0.920683443,0.954467537,0.87847024,0.925215158,0.812842406,0.560982049,0.452758027
2266,2266,2435,12.11,to find a node in a binary search tree takes at most the same number of steps as there are levels of the tree.,5,5,5,0.030135512,0.969864488,0.96154642,0.432548374,0.50197819,0.991999581,0.908526933,0.999933583,0.921686794,0.942192492,0.84570717,0.944640035,0.861455376,0.631315291,0.540429367
2267,2267,2436,12.11,"three steps visit the root node, then go to right subtree, after visiting right subtree visit left subtree",0,4.5,2.25,0.071163833,0.928836167,0.909193377,0.104517892,0.214083457,0.985557105,0.834866663,0.999919707,0.905325814,0.809890076,0.492581513,0.94141957,0.853395795,0.504191756,0.381968158
2268,2268,2437,12.11,log n,4.5,5,4.75,0.234557271,0.765442729,0.70069974,0.088721894,0.200220158,0.951713334,0.447912723,0.999773964,0.733478593,0.98423274,0.957915931,0.881117087,0.702481955,0.444033414,0.30697997
2269,2269,2438,12.11,( n(n-1) ) / 2,0,3,1.5,0.212777615,0.787222385,0.728491063,0.012450383,0.13328075,0.985930263,0.839133173,0.999885321,0.864780852,0.996309377,0.990149434,0.91221149,0.780299244,0.253501087,0.069478843
2270,2270,2439,12.11,2n-1,0,4.75,2.375,0.66122672,0.33877328,0.156260097,-0.111379147,0.024602224,0.970397652,0.661540519,0.999507584,0.419386302,0.982426751,0.953095603,0.951068015,0.877542128,0.313551754,0.144332813
2271,2271,2440,12.11,"it takes at most h steps, where h is the height of the tree.",5,5,5,0.028765023,0.971234977,0.963295195,0.585694134,0.636385997,0.98714154,0.852982354,0.999935697,0.92417991,0.930434016,0.814322863,0.918344268,0.79564722,0.697279692,0.622654886
2272,2272,2441,12.11,it depends on the install search tree then from there for whatever the case is the it repeats it back along the case of the primary node,0,3,1.5,0.045449317,0.954550684,0.942005668,0.210919365,0.307466315,0.989932543,0.884893377,0.999931552,0.919291889,0.887525231,0.699795908,0.935192319,0.837811389,0.63228488,0.541637972
